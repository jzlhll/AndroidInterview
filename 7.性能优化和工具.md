

### 启动优化

* 启动线程不宜过多
* 减少使用AMS，WMS的接口，都是带锁执行会导致SystemServer锁等待

* 主题过度优化

从UI视觉上优化冷启动切换体验；

SplashScreen过度启动。

转圈圈的用途。

* Application初始化优化

都是为了加速主线程：通常包括：
	1. 布局初始化
	2. 阻塞主线程的耗时操作，I/O，网络
	3. Bitmap、矢量图等加载
	组织好application里面多组件的初始化，能延迟的放到子线程。编排好初始化顺序。有向无环图。



systrace查看内存占用情况。

启动优化，应用1s内打开。dex，编译优化什么的

https://juejin.im/collection/5a93826a6fb9a00a0f45a454



1. SDK来源库，按照有向无环图DAG来排布, 之间排查依赖关系初始化异步排布，不浪费时间。
2. dex nativecode的热函数处理。插装收集，预支profile.google有一个profile的搞法。
3. 运行时注解，改进为编译时注解。
4. 锁太多。
5. ART optimizing profiles App 安装后，Android Runtime 会随着应用的运行，逐步增量编译应用的热函数，意味着需要 App 运行一阵子才能看到收益。https://source.android.google.cn/devices/tech/perf/pgo?spm=ata.13261165.0.0.2c67391eYZgtSB
   https://android-developers.googleblog.com/2019/04/improving-app-performance-with-art.html?spm=ata.13261165.0.0.2c67391eYZgtSB
6. cpu负载和使用率 还需要关注这个点。不能让他超过指标。
   负载：如果 CPU 每分钟最多处理 100 个进程，那么系统负荷 0.2，意味着 CPU 在这一分钟里处理 了20 个进程，没有达到他的极限；系统负荷 1.0，意味着 CPU 在这一分钟里正好处理 100 个进程；系统负荷 1.7，意味着除了 CPU 正在处理的 100 个进程外，还有 70 个进程正在排队等着 CPU 处理。
   当系统负荷持续大于 0.7，你必须开始调查了，问题出在哪里，防止情况恶化；
   如果只有 1 分钟的系统负荷大于 1.0，其它两个时间段都小于 1.0，这表明只是暂时现象，问题不大。
   如果 15 分钟内，平均系统负荷大于 1.0（调整 CPU 核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察“15 分钟系统负荷”，将它作为电脑正常运行的指标。

#### UI渲染优化

工具：systrace | layoutInspector|hierarchy view
measure, layout, draw每个阶段代码重复运行，耗时操作;
减少层级；约束布局；
无用背景移除，window background null；
背景分段给到子控件上，父控件不设置；
滑动帧率检测；
ViewStub；
动态addView



### ANR

[理解Android ANR的触发原理 - Gityuan博客 | 袁辉辉的技术博客](https://gityuan.com/2016/07/02/android-anr/)

> 设计逻辑就是在起服务，发送广播开始等操作，发出一个TIMEOUT的消息，等执行完成就remove掉这个消息。

Service Timeout:比如前台服务在20s内未执行完成，后台服务Timeout时间是前台服务的10倍，200s；

BroadcastQueue Timeout：比如前台广播在10s内未执行完成，后台60s

ContentProvider Timeout：内容提供者,在publish过超时10s;

InputDispatching Timeout: 输入事件分发超时5s，包括按键和触摸事件。

主线程：其实就是zygote fork出来的application， main函数所在的主线程。

卡顿有2个原因：

>  一个是messageQueue处理消息的next()；可能是绘制过慢。
>
>  一个是dispatchMsg处理太久。

**应用卡顿，原因一般都可以认为是Handler处理消息太耗时导致的**，细分的原因可能是方法本身太耗时、算法效率低、cpu被抢占、内存不足、IPC超时等等。

* ServiceANR:

原因/流程	ActiveServices	Service	超时时间
create	realStartServiceLocked	onCreate	20s/200s
start	sendServiceArgs	onStartCommand	20s/200s
foreground	sendServiceArgs	onStartCommand	10s

设计逻辑都是在执行某个事情的时候，先发送一个delay的anr消息出去；如果干完了就remove掉。否则收到了就开始dump。

* 广播ANR：
  类似。

* ContentProvider ANR：

  创建contentProvider的时候，可会有ANR。

1.当ContentProvider运行与独立进程的时候; onCreate方法运行与该进程的主线程,
其余增删改查等所有方法运行在Binder线程.
2.当ContentProvider运行在调用者同一个进程的时候; onCreate方法运行与该进程的主线程,其余增删改查等所有方法运行在调用时所在的线程.

只有初始化有ANR。后续的CURD其实走的是binder线程。

* Input超时：KeyDispatchTimeout：

  是在c++层，systemServer里面，做的按键事件队列。重置ANR的timeout。而ViewRootImpl会监听按键事件, 处理完成后，移除点击事件的队列消息。

  否则就上报ANR了。

  



### 内存抖动

短时间大量对象分配，又快速释放内存。一般是循环体内创建对象。

主要是onDraw里面重复创建, 对象池等解决方案。

工具：android profiler。

### crash优化

崩溃率指标 0.01%。

#### 崩溃类型

1. java层

   代码逻辑上的exception；

   low memory killer杀掉；

   anr崩溃；

2. native层

#### 崩溃上报

自研SDK。bugly，firebase等。

#### 热修复

已经不火了，主要是google对于反射的api越来越多限制，兼容性较差；现在跨端技术选择很多，有的支持热更新；

直接发新版也比较容易。

#### 崩溃防护

handler post 死循环runnable的方式，收敛到无法无限崩溃的程度。

#### 规范

@NonNull @Nullable

插件



#### 日志分析

java: Fatal, Exception, System.err,  event log

jni:   DEBUG: backtrace, signal, addr, SIGSEGV, SIGABRT, 

​		addr2line, so的符号表

### 内存优化

条件：待申请的内存大于系统分配给应用的剩余内存。 

- 堆内存分配失败
  - 堆内存溢出
  - 没有足够的连续内存空间
- 创建线程失败（pthread_create (1040KB stack) failed: Try again）
- FD数量超出限制
- Native虚拟内存OOM

库：leakcanary，快手KOOM

原因：Bitmap回收慢，Cursor关闭

工具：profiler，MAT，LeakCannary

>  LeakCannary原理大致是通过weakReference和new WeakReference第二个参数的gc回调

内存模型：（方法区[运行时常量池]、堆）、（程序计数器、本地方法栈、虚拟机栈）

#### 内存泄漏

多次抓取prof文件，分析。一般来讲，fragment过多，activity过多，被持有。再分析下MAT里面的objects和引用关系。找到谁耽误了内存释放。

图片的使用，注意RGB565，resize。不过现在都用Glide省去了不少烦恼。



### 线程数量监控

1. 获取线程数量，我们可以读取文件/proc/[pid]/status 中的线程数量

2. Thread.getAllStackTraces();

### Bitmap优化

主动recycler()

imageView也可以设置回收。drawable.getBitmap()



### 卡顿优化  systrace

  16.6ms；vsync。

工具：**systrace**分析分析一些黄色红色区域的方法执行；自行研究代码执行时间等等；

第三方监控：**blockCannary**, **matrix**

> Matrix 当前监控范围包括：应用安装包大小，SQLite 操作优化，帧率变化，卡顿，启动耗时，页面切换耗时，慢方法，文件读写性能，I/O 句柄泄漏， 内存泄漏等。

dumpsys activity oom; 

dumpsys meminfo cpuinfo, input window

Trace Canary 通过 choreographer 回调、编译期插桩的方式，



### 数据库/Sqlite优化

[Android 数据库系列三：复杂项目SQL治理与数据库的优化总结本篇主要介绍在我们的业务中，我们是如何在wcdb基础上 - 掘金](https://juejin.cn/post/7338306790173704192/)

### SharedPerfence优化

头条hook的方案。优化卡住主线程的可能。



### 网络优化

| 层面         | 策略                             | 目的                                                         |
| :----------- | :------------------------------- | :----------------------------------------------------------- |
| **协议层**   | 优先选择BLE                      | 更低功耗，更快重连                                           |
|              | 优化连接参数（间隔、延迟、超时） | 适应弱网环境，避免误断连                                     |
| **应用层**   | **实现应用级ACK/重传**           | **核心中的核心，保证可靠性**                                 |
|              | 序列号与去重                     | 处理重复包                                                   |
|              | 数据分片                         | 适应MTU，提高小包成功率                                      |
|              | 心跳机制                         | 保活、检测连接状态                                           |
|              | 退避算法                         | 重传时，每次重传的间隔可以指数级增加（如1s, 2s, 4s, 8s...），避免网络恢复时大量重传包拥塞链路。避免网络拥塞 |
| **业务逻辑** | 幂等性设计                       | 防止重复执行产生错误                                         |
|              | 增量更新 & 优先级队列            | 减少数据量，保证关键数据及时发送                             |

**使用无连接的、不可靠的UDP作为传输层，并在其之上自主实现一套包含可靠性、有序性和拥塞控制的应用层协议**。

假设我们设计无人机和控制器之间的协议：

1. **包类型 (Packet Type)**:
   - `0x01`: **CMD** (控制指令，需要可靠ACK)
   - `0x02`: **ACK** (确认包)
   - `0x03`: **TELEMETRY** (遥测数据，如位置、电量，可不可靠或低可靠性)
   - `0x04`: **VIDEO_FRAME** (视频帧，不可靠传输，容忍丢包)
   - `0x05`: **HEARTBEAT** (心跳包)
2. **通信流程**:
   - **控制器 -> 无人机 (发送指令)**:
     - 发送一个 `CMD` 包，`Seq = 100`，载荷是 `{pitch: 10, yaw: 5, throttle: 50}`。
     - 启动重传定时器（超时时间 e.g., 100ms）。
   - **无人机 -> 控制器 (回复ACK)**:
     - 成功执行指令后，回复一个 `ACK` 包，`Ack = 100`。
   - **控制器 (处理ACK)**:
     - 收到 `ACK 100`，清除该指令的重传定时器。
   - **无人机 -> 控制器 (持续发送)**:
     - 以30fps的速率发送 `VIDEO_FRAME` 包，这些包没有序列号或不需要ACK，即使丢失一些，视频也只会短暂花屏而不会卡住。
     - 以10Hz的频率发送关键的 `TELEMETRY` 数据（如电量报警），这些包可以带有序列号和轻量级重传机制。

### 多线程优化

volatile

synchronized

AtomicXXX

jdk1.6以后，推荐使用synchronized，java源码都改用了。

synchronized的升级过程：

->偏向锁（偏向加锁的第一个线程来抢占则不用同步处理；）

->轻量级锁（不释放cpu，自旋锁CAS，就是在JVM层面，在锁门口等着期待着别人释放，马上抢进去）

->重量级锁（系统内核态用户态切换，挂起线程，阻塞）

锁的嵌套：死锁的解决:

reentrantLock其实也是重量级锁，只是能够tryLock，打断，等一些特殊灵活的使用。



#### 多线程编程

asyncTask、HandlerThread、IntentService、ThreadPoolExcutors



### APK体积优化

无用资源清理；

gradle编译忽略；

proguard忽略；

第三方包的精简；

tinypng；shape|selector图形背景色；

微信的资源压缩方案；

混淆；

facebook redex优化字节码。

动态加载so

> Play Store 动态代码禁用问题
>
> 由于一些众所周知的原因，包含有动态代码的 APK 包是无法上传到 Play Store 的。不过实际上 Google 不是禁止动态代码，而是禁止绕过 Play 渠道下发未经过审核的动态代码。经过咨询，通过 Play 提供的 APK 拓展资源包 Expansion Files 服务，可以向客户端下发相关插件资源包，没有政策风险（该服务主要是面向游戏客户端，可以向 APK 客户端下发绑定版本的“一个主资源包 + 一个 patch 包”，体积上限个 1G。需要说明的是，用户发布特定版本的 APK 之前必须先绑定资源包，一旦发布就无法修改）。



### BlockCanary/Matrix/UIBlockMonitor

<img src=".\pictures\blockCanary原理.png" alt="blockCanary原理" style="zoom:47%;" />

通过监听Looper的messageLogging的接口来做消息是否回来的执行。

而腾讯通过Choreographer，接收vsync信号，注册framecallback来监听相邻两帧之间的执行耗时

而华为通过MessageQueue插入空message。

### LeakCanary

**监控对象生命周期** → **触发GC并验证存活** → **分析引用链**。

基本流程：

通过一些手段监听viewModel，Service，Activity, Fragment的生命周期，在他们destroy的时候，通过**WeakReference**+**ReferenceQueue**来弱引用他们。然后过一会儿触发GC，看看是否存活。再通过heap dump下来，分析GC root。

概念和手段：

Activity监控：ActivityLifecycleCallbacks

Fragment监控：activity.supportFragmentManager.registerFragmentLifecycleCallbacks

Service、ViewModel有一些hook的办法来达到监听destroy的目的。

heap dump：堆抓取hprof文件



### MAT

`adb shell am dumpheap <PID> /sdcard/heapdump.hprof`

就可以得到hprof文件。

拖入到MAT工具。有独立版本。

多关注Retained Heap，GC roots来看看哪些内存是无限多份的。

多关注Thread Overview，看看线程是否有跑过多，没有停下的。



### Profiler

开发过程中使用，火焰图比较直观之类的。

日志也有skip xxx frames。可以看出打开界面这段时间是有掉帧的。



### sysTrace和perfetto

adb shell perfetto -t 60s -o trace_file.perfetto-trace

然后导入到chrome://tracing里面去分析。

* SurfaceFlinger 负责合成surface，主要关注dequeueBuffer/queueBuffer的耗时。屏下光感截图方案影响app首帧。
* HWC Service耗时影响阻塞卡顿
* IO卡顿：
* APP卡顿：关注traversal/measure/Choreographer#doFrame 各阶段颜色
  （Draw超时图）

<img src=".\pictures\appDraw超时.png" alt="appDraw超时" style="zoom:80%;" />

​	（Animation超时图）

<img src=".\pictures\app动画超时.png" alt="appDraw超时" style="zoom:80%;" />

​	（AppView初始化超时图）

<img src=".\pictures\appViewInit超时.png" alt="appDraw超时" style="zoom:50%;" />

​	（App使用CPU渲染超时图）

<img src=".\pictures\appCpu渲染超时.png" alt="appDraw超时" style="zoom:50%;" />

​	（查看GPU参与）

<img src=".\pictures\renderThreadGpu.png" alt="appDraw超时" style="zoom:50%;" />

​	（无GPU参与）

<img src=".\pictures\NoRenderThreadCpu.png" alt="appDraw超时" style="zoom:50%;" />

### 低内存分析

dumpsys meminfo

cat /proc/meminfo

特征：

* FreeRam很少，UsedRam非常大

* low memory killer/kswapd线程十分活跃

  kernelLog：lowmemorykiller killing...adj...

* Trace有Uninterruptible Sleep | WakeKill Block | kernel callsite when blocked wait on page bit

* CPU竞争：kswapd0频繁跑，主要是内存不足的时候被唤醒，导致应用得不到cpu调度
