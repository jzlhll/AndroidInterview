

### 启动优化

* 启动线程不宜过多
* 减少使用AMS，WMS的接口，都是带锁执行会导致SystemServer锁等待

* 主题过度优化

从UI视觉上优化冷启动切换体验；

SplashScreen过度启动。

转圈圈的用途。

* Application初始化优化

都是为了加速主线程：通常包括：
	1. 布局初始化
	2. 阻塞主线程的耗时操作，I/O，网络
	3. Bitmap、矢量图等加载
	组织好application里面多组件的初始化，能延迟的放到子线程。编排好初始化顺序。有向无环图。



systrace查看内存占用情况。

启动优化，应用1s内打开。dex，编译优化什么的

https://juejin.im/collection/5a93826a6fb9a00a0f45a454



1. SDK来源库，按照有向无环图DAG来排布, 之间排查依赖关系初始化异步排布，不浪费时间。
2. dex nativecode的热函数处理。插装收集，预支profile.google有一个profile的搞法。
3. 运行时注解，改进为编译时注解。
4. 锁太多。
5. ART optimizing profiles App 安装后，Android Runtime 会随着应用的运行，逐步增量编译应用的热函数，意味着需要 App 运行一阵子才能看到收益。https://source.android.google.cn/devices/tech/perf/pgo?spm=ata.13261165.0.0.2c67391eYZgtSB
   https://android-developers.googleblog.com/2019/04/improving-app-performance-with-art.html?spm=ata.13261165.0.0.2c67391eYZgtSB
6. cpu负载和使用率 还需要关注这个点。不能让他超过指标。
   负载：如果 CPU 每分钟最多处理 100 个进程，那么系统负荷 0.2，意味着 CPU 在这一分钟里处理 了20 个进程，没有达到他的极限；系统负荷 1.0，意味着 CPU 在这一分钟里正好处理 100 个进程；系统负荷 1.7，意味着除了 CPU 正在处理的 100 个进程外，还有 70 个进程正在排队等着 CPU 处理。
   当系统负荷持续大于 0.7，你必须开始调查了，问题出在哪里，防止情况恶化；
   如果只有 1 分钟的系统负荷大于 1.0，其它两个时间段都小于 1.0，这表明只是暂时现象，问题不大。
   如果 15 分钟内，平均系统负荷大于 1.0（调整 CPU 核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察“15 分钟系统负荷”，将它作为电脑正常运行的指标。

#### UI渲染优化

工具：systrace | layoutInspector|hierarchy view
measure, layout, draw每个阶段代码重复运行，耗时操作;
减少层级；约束布局；
无用背景移除，window background null；
背景分段给到子控件上，父控件不设置；
滑动帧率检测；
ViewStub；
动态addView



### ANR

[理解Android ANR的触发原理 - Gityuan博客 | 袁辉辉的技术博客](https://gityuan.com/2016/07/02/android-anr/)

> 设计逻辑就是在起服务，发送广播开始等操作，发出一个TIMEOUT的消息，等执行完成就remove掉这个消息。

Service Timeout:比如前台服务在20s内未执行完成，后台服务Timeout时间是前台服务的10倍，200s；

BroadcastQueue Timeout：比如前台广播在10s内未执行完成，后台60s

ContentProvider Timeout：内容提供者,在publish过超时10s;

InputDispatching Timeout: 输入事件分发超时5s，包括按键和触摸事件。

主线程：其实就是zygote fork出来的application， main函数所在的主线程。

卡顿有2个原因：

>  一个是messageQueue处理消息的next()；可能是绘制过慢。
>
>  一个是dispatchMsg处理太久。

**应用卡顿，原因一般都可以认为是Handler处理消息太耗时导致的**，细分的原因可能是方法本身太耗时、算法效率低、cpu被抢占、内存不足、IPC超时等等。

* ServiceANR:

原因/流程	ActiveServices	Service	超时时间
create	realStartServiceLocked	onCreate	20s/200s
start	sendServiceArgs	onStartCommand	20s/200s
foreground	sendServiceArgs	onStartCommand	10s

设计逻辑都是在执行某个事情的时候，先发送一个delay的anr消息出去；如果干完了就remove掉。否则收到了就开始dump。

* 广播ANR：
  类似。

* ContentProvider ANR：

  创建contentProvider的时候，可会有ANR。

1.当ContentProvider运行与独立进程的时候; onCreate方法运行与该进程的主线程,
其余增删改查等所有方法运行在Binder线程.
2.当ContentProvider运行在调用者同一个进程的时候; onCreate方法运行与该进程的主线程,其余增删改查等所有方法运行在调用时所在的线程.

只有初始化有ANR。后续的CURD其实走的是binder线程。

* Input超时：KeyDispatchTimeout：

  是在c++层，systemServer里面，做的按键事件队列。重置ANR的timeout。而ViewRootImpl会监听按键事件, 处理完成后，移除点击事件的队列消息。

  否则就上报ANR了。

  



### 内存抖动

短时间大量对象分配，又快速释放内存。一般是循环体内创建对象。

主要是onDraw里面重复创建, 对象池等解决方案。

工具：android profiler。

### crash优化

崩溃率指标：

接入工具库：bugly；阿里内部也有工具监控；firebase。

崩溃类型：

1. java层

   代码逻辑上的exception；

   low memory killer杀掉；

   anr崩溃；

2. native层

#### 日志分析

java: Fatal, Exception, System.err,  event log

jni:   DEBUG: backtrace, signal, addr, SIGSEGV, SIGABRT, 

​		addr2line, so的符号表

### 内存优化

Bitmap回收慢, Cursor关闭, 



工具：profiler，MAT，LeakCannary

>  LeakCannary原理大致是通过weakReference和new WeakReference第二个参数的gc回调

内存模型：（方法区[运行时常量池]、堆）、（程序计数器、本地方法栈、虚拟机栈）

#### 内存泄漏

工具：profiler，MAT。

多次抓取prof文件，分析。一般来讲，fragment过多，activity过多，被持有。再分析下MAT里面的objects和引用关系。找到谁耽误了内存释放。

图片的使用，注意RGB565，resize。不过现在都用Glide省去了不少烦恼。



### Bitmap优化

主动recycler()

imageView也可以设置回收。drawable.getBitmap()





### 卡顿优化  systrace

  16.6ms；vsync。

工具：systrace

​			分析分析一些黄色红色区域的方法执行；自行研究代码执行时间等等；

​            blockCannary

dumpsys activity oom; 

dumpsys meminfo cpuinfo, input window



### SharedPerfence优化

### Sqlite优化

### 网络优化

### 多线程优化

volatile

synchronized

AtomicXXX

jdk1.6以后，推荐使用synchronized，java源码都改用了。

synchronized的升级过程：

->偏向锁（偏向加锁的第一个线程来抢占则不用同步处理；）

->轻量级锁（不释放cpu，自旋锁CAS，就是在JVM层面，在锁门口等着期待着别人释放，马上抢进去）

->重量级锁（系统内核态用户态切换，挂起线程，阻塞）

锁的嵌套：死锁的解决:

reentrantLock其实也是重量级锁，只是能够tryLock，打断，等一些特殊灵活的使用。



#### 多线程编程

asyncTask、HandlerThread、IntentService、ThreadPoolExcutors



### APK优化

无用资源清理；gradle编译忽略；proguard忽略；第三方包的精简。

tinypng；shape|selector图形背景色；

微信的资源压缩方案；

混淆；

facebook redex优化字节码。

### LeakCanary

**监控对象生命周期** → **触发GC并验证存活** → **分析引用链**。

基本流程：

通过一些手段监听viewModel，Service，Activity, Fragment的生命周期，在他们destroy的时候，通过**WeakReference**+**ReferenceQueue**来弱引用他们。然后过一会儿触发GC，看看是否存活。再通过heap dump下来，分析GC root。

概念和手段：

Activity监控：ActivityLifecycleCallbacks

Fragment监控：activity.supportFragmentManager.registerFragmentLifecycleCallbacks

Service、ViewModel有一些hook的办法来达到监听destroy的目的。

heap dump：堆抓取hprof文件



### MAT

`adb shell am dumpheap <PID> /sdcard/heapdump.hprof`

就可以得到hprof文件。

拖入到MAT工具。有独立版本。

多关注Retained Heap，GC roots来看看哪些内存是无限多份的。

多关注Thread Overview，看看线程是否有跑过多，没有停下的。



### Profiler

开发过程中使用，火焰图比较直观之类的。

日志也有skip xxx frames。可以看出打开界面这段时间是有掉帧的。



### sysTrace和perfetto

adb shell perfetto -t 60s -o trace_file.perfetto-trace

然后导入到chrome://tracing里面去分析。

* SurfaceFlinger 负责合成surface，主要关注dequeueBuffer/queueBuffer的耗时。屏下光感截图方案影响app首帧。
* HWC Service耗时影响阻塞卡顿
* IO卡顿：
* APP卡顿：关注traversal/measure/Choreographer#doFrame 各阶段颜色
  （Draw超时图）

<img src=".\pictures\appDraw超时.png" alt="appDraw超时" style="zoom:80%;" />

​	（Animation超时图）

<img src=".\pictures\app动画超时.png" alt="appDraw超时" style="zoom:80%;" />

​	（AppView初始化超时图）

<img src=".\pictures\appViewInit超时.png" alt="appDraw超时" style="zoom:50%;" />

​	（App使用CPU渲染超时图）

<img src=".\pictures\appCpu渲染超时.png" alt="appDraw超时" style="zoom:50%;" />

​	（查看GPU参与）

<img src=".\pictures\renderThreadGpu.png" alt="appDraw超时" style="zoom:50%;" />

​	（无GPU参与）

<img src=".\pictures\NoRenderThreadCpu.png" alt="appDraw超时" style="zoom:50%;" />

### 低内存分析

dumpsys meminfo

cat /proc/meminfo

特征：

* FreeRam很少，UsedRam非常大

* low memory killer/kswapd线程十分活跃

  kernelLog：lowmemorykiller killing...adj...

* Trace有Uninterruptible Sleep | WakeKill Block | kernel callsite when blocked wait on page bit

* CPU竞争：kswapd0频繁跑，主要是内存不足的时候被唤醒，导致应用得不到cpu调度
