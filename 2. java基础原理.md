### HashMap

hashMap vs ConcurrentHashMap



### Java线程同步

#### 关键字

volatile关键字：

内存可见性：(修改后缓存及时变更。因为极快的时候，cpu是改了，但是内存变量并没有快速更新。)

原子性：volatile不保证。无法做i++操作。所以一般是bool的赋值或者变量的单例。

有序性：通过**内存屏障**，禁止指令重排。jvm保证单线程执行结果无误；但是多线程不保证。

synchronized：

**临界区**。

保证上述3个特性。



* 单例，为什么需要双检测？

> 首先外层的null判断其实是为了减少使用synchronized，因此，外层不是临界区了。那么就会存在线程1正在分配单例对象，内部并没有完成初始化完成；而线程2由于外层判断不为null，使用了它就会导致错误。所以需要volatile来保证指令不重排。

* volatile 不能保证原子性

> 防止指令重排，比如a=1;a=2;a=3就会被优化为a=3，就是要求必须从内存中读取和写入，而不是从寄存器中。比如多线程while(flag)，这个flag如果不修饰为volatile的话，可能另外的线程改变了它，却没有反应到当前的寄存器中。
>
> java中，
>
> 保证3项：受限原子性（i++就不是volatile能搞定的，因为涉及到3步骤，多线程下无效），
>
> ```
> 			 可见性（新值可以被其他线程看到，普通变量不行，需要在主内存中传递），
> 
> 			顺序性（禁止指令重排，指令重排比如a=1;a=2;a=3就会被优化为a=3）
> ```
>
> https://www.cnblogs.com/wildwolf0/p/11449506.html
>
> volatile写的内存语义：当写线程写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。
>
> volatile读的内存语义：当读线程读一个volatile变量时，JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存读取共享变量。
>
> 内存屏障（一组处理器指令，实现对内存操作的顺序限制），缓存行（CPU高速缓存中的最小存储单位）。
>
> 在一个处理器将自己缓存行的数据写回到系统内存后，其他的每个处理器就会通过嗅探在总线上传播的数据来检查自己缓存的数据是否已过期，当处理器发现自己缓存行对应的内存地址的数据被修改后，就会将自己缓存行缓存的数据设置为无效，当处理器要对这个数据进行修改操作的时候，会重新从系统内存中把数据读取到自己的缓存行，重新缓存。
>
> **volatile可见性的实现就是借助了CPU的lock指令，通过在写volatile的机器指令前加上lock前缀**，使写volatile具有以下两个原则：
>
> ```
> 1. 写volatile时处理器会将缓存写回到主内存。
> 2. 一个处理器的缓存写回到内存会导致其他处理器的缓存失效。
> ```
>
> 这就保证了可见性。
>
> 禁止指令重排就能保证有序性，插入内存屏障，loadStore，load。
>
> https://blog.csdn.net/a779868946/article/details/105904932
>
> 总结：volatile使用了cpu的lock指令，和使用内存屏障完成了可见性和有序性。但是原子性只限定于单个量的读和写的操作，如果遇到i++或者i<j这种2，三个操作将无能为力。



#### 锁的种类，特性

java1.5优化synchronized,之前是完全依赖于重要级锁，需要在用户态切换到内核态，需要操作系统的接入；优化后，首先假设只有一个线程会占用，锁为偏向锁，减少这个线程二次进入获取锁的代价；其次，当第二个线程来竞争，锁升级为轻量级锁，通过CAS尝试一段时间(几十次)，因为这是假定大部分情况不需要锁住太久，虽然不断重试也消耗cpu，但切换内核态挂起线程也比较消耗；所以，当尝试过多就进入原来的重量级锁。

https://www.cnblogs.com/hustzzl/p/9343797.html 介绍了很多很多的锁。其实锁的概念引入了很多的名词，(非)公平锁，乐观/悲观等等。

### 反射

android中反射，有一些限定。



### 泛型

略。

### 注解

纯java运行时注解。

编译时注解。

### 多线程

executorService比较简单：

```java
static ExcutorService myNewTest() {
  ExecutorService pool = new ThreadPoolExecutor(2, 4, 60000L, TimeUnit.MILLISECONDS, 
  new ArrayBlockingQueue<Runnable>(3), 
  Executors.defaultThreadFactory(), 
  new ThreadPoolExecutor.AbortPolicy());
  //我们给coreSize2，maxSize4，并且给了ArrayBlockingQueue容量为3的队列。
  //所以当前我们可以先跑2个线程运行，并且队列是空着的；
  //这个时候2个线程还没有干完，又来活儿了，加入到队列中，直到满；
  //当满了，如果maxSize是大于coreSize的，会将现在来的任务直接干（也就是比先加入队列的还要先干活，是不是超出你的想象？）
  //如果还是超过了，就报错。
}

//以下是源码中的Excutors.java:
public static ExecutorService newSingleThreadExecutor() {
  return new FinalizableDelegatedExecutorService
    (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>()));
  //单线程池
  //coreSize，maxSize为1，表示了不可能有额外创建线程的可能；只有1个。
  //时间是0，永远不释放。
  //并且使用链表无限排队。
}

public static ExecutorService newCachedThreadPool() {
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue<Runnable>());
  //与OKHTTP内部线程模型一样
  //coreSize 0, 60的时间，表示没活一段时间后会释放；
  //SynchronousQueue,一个假的队列一直是满的。根据图片规则，超过了就新建线程去了。
  //同时，maxSize Int上限，表示无线创建线程；
  //适用于最大化并发，并且又能够在一定时间内的复用线程。
}

public static ExecutorService newFixedThreadPool(int nThreads) {
  return new ThreadPoolExecutor(nThreads, nThreads,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>());
  //coreSize=maxSize表明不能新建；
  //linkedblockingQueue表明无限压任务排队；
  //0L时间表示不回收线程。
  //适用于固定数量的线程，永远不回收。与单个线程类似。
}
```

自定义线程池：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
```

corePoolSize：描述核心个数。超过核心个数会进入BlockingQueue；

maxSize:          描述最多创建线程数。

blockQueue:   对逻辑产生重大影响。

* SynchronousQueue（无内部容量同步队列）

  没有容量，即（队列是否满了）判断永远是“满了”。

* ArrayBlockingQueue （指定容量的数组阻塞队列）

* LinkedBlockingQueue( 链表阻塞队列) 

  内部是链表，无限往下挂item，即(队列是否满了)判断永远为“未满”。

<img src="https://img-blog.csdnimg.cn/8848b183c1c9471a81d6f6a5a41efede.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAanpsaGxsMTIz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:45%;" />

深入理解和背诵图片，结合，如下4个case大致上就掌握了：



### ThreadLocal内存泄漏的原因

* weakReference和threadLocal的基本用法

  必须放在这里，因为后面好用于解析源码的时候回忆。

```java
//weak ref
WeakReference<Activity> ref = new WeakReference<>(activity);

//thread local
ThreadLocal<String> local = new ThreadLocal<>();
local.set("test");
String s = local.get();
local.remove();
```

* 代码结构

<img src="https://i-blog.csdnimg.cn/blog_migrate/9881acb6c08058a18504acf3a1439054.png#pic_center" alt="threadLocal" style="zoom:40%;" />

画图结合使用逻辑，就清楚了。

假设我们自己的代码中local已经没有引用了，比如Test已经置为null，或者local置为null，可达性已经失去；

那么，作为Entry的key就被回收；而value是强引用设置的值，如果是复杂类型数据的话，就会长时间留存在ThreadLocalMap(table)数组中。在某些get(), remove() , resize() 扩容,set()动作的时候，会尝试clear部分key为null的entry，移除数组并标记value=null，去除引用。

但是这些动作并不一定能跑进去。而且假设你申请的local并不是特别频繁使用的话（即很少调用set，remove, get），这个value的引用将会存在无法回收。

**解决方案：用完记得remove掉。比如Thread结束的时候，或者数据使用完后，记得remove()。有的帖子说搞成static，下面我将Handler会提到。**

* 扩展点1：多线程下有几个local？几个map？多个local变量申明呢？

  * 假设1个local变量，多线程：

    这个很容易理解了吧，每个Thread下面都挂着一个map，只是我们这一个local被多次拿去做Entry key了，保存着不同的value。

    Android Handler就是这个模式。

  * 假设多个local变量，单线程：

    <img src="https://i-blog.csdnimg.cn/blog_migrate/926da668cd9b6f8fbdc56d5b381f459d.png#pic_center" alt="threadlocalMulti" style="zoom:33%;" />

    如灵魂画手，即，该线程下的map的数组不再是单个Entry元素了。而是多个k v组成。

  * 假设多个local变量，多线程：

    这下好理解了，不用多说。每一个线程都有map，map下的数组就对应有多个Entry（local组成弱引用的key，和value）。

    


* 扩展点2 Android Handler

      就是把Looper对象，申明了一个static的LocalThread<Looper>在我们prepare的时候，进行初始化。这样的情况，就保证了每一个线程，在new出来的时候，都会创建一个独有的Looper。
      
      所以说，ThreadLocal和Thread有什么关系呢？Thread只和ThreadLocalMap有关，而我们申明的变量，ThreadLocal是作为ThreadLocalMap的数组中一个元素的key(weakRef)。

  那为什么在Handler和Looper源码中看不到remove来解决内存泄漏呢？

  这里他使用static来标记threadLocal变量。即保证了所有线程只有一个key。这个key永远不会被回收了。则不会出现key=null，value存在的现象。但是假设HandlerThread被回收，Looper作为value会被先回收。理论上讲，他并没有考虑内存问题。如果线程和Looper搞的多，在前面提到的逻辑中，靠的ThreadLocal内部代码的比如set，或者resize的时候，进行清理（详细可以阅读ThreadLocal.java：set()->cleanSomeSlots，即每次设置值都会尝试清理清理）。

  

### JVM运行时分区

进程共享：方法区(常量池) （类信息，常量，静态变量）,  堆区（类的全局变量跟随类new出来的）；

线程私有： 虚拟机栈（临时变量），本地方法栈，程序计数器。

### classLoader

类加载器，最开始是给Java Applet（一种Html+下载Java代码来执行逻辑的应用程序）。这就要求JVM能够动态加载java代码，因而设计出来。

`java.lang.ClassLoader` 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 `java.lang.Class` 类的一个实例。

https://developer.ibm.com/zh/articles/j-lo-classloader/

https://www.jianshu.com/p/fe2f739928ec

https://segmentfault.com/a/1190000004062880

https://blog.csdn.net/dongbaoming/article/details/54312824?utm_source=blogxgwz5



### java类加载流程

Loading：查找class到内存

Linking:  验证(字节码是否合规)，准备(静态变量，空间并附默认值)，解析（直接引用常量池）

Initialization: 初始化，真正的值变更。

类从被加载到JVM中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。

#### 类加载器&双亲委托

* java里面：

customClassLoader->applicationClassloader->extersionClassLoader->bootstrapClassLoader

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // First, check if the class has already been loaded
    // 1.先查找该 Class 是否已经加载过，若加载过，则直接返回。
    Class<?> c = findLoadedClass(name);
    if (c == null) {
        try {
            if (parent != null) {
                // 2.委托给父加载器进行加载。
                c = parent.loadClass(name, false);
            } else {
                // 当执行到顶层的类加载器时，parent = null
                c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // ClassNotFoundException thrown if class not found
            // from the non-null parent class loader
        }

        if (c == null) {
            // 3.如果父加载器也没有找到，则自己尝试加载。该方法的逻辑由具体子加载器实现。
            c = findClass(name);
        }
    }
    return c;
}

// 由子类自己实现
protected Class<?> findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
```

像极了事件分发，onInterept()就是在本类中进行拦截，就直接return掉完成了；

如果本类不做处理，则给到parent去loadClass。如果parent有返回就是返回的。如果parent没有返回的，则最终才轮到自己去创建，就像只有子View不消费，父控件才能触发自己的onTouchEvent。

也相当于二叉树的后序遍历。

```java
public void visit(TreeNode n) {
   //前序点拦截
   visit(n.left);
   visit(n.right);
   print(n.val); //后序点
}
```

前序遍历点做拦截处理；能最快的打破往下传递。

后序遍历点做自己的实现(打印，消费事件），当自己被访问链，即将离开的时候，才处理。



与事件分发的区别在于：

事件分发机制，onInterupt()是极度容易，而这里的拦截是父类的native方法。仅仅起到后续二次加载cache而已。



* 打破双亲委托

  loadClass修改；Thread处理；自定义classLoader。android一般用不上。 

* android里面：

  我们加载的dex文件，因此必须要自己实现classLoader了。

  主要分为：

  BootClassLoader（加载常用类）；

  PathClassLoader（加载系统类和应用程序类，已经安装的程序的dex）；

  DexClassLoader（可以用于外部加载dex，apk）

* 热修复：

  修复的原理就是将补丁 dex 文件放到 dexElements 数组靠前位置，这样在加载 class 时，优先找到补丁包中的 dex 文件，加载到 class 之后就不再寻找，从而原来的 apk 文件中同名的类就不会再使用，从而达到修复的目的。Application初始化就加载好它。



### jdk动态代理

使用上，

1）必须实现InvocationHandler接口；

2）使用Proxy.newProxyInstance产生代理对象；

3）被代理的对象必须要实现接口。

```java
public interface IString {
    int length(String s);
}

System.out.println("s addr: " + System.identityHashCode(s));

IString news = (IString) Proxy.newProxyInstance(IString.class.getClassLoader(), new Class[] { IString.class},
                                                new InvocationHandler() {
                                                  @Override
                                                  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                                    System.out.println("proxy addr: " + System.identityHashCode(proxy));
                                                    int an = (int) method.invoke(s, args); //重点：第一个参数是被代理的对象。
                                                    return an + 1;
                                                  }
                                                });

System.out.println(" news addr: " + System.identityHashCode(news));
var ans = news.length("hello");
System.out.println("ans: " + ans);

//执行结果
s addr: 2055281021
news addr: 834600351
proxy addr: 834600351
ans: 6
```

在invoke里面，

我们可以针对被代理的结果进行修改；或者插入额外执行信息；
甚至可以完全不调用它，换成adapter适配模式一样，替换掉。
还可以使用动态代理做成一种网络运行参数的配置规则。通过注解不同的interface，解析注解来访问网络。

* 原理

1. JDK里面源码，就是在Proxy.newProxyInstance的传入参数，

第二是传入想要代理的接口类，第三是传入InvocationHandler处理函数。

2. 动态生成的代码，类似如下：

```java
public class NewStringImpl extends Proxy implements IString{
    protected InvocationHandler h; //在父类Proxy里面
  
    private static Method m1;
    private static Method m0;
    private static Method m3;
    private static Method m2;
  
  	public String length() {
       h.invoke(this, m, null);
    }
  
    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
  
      static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
            m2 = Class.forName("java.lang.Object").getMethod("toString");
          
            m3 = Class.forName("xxxx.IString").getMethod("length");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```

也就是说，JDK帮我们生成了一个类:

1. 它继承了Proxy；父类Proxy里面含有一个我们构造的时候的第三个参数InvocationHandler h；
2. 实现了我们传入的第二个参数接口；

3. 生成了toString, hashCode, equals三个静态变量method，和目标函数静态变量method；
4. 在我们调用接口的函数的时候，触发的执行其实就是执行了InvocationHandler的回调。而method.invoke(Object obj, Object... args)，第一个参数为对象（即Proxy.newInstanace出来的这个对象）。

因此，需要注意：

不能在invoke函数里面调用System.out.println(proxy)，会导致死循环，因为toString也会invoke给到这个函数。导致不断死循环。

可以看到，m0~m3的class.forname。才会有框架代码判断if (Object.class.equals(method.getDeclaringClass())) 的拦截。