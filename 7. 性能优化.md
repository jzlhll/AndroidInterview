### 启动优化
#### 主题过度优化
从UI视觉上优化冷启动切换体验；
#### Application初始化优化
都是为了加速主线程：通常包括：
	1. 布局初始化
	2. 阻塞主线程的耗时操作，I/O，网络
	3. Bitmap、矢量图等加载
	组织好application里面多组件的初始化，能延迟的放到子线程。编排好初始化顺序。有向无环图。CountdownLatch



systrace查看内存占用情况。

启动优化，应用1s内打开。dex，编译优化什么的

https://juejin.im/collection/5a93826a6fb9a00a0f45a454



1. 动态加载页面。启动app转圈圈举例DVR视频浏览加载。
2. SDK来源库，按照有向无环图DAG来排布, 之间排查依赖关系初始化异步排布，不浪费时间。
3. dex nativecode的热函数处理。插装收集，预支profile.google有一个profile的搞法。
4. 运行时注解，改进为编译时注解。
5. 锁太多。
6. ART optimizing profiles App 安装后，Android Runtime 会随着应用的运行，逐步增量编译应用的热函数，意味着需要 App 运行一阵子才能看到收益。https://source.android.google.cn/devices/tech/perf/pgo?spm=ata.13261165.0.0.2c67391eYZgtSB
   https://android-developers.googleblog.com/2019/04/improving-app-performance-with-art.html?spm=ata.13261165.0.0.2c67391eYZgtSB
7. cpu负载和使用率 还需要关注这个点。不能让他超过指标。
   负载：如果 CPU 每分钟最多处理 100 个进程，那么系统负荷 0.2，意味着 CPU 在这一分钟里处理 了20 个进程，没有达到他的极限；系统负荷 1.0，意味着 CPU 在这一分钟里正好处理 100 个进程；系统负荷 1.7，意味着除了 CPU 正在处理的 100 个进程外，还有 70 个进程正在排队等着 CPU 处理。
   当系统负荷持续大于 0.7，你必须开始调查了，问题出在哪里，防止情况恶化；
   如果只有 1 分钟的系统负荷大于 1.0，其它两个时间段都小于 1.0，这表明只是暂时现象，问题不大。
   如果 15 分钟内，平均系统负荷大于 1.0（调整 CPU 核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察“15 分钟系统负荷”，将它作为电脑正常运行的指标。

#### UI渲染优化

工具：systrace | layoutInspector|hierarchy view
measure, layout, draw每个阶段代码重复运行，耗时操作;
减少层级；约束布局；
无用背景移除，window background null；
背景分段给到子控件上，父控件不设置；
滑动帧率检测；
ViewStub；
动态addView

### 内存抖动

短时间大量对象分配，又快速释放内存。一般是循环体内创建对象。

主要是onDraw里面重复创建, 对象池等解决方案。

工具：android profiler。

### crash优化

崩溃率指标：

接入工具库：bugly；阿里内部也有工具监控。

崩溃类型：

1. java层

   代码逻辑上的exception；

   low memory killer杀掉；

   anr崩溃；

2. native层

#### 日志分析

java: Fatal, Exception, System.err,  event log

jni:   DEBUG: backtrace, signal, addr, SIGSEGV, SIGABRT, 

​		addr2line, so的符号表

### 内存优化

工具：profiler，MAT，LeakCannary

>  LeakCannary原理大致是通过weakReference和new WeakReference第二个参数的gc回调

内存模型：（方法区[运行时常量池]、堆）、（程序计数器、本地方法栈、虚拟机栈）

#### 内存泄漏

工具：profiler，MAT。

多次抓取prof文件，分析。一般来讲，fragment过多，activity过多，被持有。再分析下MAT里面的objects和引用关系。找到谁耽误了内存释放。

图片的使用，注意RGB565，resize。不过现在都用Glide省去了不少烦恼。

### 卡顿优化  

  16.6ms；vsync。

工具：systrace

​			分析分析一些黄色红色区域的方法执行；自行研究代码执行时间等等；

​            blockCannary

### SharedPerfence优化

### Sqlite优化

### 网络优化

### 多线程优化

volatile

synchronized

AtomicXXX

jdk1.6以后，推荐使用synchronized，java源码都改用了。

synchronized的升级过程：

->偏向锁（偏向加锁的第一个线程来抢占则不用同步处理；）

->轻量级锁（不释放cpu，自旋锁CAS，就是在JVM层面，在锁门口等着期待着别人释放，马上抢进去）

->重量级锁（系统内核态用户态切换，挂起线程，阻塞）

锁的嵌套：死锁的解决:

reentrantLock其实也是重量级锁，只是能够tryLock，打断，等一些特殊灵活的使用。



#### 多线程编程

asyncTask、HandlerThread、IntentService、ThreadPoolExcutors



### APK优化

无用资源清理；gradle编译忽略；proguard忽略；第三方包的精简。

tinypng；shape|selector图形背景色；

微信的资源压缩方案；

混淆；
