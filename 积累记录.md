## Kotlin Flow

[学习采用 Kotlin Flow 和 LiveData 的高级协程](https://developer.android.google.cn/codelabs/advanced-kotlin-coroutines/index.html?hl=ru#7)

[Android 上的 Kotlin 数据流  | Android Developers](https://developer.android.com/kotlin/flow?hl=zh-cn)

[用Kotlin Flow解决Android开发中的痛点问题本文将通过实际业务场景阐述如何使用Kotlin Flow解决A - 掘金](https://juejin.cn/post/7031726493906829319?from=search-suggest)





## Jetpack Compose

[面向 Android 开发者的 Jetpack Compose  | Jetpack Compose for Android Developers](https://developer.android.google.cn/courses/jetpack-compose/course?hl=zh-cn)

### 1. Compose基础知识







### androidStudio必备

#### 主题

1. Dracula主题
2. github主题
3. xcode主题

#### 插件

rainbow brackets *

Color Highlighter ***

key promoter X
dracula theme
APK mover
Builder Generator
Color Highlighter
gitBashOpenHere

codeGeeX

translation ***

gitbashOpenHere ***

#### 设置

fontSize调整

androidStudio->setting->inlay hints 关闭一些usages和author

hard wrap



#### 快捷键

ctrl+alt+O：清理import



### DialogFragment

两次parentFragment就能找到被拉起的Fragment



### Android launcher

参考文档：

[实战-Android开机进入Launcher前黑屏问题_尹杰Enjoy your code的博客-CSDN博客](https://blog.csdn.net/u010927489/article/details/121997086)

[android8.1 开机黑屏2s修复方案_android mtk解锁后黑几秒_凯文的内存的博客-CSDN博客](https://blog.csdn.net/DKBDKBDKB/article/details/101284914)

android7.0 以上多了一个FallbackHome的机制。

```shell
06-07 00:46:37.198   707   731 I ActivityManager: Start proc 961:com.android.settings/1000 for activity {com.android.settings/com.android.settings.FallbackHome}
06-07 00:46:42.057   707   801 D StorageManagerService: Thinking about init, mBootCompleted=true, mDaemonConnected=true
06-07 00:46:42.059   707   801 D StorageManagerService: Thinking about reset, mBootCompleted=true, mDaemonConnected=true
06-07 00:46:42.794  1328  1328 W ContextImpl: Calling a method in the system process without a qualified user: android.app.ContextImpl.startService:1571 android.content.ContextWrapper.startService:669 android.content.ContextWrapper.startService:669 com.mediatek.simprocessor.BootCmpReceiver.startSimService:113 com.mediatek.simprocessor.BootCmpReceiver.processBootComplete:134 
06-07 00:46:43.388   707   731 I ActivityManager: Start proc 1397:com.typhur.device.sousvide/u0a76 for activity {com.typhur.device.sousvide/com.typhur.device.sousvide.MainActivity}
06-07 00:46:43.808   707   707 I Telecom : MissedCallNotifierImpl: reloadAfterBootComplete: user=0: TSBCR.oR@ABA
06-07 00:46:43.979   707   731 I ActivityManager: Start proc 1484:bnd.com/1000 for broadcast {bnd.com/bnd.com.BootCompleteReceiver}
06-07 00:46:44.194  1484  1484 I AutoStart: BootCompleteReceiver action2
06-07 00:46:44.195  1484  1484 I AutoStart: BootCompleteReceiver action1 = android.intent.action.BOOT_COMPLETED
```

**启动流程为：先启动FallbackHome，显示了出来，再显示launcher，他不断地delay500ms来检测是否有launcher出来，才隐退。我们自己做了实验，移除sousVide（即launcher），FallbackHome永远不会消除。**

android开机过程中，在还没有完全BootComplete之前，先启动一个activity，settings的FallbackHome。从反编译来看，10.0通过获取了wallpaper的颜色，android7.0-8.0版本的代码则直接显示透明界面：

```java
this.mProvisioned = Settings.Global.getInt(getContentResolver(), "device_provisioned", 0) != 0;
if (this.mProvisioned) {
    i = 1536;
} else {
    setTheme(2131951877);
    i = 4102;
}
this.mWallManager = (WallpaperManager) getSystemService(WallpaperManager.class);
if (this.mWallManager == null) {
    Log.w("FallbackHome", "Wallpaper manager isn't ready, can't listen to color changes!");
} else {
    loadWallpaperColors(i);
}
getWindow().getDecorView().setSystemUiVisibility(i);
```

不论如何处理，这里都将是显示wallpaper或者黑屏的情况，因为此时只有它一个应用起来。

如下代码为反编译得到的10.0的不断delay500ms，来检测launcher的逻辑：

```java
 public void maybeFinish() {
        if (((UserManager) getSystemService(UserManager.class)).isUserUnlocked()) {
            if (Objects.equals(getPackageName(), getPackageManager().resolveActivity(new Intent("android.intent.action.MAIN").addCategory("android.intent.category.HOME"), 0).activityInfo.packageName)) {
                if (UserManager.isSplitSystemUser() && UserHandle.myUserId() == 0) {
                    return;
                }
                Log.d("FallbackHome", "User unlocked but no home; let's hope someone enables one soon?");
                this.mHandler.sendEmptyMessageDelayed(0, 500L);
                return;
            }
            Log.d("FallbackHome", "User unlocked and real home found; let's go!");
            ((PowerManager) getSystemService(PowerManager.class)).userActivity(SystemClock.uptimeMillis(), false);
            finish();
        }
    }

```





所以解决方案：

我们不能去掉FallbackHome，因为去掉以后，我们的launcher其实还没有起来。



第一种方案：参考代码延迟开机动画，这样的弊端是开机时间拉长，不过对于我们的情况似乎更合适（衔接更加正常）；

第二种方案：

​	第一步，修改wallpaper，在framework/res/res/..../default_wallpaper.png，注意搜索所有的default_wallpaper.png注意它的尺寸；

​	第二步，修改FallbackHome的显示界面，去除这种color的获取和透明显示，换成开机动画最后一帧，然后delay 500ms检测也可以适当缩短；

​	第三步，sousVide App也修改启动界面。



### Glide

[Android Glide加载图片、网络监听、设置资源监听-腾讯云开发者社区-腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1768919)

[Glide缓存配置 - 简书 (jianshu.com)](https://www.jianshu.com/p/75938bddf407)

[Android 玩转Glide4---基础篇_DeMonnnnnn的博客-CSDN博客](https://demon.blog.csdn.net/article/details/105633573)



### 混淆规则

多模块混淆

### 修改jar

jar 命令的一些操作：

1. jar -xvf xxx.jar

2. 自行修改替换class

3. jar -cvf anyName.jar ./

4. 更新META-INF/MANIFEST.MF清单文件

   jar umf META-INF/MANIFEST.MF xxx.jar



### 签名

查看签名

keytool -list -printcert -jarfile xxx.apk

签名jks：

./keyipair -k platform.jks -p 12345678 -pk8 ./bndCode2/platform.pk8 -cert ./bndCode2/platform.x509.pem -alias platform

然后给到androidStudio配置（可以再细分release和debug）：

```
signingConfigs {
    config {
        storeFile file("../platform.jks")
        storePassword '12345678'
        keyAlias 'platform'
        keyPassword '12345678'
    }
}
```



### 协程 TODO

[kotlin中将回调改写为协程_kotlin回调 改成协程_沙漠一只雕得儿得儿的博客-CSDN博客](https://blog.csdn.net/cpcpcp123/article/details/111724458)

[更优雅的使用回调函数 —— Kotlin 协程_kotlin 协程回调_Junerver的博客-CSDN博客](https://blog.csdn.net/u011133887/article/details/112262311)



launcherUI

launcherOnThread

withContext



### Statubar

```kotlin
ViewCompat.setOnApplyWindowInsetsListener(requireActivity().window.decorView) { _, insets ->
            val statusBarTop = insets.getInsets(WindowInsetsCompat.Type.statusBars()).top
            run{
                val dm = resources.displayMetrics
                val density = dm.density
                val densityDpi = dm.densityDpi
                val scaledDensity = dm.scaledDensity
                Log.d("allan", "statusBarTop: $statusBarTop density $density  densityDpi $densityDpi scaledDensity $scaledDensity")
            }

            run{
                val screenAdaptationObj = ScreenAdaptationObj
                val density = screenAdaptationObj.density
                val densityDpi = screenAdaptationObj.densityDpi
                val scaledDensity = screenAdaptationObj.scaledDensity
                Log.d("allan", "mine statusBarTop: $statusBarTop density $density  densityDpi $densityDpi scaledDensity $scaledDensity")
            }

            run{
                val dm = BaseGlobalConst.app.resources.displayMetrics
                val density = dm.density
                val densityDpi = dm.densityDpi
                val scaledDensity = dm.scaledDensity
                Log.d("allan", "application statusBarTop: $statusBarTop density $density  densityDpi $densityDpi scaledDensity $scaledDensity")
            }
            WindowInsetsCompat.CONSUMED
        }
```

10:45:18.286  D                       statusBarTop: 90 density 2.88  densityDpi 460 scaledDensity 2.7648
10:45:18.286  D             mine statusBarTop: 90 density 2.88  densityDpi 460 scaledDensity 2.7648
10:45:18.287  D  application statusBarTop: 90 density 2.75  densityDpi 440 scaledDensity 2.75

不做适配：statusBarTop: 90 density 2.75  densityDpi 440 scaledDensity 2.75



### AppBarLayout

在没有任何的显示的时候，会出现边缘阴影。因为他默认设置了12dp的elevation。

通过设置0dp来解决。让他不显示阴影。

```
app:elevation="0dp"
```



### TabLayout样式

```
<item name="tabRippleColor">@null</item>
```

 color tansparent不行。

否则，某些手机(android13可能)出现背景的显示。有的手机可以，有的不行。null解决。



抛弃使用

```
<!--        <com.google.android.material.tabs.TabItem-->
<!--            android:text="@string/steps"-->
<!--            android:layout_height="46dp"-->
<!--            android:layout_width="118dp"/>-->
```

的方式。来预制TabItem，通过代码来设置mBinding.tabLayout.newTab().setText(R.string.steps)。

解决闪动的问题。



### 输入框问题

> 隐藏输入框的办法：

需要给DialogFragment的子类，添加dismiss()实现

在调用super.dimiss()的时候，清理焦点和hideIme（）

对于onPause的时候，清理edit的焦点clearFocus() 然后调用hideIme()

```kotlin
ViewCompat.getWindowInsetsController(this)?.hide(WindowInsetsCompat.Type.ime())
或者
WindowCompat.getInsetsController(window, view).hide(WindowInsetsCompat.Type.ime())
```

> 输入框在DialogFragment的情况下，被遮挡了一部分：

```xml

    <com.typhur.module.android.widget.BaseTextInputLayout
        app:layout_constraintTop_toBottomOf="@id/titleTv"
        android:id="@+id/edTextLayout"
        style="@style/TyphurInputLayoutBlack"
        android:layout_width="match_parent"
        android:layout_height="64dp"
        android:padding="8dp"
        android:layout_marginTop="42dp">

        <com.typhur.module.base.typhur.view.TyphurFontEdit
            style="@style/TyphurEditGrayBgAndBoard"
            android:id="@+id/etText"
            android:textSize="@dimen/text_size_h5_15sp"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:layout_gravity="center"
            android:background="@null"
            android:ellipsize="end"
            android:lines="1"
            android:paddingVertical="5dp"
            android:paddingStart="20dp"
            android:paddingEnd="20dp" />
    </com.typhur.module.android.widget.BaseTextInputLayout>
```

```xml
<!--输入框样式2.0-->
    <style name="TyphurInputLayout">
        <item name="boxBackgroundMode">outline</item>
        <item name="boxBackgroundColor">@color/color_typhur_gray</item>
        <item name="boxStrokeColor">@color/color_typhur_primary</item>
        <item name="boxCornerRadiusTopStart">7dp</item>
        <item name="boxCollapsedPaddingTop">7dp</item>
        <item name="boxCornerRadiusBottomEnd">7dp</item>
        <item name="boxCornerRadiusBottomStart">7dp</item>
        <item name="boxCornerRadiusTopEnd">7dp</item>
        <item name="boxStrokeWidth">1dp</item>
        <item name="boxStrokeWidthFocused">1dp</item>

        <item name="android:layout_height">58.5dp</item>
        <item name="android:layout_width">match_parent</item>

        <item name="android:background">@null</item>
        <item name="android:textSize">@dimen/text_size_minest</item>
        <item name="hintTextColor">@color/color_999999</item>
        <item name="android:textColorHint">@color/color_999999</item>
        <item name="android:textColor">@color/color_black</item>
        <!--不给Layout有hint动画把hint放到editText上，并设置paddingVertical-->
        <item name="hintEnabled">false</item>
    </style>

    <!--输入框样式2.0-->
    <style name="TyphurInputLayoutBlack" parent="TyphurInputLayout">
        <item name="boxBackgroundColor">@color/color_typhur_gray_light</item>
        <item name="boxStrokeColor">@color/color_text_normal</item>
    </style>

    <!--输入框样式 todo -->
    <style name="TyphurEdit" parent="TyphurFontText">
        <item name="android:textSize">@dimen/text_size_h4_16sp</item>
        <item name="android:textColorHint">@color/color_999999</item>
        <item name="android:background">@null</item>
        <item name="android:textCursorDrawable">@drawable/typhur_text_cursor</item>
    </style>

    <style name="TyphurEditGrayBgAndBoard" parent="TyphurFontText">
        <item name="android:textSize">@dimen/text_size_h5_15sp</item>
        <item name="android:textColor">@color/color_text_normal</item>
        <item name="android:textColorHint">@color/color_999999</item>
        <item name="android:background">@drawable/corner_black_board_gray_bg</item>
        <item name="android:textCursorDrawable">@drawable/typhur_text_cursor</item>
    </style>

    <style name="TyphurEditGrayNoCursor" parent="TyphurFontText">
        <item name="android:textSize">24sp</item>
        <item name="android:textStyle">bold</item>
        <item name="android:background">#F7F7F7</item>
        <item name="android:textCursorDrawable">@null</item>
        <item name="android:gravity">center</item>
    </style>
```

通过padding来解决被遮挡问题。



### RecyclerView

使用ItemDecoration。

```kotlin
addItemDecoration(HorzPaddingItemDecoration(12.dp, 12.dp, 0))

class HorzPaddingItemDecoration(
    private val firstLeftPadding: Int,
    private val endRightPadding: Int,
    padding: Int,
) : ItemDecoration() {

    private val halfPadding:Int = padding shr 1

    override fun getItemOffsets(
        outRect: Rect,
        view: View,
        parent: RecyclerView,
        state: RecyclerView.State
    ) {

        val position = parent.getChildAdapterPosition(view) // item position
        val count = parent.adapter?.itemCount ?: 0
        when (position) {
            0 -> {
                outRect.left = firstLeftPadding
                outRect.right = halfPadding
            }
            count - 1 -> {
                outRect.left = halfPadding
                outRect.right = endRightPadding
            }
            else -> {
                outRect.left = halfPadding
                outRect.right = halfPadding
            }
        }
    }
}
```

修改outRect不会影响item的宽度。



使用CardView作为RecyclerView的子Item。必须使用以下android:layout_margin="5dp"，这样才能避免边缘被遮挡。



### kotlin foreach

警惕kotlin foreach的return@foreach，只能相当于continue。

```kotlin
data class DataBean(val id:Int, val info:String)

fun test() {
    val list = mutableListOf<DataBean>()
    list.add(DataBean(1, "first1"))
    list.add(DataBean(2, "adf22222"))
    list.add(DataBean(3, "adsfa3333"))
    list.add(DataBean(4, "dfdf44444"))
    list.add(DataBean(1, "theNext1"))

    //错误
    list.forEach {
        if (it.id == 1) {
            return@forEach
        }
    }

    //正确
    list.let { newList->
        newList.forEach {
            if (it.id == 1) {
                return@let
            }
        }
    }
}

fun main() {
    test()
}
```



### setSpan crash

1、常见的可能是下标计算有误，导致start和end负值；

2、网上有人说开启无障碍模式的TalkBack功能，如果start==end也会，测试已证实；

3、还有一种本人遇到的，实现ClickableSpan时为了解决内存泄漏问题，按照网上的方法实现了NoCopySpan。部分机型可能不支持NoCopySpan的实现，导致异常报错，去除后恢复正常



在正常的Android 8.0的使用中，并不会出现什么问题，但是如果手机开启了无障碍中的TalkBack功能的话，那么这段代码就必定会出现上述的crash。也就是说，在设置ClickableSpan的时候，如果设置的endIndex == startIndex 那么就会出现crash，但是在正常的使用中，是可以进行这样的设置的，虽然没有什么显示效果，但是并不会出现任何crash。所以，如果你也出现了类似的问题，就需要检查一下相关代码了。



会有内存泄漏的问题，如果使用NoCopySpan代替ClickableSpan再8.0的版本上会触发无障碍模式的权限判定导致闪退，可尝试页面退出时回收对象





textView 使用ClickSpan进行点击设置时，会有点击冲突,解决同时触发点击事件的冲突可以去掉textView上的点击事件，在父控件上添加点击事件，同时自定义LinkMovementMethod
textView 的clickspan 会有内存泄漏的问题，如果使用NoCopySpan代替ClickableSpan再8.0的版本上会触发无障碍模式的权限判定导致闪退，可尝试页面退出时回收对象
if(text instanceof Spannable){
            Spannable spannable= (Spannable) text;
            Object[] spans = spannable.getSpans(0, text.length(), Object.class);
            for (Object span: spans) {
                spannable.removeSpan(span);
            }
        }

[listview - Android TextView leaks with setMovementMethod - Stack Overflow](https://stackoverflow.com/questions/28539216/android-textview-leaks-with-setmovementmethod)



[(1条消息) TextView 富文本学习六 - 设置了ClickableSpan导致内存泄漏_spannablestringbuilder 内存泄漏_lidongxiu0714的博客-CSDN博客](https://blog.csdn.net/u010126792/article/details/91821017?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-91821017-blog-123114323.235^v32^pc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-91821017-blog-123114323.235^v32^pc_relevant_default_base3&utm_relevant_index=2)





### seakbar

[SeekBar的样式修改及分析_seekbar样式_坚持就有希望的博客-CSDN博客](https://blog.csdn.net/liangtianmeng/article/details/90286217)





### Toolbar

的navigationIcon的size选择

```yaml
mdpi : 24 x 24 px
hdpi : 36 x 36 px
xhdpi : 48 x 48 px
xxhdpi : 72 x 72 px
xxxhdpi : 96 x 96 px
```

**According to their ratios:**

```yaml
mdpi : hdpi : xhdpi : xxhdpi : xxxhdpi= 1 : 1.5 : 2 : 3 : 4
```



### View圆角和背景模糊

```kotlin
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) { //高版本使用模糊，低版本纯半透
    //View decorView = getWindow().getDecorView();
    // ViewGroup you want to start blur from. Choose root as close to BlurView in hierarchy as possible.
    //ViewGroup rootView = (ViewGroup) decorView.findViewById(android.R.id.content);
    // Optional:
    // Set drawable to draw in the beginning of each blurred frame.
    // Can be used in case your layout has a lot of transparent space and your content
    // gets a too low alpha value after blur is applied.
    //Drawable windowBackground = decorView.getBackground();
    binding.blurView.setupWith(binding.root, RenderEffectBlur()) // or RenderEffectBlur
        //.setFrameClearDrawable(windowBackground) // Optional
        .setBlurRadius(12f)

    binding.blurView.outlineProvider = viewOutlineProvider
    binding.blurView.clipToOutline = true
} else {
    binding.blurView.setBackgroundResource(R.drawable.corner4dp_alpha_white_bg)
}

private val viewOutlineProvider = object : ViewOutlineProvider() {
    override fun getOutline(view: View, outline: Outline) {
        outline.setRoundRect(0, 0, view.width, view.height, 4f.dp)
    }
}

//圆角矩形
binding.blurView.outlineProvider = viewOutlineProvider
binding.blurView.clipToOutline = true
```

### android button文字颜色

```xml
<style name="BtnStyleBlankWhite">
    <item name="android:background">@drawable/corner_btn_blank_white</item>
    <item name="android:textColor">@color/primary_btn_color</item>
    <item name="android:textSize">@dimen/text_size_h5_15sp</item>
    <item name="autoSizeTextType">uniform</item>
    <item name="autoSizeMaxTextSize">@dimen/text_size_h3_20sp</item>
    <item name="autoSizeMinTextSize">@dimen/text_size_minest</item>
    <item name="android:lines">1</item>
    <item name="android:layout_height">49dp</item>
    <item name="android:gravity">center</item>
    <item name="android:layout_width">match_parent</item>
</style>

定义在res/color下面
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- disabled state -->
    <item android:state_enabled="false" android:color="#CCCCCC" />
    <item android:color="@color/white"/>
</selector>
```





### SpanStringBuilder

xxx

### HideIme

```kotlin
//ViewCompat.getWindowInsetsController(this) 已经经常失效了。改成WindowCompat.getInsetsController(window, view)

fun hideImeNew(window: Window, view:View) {
    WindowCompat.getInsetsController(window, view).hide(WindowInsetsCompat.Type.ime())
}


/**
 * 当刚刚显示的时候，调用无效。
 * 需要postDelay一段时间才行。这个函数建议手动点击比如某些按钮，然后触发弹出。
 */
fun showImeNew(window: Window, view:EditText) {
    view.requestFocus()
    WindowCompat.getInsetsController(window, view).show(WindowInsetsCompat.Type.ime())
}

/**
 * 当显示的时候，直接显示
 */
fun showImeNewOnCreate(window:Window, et:EditText) {
    // 等价于xml中 android:windowSoftInputMode="stateVisible"
    //Visibility state for softInputMode:
    // please show the soft input area when normally appropriate (when the user is navigating forward to your window).
    //Applications that target Build.VERSION_CODES.P and later,
    // this flag is ignored unless there is a focused view
    // that returns true from View.onCheckIsTextEditor() when the window is focused.
    window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE)
    et.requestFocus()
}
```



```
对于dialogFragment的处理
mBinding.etText.requestFocus() //模拟器生效，真机不稳定
Instance.findDialog(this)?.window?.let { showImeNew(it, mBinding.etText) }
Instance.findDialog(this)?.window?.let { showImeNewOnCreate(it, mBinding.etText) }
showImeNew(requireActivity().window, mBinding.etText)
```

```kotlin

fun findDialog(fragment: Fragment?): AppCompatDialogFragment? {
    fragment ?: return null
    if (fragment is AppCompatDialogFragment) {
    	return fragment
    }
    return findTyphurBottomSheetDialog(fragment.parentFragment)
}
```



### 键盘兼容

[Android软键盘的监听与高度控制的几种方案及常用效果 - 掘金 (juejin.cn)](https://juejin.cn/post/7150453629021847566)

android11以上可以监听ime高度不断回调

android11一下：简单点则直接设置state_



STATE组和ADJUST可以共用。

[Android-软键盘一招搞定(原理篇) - 简书 (jianshu.com)](https://www.jianshu.com/p/996dd93f8a48)

#### SOFT_INPUT_STATE_UNSPECIFIED,
#### SOFT_INPUT_STATE_UNCHANGED, 

​			**当 Activity 转至前台时保留软键盘最后所处的任何状态，无论是可见还是隐藏。**

#### SOFT_INPUT_STATE_HIDDEN,
#### SOFT_INPUT_STATE_ALWAYS_HIDDEN,

​	**跳转到一个新页面而非返回到当前页面，stateHidden只有在向前跳转的时候才会去调用hideCurrentInputLocked方法隐藏输入法，而stateAlwaysHidden则没有这个判断，任何情况下窗口获取到焦点都会去隐藏输入法。**

目标是隐藏键盘。只是看看要不要跟随前面一个界面是否隐藏罢了。



#### SOFT_INPUT_STATE_VISIBLE,
#### SOFT_INPUT_STATE_ALWAYS_VISIBLE,

**当 Activity 的主窗口有输入焦点时始终显示软键盘。**安卓9之后软键盘不能自动弹出了，
进入判断后会去判断输入法进程有没有开启，没有开启会去调用startInputUncheckedLocked开启，开启之后会去掉用showCurrentInputLocked显示软键盘。

#### SOFT_INPUT_ADJUST_UNSPECIFIED,

​	**默认的。**

#### SOFT_INPUT_ADJUST_RESIZE,

​	设置后影响了布局的高度，第一个Demo里ImageView高度是固定的，因此即使其父布局高度变小了也不会影响ImageView的展示。而第二个Demo里ImageView高度跟随父布局高度变化，因此当父布局高度变化时，ImageView也随着变化。

​     1、当设置SOFT_INPUT_ADJUST_RESIZE 时，DecorView的子布局padding会改变，最后影响子孙布局的高度。
 	2、父布局高度的变化并不一定会让子布局重新布局，因此针对上面的第一个Demo，我们需要监听键盘的变化从而调整输入框的位置。而对于上面的第二个Demo，不需要手动调整，父布局会自动调整。

**API描述：**

不跟SOFT_INPUT_ADJUST_PAN一起使用。如果没有设置任何一个SOFT_INPUT_ADJUST_*，系统会选一个来适配；如果window是全屏的则不调整。

android11通过Call Window.setDecorFitsSystemWindows(boolean) with false and install an View.OnApplyWindowInsetsListener on your root content view that fits insets of type WindowInsets.Type.ime(). 来做。



#### SOFT_INPUT_ADJUST_PAN,

1、当设置SOFT_INPUT_ADJUST_PAN时，如果发现键盘遮住了当前有焦点的View，那么会对RootView(此处Demo里DecorView作为RootView)的Canvas进行平移，直至有焦点的View显示到可见区域为止。
 2、这就是为什么点击输入框2的时候布局会整体向上移动的原因。

**API描述：**不跟SOFT_INPUT_ADJUST_RESIZE 一起使用。如果没有设置任何一个SOFT_INPUT_ADJUST_*，系统会选一个来适配；如果window是全屏的则不调整。实践下来基本上是选择RESIZE或者PAN。



#### SOFT_INPUT_ADJUST_NOTHING,

不准调整布局。



### Input

```
app:passwordToggleEnabled="true"
不能跟app:endIconMode="password_toggle"一起使用
```

[android - endIconTint in TextInputLayout is not working - Stack Overflow](https://stackoverflow.com/questions/68095814/endicontint-in-textinputlayout-is-not-working)



andorid EditText 不添加inputType=text，则会换行。



android 开发中android:ellipsize="end" 不会产生三个点的原因

字体大小或控件宽度限制：如果控件宽度不足以容纳整个文本，并且没有足够的空间来显示省略号，那么省略号可能无法显示。此外，如果使用的字体大小过大，导致文本在控件内部没有足够的空间显示省略号，也可能出现这种情况。

其实不能设置为maxLength来限定。只能用width来限定。



### 提取android10+ANR

1. windows打开左下角，输入cmd，输入d:  定位到d盘。没有则忽略。

2. 看机器wifi，查看ip地址；

3. adb connect xx.xx.xx.xx  没有adb则需要找一个adb.exe

4. adb bugreport 等待几分钟

5. cmd中输入：adb pull /bugreports
6. 等待完成，将提取出来的文件，打包发过来。



### 混淆keep

混淆的规则
1.压缩 Shrinking
默认开启，优化Apk体积，移除未使用的类和成员
#关闭压缩
-dontshrink
2.优化 Optimization
默认开启，在字节码中进行优化，让应用运行更快
#关闭优化
#-dontoptimize
#表示proguard对代码进行迭代优化的次数，Android一般为5
-optimizationpasses n
3.混淆 Obfuscation
默认开启，类和成员随机命名，增加反编译及阅读难度，可以使用keep命令保存
#关闭混淆
-dontobfuscate



**4.keep keep的用法非常的多**

```shell
混淆的规则
1.压缩 Shrinking
默认开启，优化Apk体积，移除未使用的类和成员
#关闭压缩
-dontshrink
2.优化 Optimization
默认开启，在字节码中进行优化，让应用运行更快
#关闭优化
#-dontoptimize
#表示proguard对代码进行迭代优化的次数，Android一般为5
-optimizationpasses n
3.混淆 Obfuscation
默认开启，类和成员随机命名，增加反编译及阅读难度，可以使用keep命令保存
#关闭混淆
-dontobfuscate



4.keep keep的用法非常的多
#表示只是保持该包下的类名，而子包下的类名还是会被混淆
-keep class com.android.xx.*
#两颗星表示把本包和所含子包下的类名都保持
-keep class com.android.xx.*
#既可以保持该包下的类名，又可以保持类里面的内容不被混淆;
-keep class com.android.xx.{;}
#既可以保持该包及子包下的类名，又可以保持类里面的内容不被混淆;
-keep class com.android.xx.**{;}
#保持某个类名不被混淆，但是内部内容会被混淆
-keep class com.android.Activity
#保持某个类的 类名及内部的所有内容不会混淆
-keep class com.android.Activity{;}
#保持类中特定内容，而不是所有的内容可以使用如下
-keep class com.android.Activity {
#匹配所有构造器
;
#匹配所有域
;
#匹配所有方法
;
}
#还可以进一步的优化
-keep class com.android.Activity{
#保持该类下所有的共有方法不被混淆
public ;
#保持该类下所有的共有内容不被混淆
public *;
#保持该类下所有的私有方法不被混淆
private ;
#保持该类下所有的私有内容不被混淆
private ;
#保持该类的String类型的构造方法
public (java.lang.String);
}
#要保留一个类中的内部类不被混淆需要用 $ 符号
-keep classcom.android.Activity$TestClass{;}
#保持继承关系不被混淆
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.view.View
#不需要保持类名可以使用keepclassmembers
5.不可混淆
部分的规则是不可混淆的
a.JNI不可混淆
#保持native方法不被混淆
-keepclasseswithmembernames class * {
native ;
}




b.清单文件
清单文件中所有使用到的类以及所有Android SDK下的类都无需混淆
c.自定义View
需要保持自定义View不混淆
d.Json对象类
需要保持Json对象类不混淆
e.第三方
正规的第三方都会提供混淆规则
f.Parcelable的子类和Creator静态成员变量
Parcelable的子类和Creator静态成员变量不混淆，否则会产生Android.os.BadParcelableException异常；
-keep class * implements Android.os.Parcelable {
保持Parcelable不被混淆
public static final Android.os.Parcelable$Creator ;
}
g.枚举
#需要保持
-keepclassmembers enum * {
public static **[] values();
public static ** valueOf(java.lang.String);
}
模板
#指定压缩级别
-optimizationpasses 5
#不跳过非公共的库的类成员
-dontskipnonpubliclibraryclassmembers
#混淆时采用的算法
-optimizations !code/simplification/arithmetic,!field/,!class/merging/*
#把混淆类中的方法名也混淆了
-useuniqueclassmembernames
#优化时允许访问并修改有修饰符的类和类的成员
-allowaccessmodification
#将文件来源重命名为“SourceFile”字符串
-renamesourcefileattribute SourceFile
#保留行号
-keepattributes SourceFile,LineNumberTable
#保持泛型
-keepattributes Signature
#保持所有实现 Serializable 接口的类成员
-keepclassmembers class * implements java.io.Serializable {
static final long serialVersionUID;
private static final java.io.ObjectStreamField[] serialPersistentFields;
private void writeObject(java.io.ObjectOutputStream);
private void readObject(java.io.ObjectInputStream);
java.lang.Object writeReplace();
java.lang.Object readResolve();
}
#Fragment不需要在AndroidManifest.xml中注册，需要额外保护下
-keep public class * extends android.support.v4.app.Fragment
-keep public class * extends android.app.Fragment

# Add project specific ProGuard rules here.
# You can control the set of applied configuration files using the
# proguardFiles setting in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}

# Uncomment this to preserve the line number information for
# debugging stack traces.
#-keepattributes SourceFile,LineNumberTable

# If you keep the line number information, uncomment this to
# hide the original source file name.
#-renamesourcefileattribute SourceFile

#############################################
#
# 对于一些基本指令的添加
#
#############################################
# 代码混淆压缩比，在0~7之间，默认为5，一般不做修改
-optimizationpasses 5

# 混合时不使用大小写混合，混合后的类名为小写
-dontusemixedcaseclassnames

# 指定不去忽略非公共库的类
-dontskipnonpubliclibraryclasses

# 这句话能够使我们的项目混淆后产生映射文件
# 包含有类名->混淆后类名的映射关系
-verbose

# 指定不去忽略非公共库的类成员
-dontskipnonpubliclibraryclassmembers

# 不做预校验，preverify是proguard的四个步骤之一，Android不需要preverify，去掉这一步能够加快混淆速度。
-dontpreverify

# 保留Annotation不混淆
-keepattributes *Annotation*,InnerClasses

# 避免混淆泛型
-keepattributes Signature

# 抛出异常时保留代码行号
-keepattributes SourceFile,LineNumberTable

# 指定混淆是采用的算法，后面的参数是一个过滤器
# 这个过滤器是谷歌推荐的算法，一般不做更改
-optimizations !code/simplification/cast,!field/*,!class/merging/*


#############################################
#
# Android开发中一些需要保留的公共部分
#
#############################################

# 保留我们使用的四大组件，自定义的Application等等这些类不被混淆
# 因为这些子类都有可能被外部调用
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Appliction
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class * extends android.view.View
-keep public class com.android.vending.licensing.ILicensingService


# 保留support下的所有类及其内部类
-keep class android.support.** {*;}

# 保留继承的
-keep public class * extends android.support.v4.**
-keep public class * extends android.support.v7.**
-keep public class * extends android.support.annotation.**

# 保留R下面的资源
-keep class **.R$* {*;}

# 保留本地native方法不被混淆
-keepclasseswithmembernames class * {
    native <methods>;
}

# 保留在Activity中的方法参数是view的方法，
# 这样以来我们在layout中写的onClick就不会被影响
-keepclassmembers class * extends android.app.Activity{
    public void *(android.view.View);
}

# 保留枚举类不被混淆
-keepclassmembers enum * {
    public static **[] values();
    public static ** valueOf(java.lang.String);
}

# 保留我们自定义控件（继承自View）不被混淆
-keep public class * extends android.view.View{
    *** get*();
    void set*(***);
    public <init>(android.content.Context);
    public <init>(android.content.Context, android.util.AttributeSet);
    public <init>(android.content.Context, android.util.AttributeSet, int);
}

# 保留Parcelable序列化类不被混淆
-keep class * implements android.os.Parcelable {
    public static final android.os.Parcelable$Creator *;
}

# 保留Serializable序列化的类不被混淆
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    !static !transient <fields>;
    !private <fields>;
    !private <methods>;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

# 对于带有回调函数的onXXEvent、**On*Listener的，不能被混淆
-keepclassmembers class * {
    void *(**On*Event);
    void *(**On*Listener);
}

# webView处理，项目中没有使用到webView忽略即可
-keepclassmembers class fqcn.of.javascript.interface.for.webview {
    public *;
}
-keepclassmembers class * extends android.webkit.webViewClient {
    public void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);
    public boolean *(android.webkit.WebView, java.lang.String);
}
-keepclassmembers class * extends android.webkit.webViewClient {
    public void *(android.webkit.webView, jav.lang.String);
}
```



### Gradle8.0



I upgrade gradle to 8.0 when i package my app i get the seam problem.

this is the error mesage

*Missing classes detected while running R8. Please add the missing classes or apply additional keep rules that are generated in **you path to mmissing_rules.txt***

I follow the path to mmissing_rules.txt like this

```kotlin
app -> build -> outputs -> mapping -> your_app_name -> missing_rules.txt
```

I copy those message into `proguard-rules.pro` then i fix this problem.



### widget。Group

[(1条消息) android widget Group使用不能单独控制某个view的显隐_androidx.constraintlayout.widget.group_林深人不知的博客-CSDN博客](https://blog.csdn.net/smallbabylong/article/details/102831942)



### Firebase文档埋点相关学习

#### 1. 添加firebase到android项目

firebase的icon 推送通知。

并非你自己的。



[将 Firebase 添加到您的 Android 项目  | Firebase for Android (google.com)](https://firebase.google.com/docs/android/setup?hl=zh-cn)

按照上述文档集成即可。

> 备注：项目体感经验，未能明确原因：建议直接在主模块工程中添加，不要加在子模块里。影响编译速度和id生成的准确性。
>
> 子模块要使用的话，直接Implement或者compileOnly引入，来调用一下接口即可。



```
adb shell setprop debug.firebase.analytics.app PACKAGE_NAME  开启打印
adb shell setprop debug.firebase.analytics.app .none.  禁用

adb shell setprop log.tag.FA VERBOSE
adb shell setprop log.tag.FA-SVC VERBOSE
adb logcat -v time -s FA FA-SVC
```

```
10 14:04:53.570 V/FA-SVC  (20778): Logging event: origin=auto,name=session_start(_s),params=Bundle[{ga_event_origin(_o)=auto, ga_screen_class(_sc)=MainActivity, ga_screen_id(_si)=7900493171563937135, ga_screen(_sn)=MainCookFragment, ga_session_id(_sid)=1688969093}]


	行  48: 07-10 14:04:53.596 V/FA-SVC  (20778): Logging event: origin=auto,name=error(_err),params=Bundle[{ga_event_origin(_o)=auto, ga_error_value(_ev)=user_id, ga_screen_class(_sc)=MainActivity, ga_screen_id(_si)=7900493171563937135, ga_screen(_sn)=MainCookFragment, ga_error(_err)=15}
    
    
    行  53: 07-10 14:04:53.606 V/FA-SVC  (20778): Logging event: origin=app,name=screen_view(_vs),params=Bundle[{ga_event_origin(_o)=app, ga_screen_class(_sc)=MainActivity, ga_screen_id(_si)=-5473944868560656723, ga_screen(_sn)=MainCookFragment, manual_tracking(_mst)=1}]
    
    
	行 387: 07-10 14:05:01.925 V/FA-SVC  (20778): Logging event: origin=app,name=screen_view(_vs),params=Bundle[{ga_event_origin(_o)=app, engagement_time_msec(_et)=8525, ga_previous_class(_pc)=MainActivity, ga_previous_id(_pi)=-5473944868560656723, ga_previous_screen(_pn)=MainCookFragment, ga_screen_class(_sc)=MainActivity, ga_screen_id(_si)=-5473944868560656722, ga_screen(_sn)=MainCookFragment, manual_tracking(_mst)=1}]

```

![debug-view-ga](D:\allan资料\每周\debug-view-ga.png)





### retrofit翻译

定义成接口

通过



### FFMPEG

仅仅调整码率

ffmpeg.exe -i input.mp4 -b:v 3000k out.mp4 

追加限制帧率

ffmpeg.exe -i input.mp4 -b:v 3000k -r 30 out.mp4
