### Android基础知识点

#### 四大组件

**Activity（活动）、Service（服务）、BroadcastReceiver（广播接收器）、ContentProvider（内容提供者）**，是 Android 应用的核心组成单元，由系统统一调度管理。



2. 四大组件生命周期 + 简单用法

Activity

- 生命周期：**创建**onCreate→**可见**onStart→**可交互**onResume→**暂停**onPause→**后台**onStop→**销毁**onDestroy（可重启：onRestart）；
- 用法：作为应用界面载体，配置 AndroidManifest，通过 Intent 启动，重写生命周期处理业务（如初始化 / 释放资源）。

Service

- 生命周期（两种）：① 启动式：onCreate→onStartCommand→onDestroy；② 绑定式：onCreate→onBind→onUnbind→onDestroy；
- 用法：后台执行耗时任务（非 UI），可通过 startService 启动 /stopService 停止，或 bindService 绑定（与组件通信），前台 Service 需加通知保活。

BroadcastReceiver

- 生命周期：仅**onReceive(Context, Intent)**，执行完即销毁（生命周期极短）；
- 用法：监听系统 / 应用广播（如网络变化、开机完成），分**静态注册**（Manifest 配置，常驻）、**动态注册**（代码 register，随组件生命周期）。

ContentProvider

- 生命周期：**onCreate**（初始化），无销毁方法，随应用进程消亡；
- 用法：跨应用 / 进程数据共享，封装增删改查（query/insert/update/delete），通过 ContentResolver 访问，底层通常关联数据库。



Activity 之间的通信方式

1. **Intent+Bundle**：传基础数据（String/int）、序列化对象（Serializable/Parcelable，推荐后者）；

2. **静态变量**：慎用，易内存泄漏；

3. **接口回调**：带返回值通信（如 A 跳 B，B 返回数据给 A）；

4. **第三方框架**：EventBus/ARouter（复杂场景）；

5. **轻量持久化**：SharedPreferences（简单数据共享）。

   

Activity 各种情况下的基础生命周期

正常启动

`onCreate()` → `onStart()` → `onResume()`（最终可交互状态）

正常销毁（按返回键 /finish ()）

`onPause()` → `onStop()` → `onDestroy()`（最终销毁释放资源）



横竖屏切换的 Activity 生命周期

默认情况（销毁重建，系统保存临时数据）

```
onPause()` → `onStop()` → `onSaveInstanceState()`（保存状态） → `onDestroy()` → `onCreate()` → `onRestoreInstanceState()`（恢复状态） → `onStart()` → `onResume()
```

禁止重建（配置后，不销毁，仅回调配置变更）

在 Manifest 给 Activity 加`android:configChanges="orientation|screenSize"`，切换时**仅执行 onConfigurationChanged ()**，无其他生命周期回调。



Activity 与 Fragment 生命周期比较

1. **依赖关系**：Fragment 依赖 Activity 存在，生命周期随 Activity 变化，**Activity 先创建，Fragment 后创建；Activity 先销毁，Fragment 后销毁**；
2. **独有方法**：Fragment 多 4 个核心方法：`onAttach()`（绑定 Activity）、`onCreateView()`（创建视图）、`onViewCreated()`（视图初始化）、`onDestroyView()`（销毁视图）；
3. **对应关系**：Activity→onCreate () 对应 Fragment→onAttach ()/onCreate ()；Activity→onResume () 对应 Fragment→onResume ()；Activity→onDestroy () 对应 Fragment→onDestroy ()/onDetach ()。



Activity 上有 Dialog 时按 Home 键的生命周期

普通 Dialog 是 Activity 的**弹窗附属**，不改变 Activity 的进程状态，按 Home 键走**应用退后台**流程：

```
onPause()` → `onSaveInstanceState()`（保存状态） → `onStop()
```

（Dialog 随 Activity 隐藏，无额外生命周期回调，DialogFragment 同理）。



两个 Activity 跳转必然执行的方法（A 跳 B）

**必然执行**（无论 B 是什么启动模式 / 主题）：

A 的`onPause()` → B 的`onCreate()` → B 的`onStart()` → B 的`onResume()`

（A 的`onStop()`非必然，如 B 是透明主题，A 仍可见，不会执行 onStop ()）。



前台切后台 / 弹 Dialog 的生命周期

前台切后台→再回前台

- 切后台：`onPause()` → `onSaveInstanceState()` → `onStop()`；
- 回前台：`onRestart()` → `onStart()` → `onResume()`。



弹出**普通 Dialog**

Activity**无任何生命周期方法回调**（Dialog 不改变 Activity 的 “可见可交互” 状态，仅遮挡界面）。



**Activity 绑定 Service 的核心实现**

通过`bindService()`实现**进程内绑定**，核心步骤：

1. Service 重写`onBind(Intent)`，返回自定义`IBinder`子类实例（暴露 Service 方法）；

2. Activity 中创建`ServiceConnection`，重写`onServiceConnected`（绑定成功，获取 IBinder 实例）、`onServiceDisconnected`（绑定断开）；

3. Activity 调用`bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)`完成绑定；

4. Activity 销毁前调用`unbindService(serviceConnection)`解绑（必做，避免内存泄漏）。

   

**Activity 启动自身对应 Service 的方式**

分**启动式**和**绑定式**（可单独 / 混合使用），核心代码：

```
// 1. 启动式（后台服务，新版用startForegroundService开启前台服务）
Intent startIntent = new Intent(Activity.this, MyService.class);
startService(startIntent); // 停止：stopService(startIntent)

// 2. 绑定式（见问题5，可调用Service方法）
bindService(bindIntent, serviceConnection, Context.BIND_AUTO_CREATE);
```

**混合式**：既`startService`又`bindService`，需同时`stop`+`unbind`，Service 才会销毁。



**Service 和 Activity 的数据交互方式（按场景排序）**

1. **绑定式直接调用**（进程内最常用）：Activity 通过 IBinder 实例直接调用 Service 的公开方法；

2. **广播**（简单跨进程 / 轻量数据）：Service 发送本地广播，Activity 动态注册接收；

3. **Messenger**（跨进程轻量）：基于 AIDL，通过`Message`/`Handler`实现跨进程双向通信；

4. **AIDL**（跨进程复杂场景）：定义接口，实现跨进程的方法调用和复杂数据传递；

5. **ViewModel+LiveData**（进程内推荐）：共享 ViewModel，LiveData 实现数据观察，生命周期感知。

   

**Service 的两种开启方式 + 核心特点**

|                           开启方式                           |              核心方法               |                           核心特点                           |                  适用场景                  |
| :----------------------------------------------------------: | :---------------------------------: | :----------------------------------------------------------: | :----------------------------------------: |
|                            启动式                            | startService/startForegroundService | 与启动组件解耦，独立后台运行；多次启动仅调用 onStartCommand；需手动停止 |     纯后台耗时任务（如下载、播放音乐）     |
|                            绑定式                            |             bindService             | 与绑定组件生命周期绑定；组件销毁需解绑；可直接调用 Service 方法 | 需与 Activity 交互的后台任务（如播放控制） |
| **混合式**：同时启动 + 绑定，需同时执行`stopService`和`unbindService`，Service 才会执行`onDestroy`。 |                                     |                                                              |                                            |



**Service 的完整生命周期**

分三种启动模式，核心流程（核心方法：onCreate→onStartCommand→onBind→onUnbind→onDestroy）：

1. **启动式**：`onCreate()`（仅首次）→`onStartCommand()`（多次启动多次调用）→`onDestroy()`（停止后）；

2. **绑定式**：`onCreate()`（仅首次）→`onBind()`（仅首次）→`onUnbind()`（解绑时）→`onDestroy()`（无绑定后）；

3. 混合式

   ```
   onCreate()→onStartCommand()→onBind()→onUnbind()→onDestroy()（需 unbind 且 stop）；
   ```

   关键onCreate仅在 Service 首次创建时调用，无论哪种方式，只有onDestroy能释放资源。



**对 ContentProvider 的理解**

Android**跨应用 / 进程数据共享的标准核心组件**，是系统提供的统一数据访问接口；

- 底层可封装数据库、SP、文件等数据源，对外暴露`query/insert/update/delete`抽象方法，隐藏数据实现细节；

- 天生**单例**，随应用进程启动，支持权限控制，保证数据访问安全；

- 系统自带实现（如联系人、短信、媒体库），应用可自定义实现，通过`ContentResolver`访问，是跨应用数据交互的官方标准。

  

**ContentProvider、ContentResolver、ContentObserver 关系**

三者**协同工作**，实现**数据共享 + 数据变化监听**，分工明确：

- **ContentProvider**：**数据提供者**，封装数据源和操作，对外提供统一访问入口，数据变化时调用`notifyChange()`发送通知；

- **ContentResolver**：**数据访问者**，Activity/Fragment 通过它访问 ContentProvider，无需关心底层数据源，跨应用透明访问；

- **ContentObserver**：**数据监听器**，通过 ContentResolver 注册，监听指定 Uri 的数据变化，收到通知后回调`onChange()`，实现数据实时同步。

  

**对 BroadcastReceiver 的理解**

Android 的**组件间消息通信机制**，用于监听系统 / 应用发出的**广播事件**，实现跨组件（跨进程 / 跨应用）的松耦合通信；

- 生命周期**极短**：仅`onReceive()`方法执行期，执行完立即销毁，**不能执行耗时操作**（否则 ANR，可通过 IntentService 处理）；

- 核心作用：监听系统事件（如网络变化、开机完成）、实现应用内 / 应用间的消息通知；

- 由系统统一调度，接收广播需先注册，发送广播通过`sendBroadcast()`系列方法。

  

**广播的核心分类**

按**传递方式 / 作用域 / 注册方式**分三类（面试高频）：

1. **按传递方式**：无序广播（默认，异步，所有接收者同时收到，不可截断 / 修改）、有序广播（同步，按优先级接收，可截断 / 修改数据）；
2. **按作用域**：全局广播（默认，跨应用，所有应用可接收）、本地广播（仅应用内，安全高效）；
3. **按注册方式**：静态广播（Manifest 注册，常驻系统，不受组件生命周期影响）、动态广播（代码注册，随组件生命周期，灵活）；
4. **按发送方**：系统广播（系统发出，如开机、网络变化）、自定义广播（应用自行定义发送）。



**广播的使用方式 + 适用场景**

1. 定义 Receiver：继承`BroadcastReceiver`，重写`onReceive()`处理广播；
2. 注册 Receiver：静态（Manifest）/ 动态（代码）；
3. 发送广播：`sendBroadcast()`（无序）、`sendOrderedBroadcast()`（有序）、`sendLocalBroadcast()`（本地）。



- 系统广播：监听网络变化、电量低、开机完成、安装 / 卸载应用；
- 本地广播：应用内 Activity/Service/Fragment 之间的轻量通信；
- 有序广播：短信拦截、广播优先级处理（如系统通知先被系统应用处理）；
- 全局广播：跨应用的简单消息通知（如应用升级提醒）。

```xml
<!-- 1. Manifest注册 -->
<receiver android:name=".MyReceiver">
    <intent-filter>
        <action android:name="com.test.MY_ACTION" /> <!-- 自定义广播action -->
    </intent-filter>
</receiver>
```

```java
// 2. 发送广播
Intent intent = new Intent("com.test.MY_ACTION");
intent.setPackage(getPackageName()); // 8.0后必须指定包名，否则静态Receiver收不到
sendBroadcast(intent);

// 3. 定义Receiver
public class MyReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 处理广播逻辑
    }
}
```

**动态注册（代码中，随组件生命周期）**

```java
// 1. 定义Receiver
MyReceiver receiver = new MyReceiver();
// 2. 注册（如Activity的onCreate）
IntentFilter filter = new IntentFilter("com.test.MY_ACTION
```





#### Activity 四种启动模式对比

|     启动模式     |           核心特点           |          适用场景          |
| :--------------: | :--------------------------: | :------------------------: |
| standard（默认） | 每次启动新建实例，多实例同栈 |  普通页面（如列表项详情）  |
|    singleTop     |    栈顶复用，非栈顶则新建    | 推送通知跳转、避免栈顶重复 |
|    singleTask    |  任务栈内复用，清空栈顶实例  | 应用主界面、首页（单实例） |
|  singleInstance  | 独占独立任务栈，全局唯一实例 | 系统级页面（如电话、相册） |



#### Activity 状态保存与恢复

核心触发场景

Activity**非主动销毁**时触发（横竖屏切换、内存不足被回收、切后台），**主动 finish () 不触发**。

核心方法

1. **保存**：`onSaveInstanceState(Bundle outState)` → 在 onPause/onStop 前调用，存入基础数据 / Parcelable 对象；
2. **恢复**：① `onRestoreInstanceState(Bundle savedInstanceState)`（onStart 后执行，Bundle 非空）；② 直接在`onCreate(Bundle savedInstanceState)`中恢复（需判空，首次创建 Bundle 为 null）。



```java
// 保存
@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putString("name", "test");
    outState.putInt("age", 20);
}
// 恢复
@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    super.onRestoreInstanceState(savedInstanceState);
    String name = savedInstanceState.getString("name");
    int age = savedInstanceState.getInt("age");
}
```

仅保存**临时状态数据**，持久化数据需用 SP / 数据库；Bundle 仅支持可序列化数据类型。



**Fragment 各种情况下的生命周期**

基于**Fragment 依赖 Activity**，核心场景生命周期流程如下（核心方法：onAttach→onCreate→onCreateView→onStart→onResume→onPause→onStop→onDestroyView→onDestroy→onDetach）：

- 正常添加：`onAttach`→`onCreate`→`onCreateView`→`onStart`→`onResume`
- 显示 / 隐藏：隐藏→`onPause`→`onStop`→`onDestroyView`；显示→`onCreateView`→`onStart`→`onResume`
- Fragment 跳 Activity：`onPause`→`onStop`→`onDestroyView`（Activity 遮挡时）
- 返回到原 Fragment：`onCreateView`→`onStart`→`onResume`
- 正常销毁：`onPause`→`onStop`→`onDestroyView`→`onDestroy`→`onDetach`
- 横竖屏切换：销毁重建→全程走上述销毁 + 创建流程；Activity 配置`configChanges`→仅 Fragment 重建（同销毁 + 创建）



**Fragment 状态保存 + startActivityForResult 方法归属 / 使用**

- **方法归属**：① 旧版（API23 前）：是**Activity 的方法**，Fragment 需通过`getActivity().startActivityForResult()`调用；② 新版（API23+）：Fragment**自身提供**`startActivityForResult()`，底层仍依赖 Activity；③ 最新推荐：用`registerForActivityResult`替代（废弃旧方法）。
- **使用场景**：Fragment 中启动其他 Activity/Fragment，**需要获取目标组件返回数据**时（如选择图片、选择联系人后返回结果）。
- **状态保存**：通过`onSaveInstanceState(Bundle)`保存临时数据（如输入框内容），重建后通过`getArguments()`/`onCreateView`恢复，与 Activity 一致。



**实现 Fragment 滑动的核心方式**

**主流方案：ViewPager2 + Fragment 适配器 步骤极简：

1. 布局中添加`ViewPager2`（可选搭配`TabLayout`实现顶部标签）；

2. 自定义适配器继承`FragmentStatePagerAdapter`（大量 Fragment，懒加载）/`FragmentPagerAdapter`（少量 Fragment，缓存）；

3. Activity/Fragment 中绑定适配器，传入 Fragment 列表；

   ViewPager2 基于 RecyclerView，支持双向滑动、懒加载、更优的性能。



Fragment 之间传递数据的方式（按推荐度排序）

1. **Bundle（最推荐）**：发送方`fragment.setArguments(bundle)`，接收方`getArguments()`获取（生命周期安全，无内存泄漏）；

2. **ViewModel**：共享`ViewModel`（通过`getActivity()`获取），跨 Fragment/Activity 共享数据，生命周期感知；

3. **接口回调**：Fragment 定义接口，宿主 Activity 实现，实现 Fragment 间间接通信（需返回数据时用）；

4. **事件总线**：EventBus/ARouter（复杂业务场景，简化通信）；

5. **慎用**：静态变量、Application 全局对象（易内存泄漏）。

   

#### 五类动画

**1. 帧动画（Frame Animation）**

- 核心：逐帧播放预定义图片序列，模拟动画效果；
- 实现：xml（drawable 下，`<animation-list>`）/ 代码创建`AnimationDrawable`，控制 start/stop；
- 注意：避免大量高清图，易 OOM；仅适用于简单逐帧效果（如加载动画、小图标动效）。

**2. 视图动画（补间动画，Tween Animation）**

- 核心：对**View 的显示效果**做平移 / 缩放 / 旋转 / 淡入淡出，**不改变 View 实际属性**（如位置、大小）；
- 类型：Translate/Scale/Rotate/Alpha Animation，支持组合动画；
- 实现：xml（anim 下）/ 代码创建，通过`startAnimation()`启动；
- 局限：仅支持 View，无属性改变，适用于简单 UI 动效（如控件入场 / 退场）。

**3. 属性动画（Property Animation，API3.0+）**

- 核心：**修改 View 的实际属性**（如 x/y/width/alpha），支持任意对象（非 View）的属性动画；
- 核心类：`ValueAnimator`（核心，控制数值变化）、`ObjectAnimator`（封装 ValueAnimator，直接操作属性）、`AnimatorSet`（组合动画）；
- 特点：可自定义插值器 / 估值器，支持动画监听，动效真实（属性同步改变）；
- 适用：复杂 UI 动效、非 View 对象动画（如自定义控件属性变化）。



**4.MotionLayout（ConstraintLayout 2.0+）**

- 核心：`ConstraintLayout`的子类，融合**布局约束 + 属性动画**，一站式实现复杂交互动效；

- 特点：可视化编辑（Android Studio Motion Editor）、支持触摸联动、关键帧动画、过渡状态控制；

- 实现：xml（res/motion 下）定义动效规则，布局直接引用；

- 适用：页面过渡、控件触摸交互动效（如侧滑、下拉刷新、按钮联动），替代复杂的属性动画组合。

  

**5. Lottie（第三方动画库，Airbnb）**

- 核心：解析 AE（After Effects）制作的动画文件（json 格式），原生端直接渲染；

- 特点：跨平台（Android/iOS/ 前端）、设计师自主制作，无需开发手写动画，支持动效控制（播放 / 暂停 / 进度）；

- 实现：导入依赖，布局添加`LottieAnimationView`，设置 json 文件路径即可；

- 适用：复杂精美动效（如启动页、节日动效、个性化控件），提升开发效率。

  

**SurfaceView 详解**

- 拥有**独立的绘图表面**，与 UI 线程分离，绘图在**子线程**执行，避免阻塞主线程；
- 采用**双缓冲机制**，绘图无闪烁，支持高频次绘制（如每秒 30/60 帧）；
- 继承自 View，但与普通 View 分离，可在底层绘制，适合叠加在其他 View 下 / 上。

1. 自定义类继承`SurfaceView`，实现`SurfaceHolder.Callback`（监听表面创建 / 销毁 / 改变）；
2. 通过`getHolder()`获取`SurfaceHolder`，设置`setFormat`/`setKeepScreenOn`等；
3. 在`surfaceCreated()`中开启**绘图子线程**，在`surfaceDestroyed()`中停止线程、释放资源；
4. 绘图时通过`SurfaceHolder.lockCanvas()`获取画布，绘制完成后`unlockCanvasAndPost(canvas)`提交。

高频次绘图场景（普通 View 易卡顿 / ANR）：**相机预览、视频播放、游戏开发、实时绘图（如波形图）**。

与普通 View 的核心区别

普通 View 绘图在**UI 线程**，仅适用于低频次绘制；

SurfaceView 绘图在子线程，双缓冲，支持高频绘制，内存开销稍大。



**RecyclerView 的使用和基本原理**

1. 布局中引入`RecyclerView`，添加依赖（AndroidX）；
2. 定义**ViewHolder**：继承`RecyclerView.ViewHolder`，绑定控件（避免多次 findViewById）；
3. 定义**Adapter**：继承`RecyclerView.Adapter<自定义ViewHolder>`，重写 3 个方法：`onCreateViewHolder`（创建 ViewHolder）、`onBindViewHolder`（绑定数据）、`getItemCount`（返回数据量）；
4. 代码中设置**LayoutManager**（核心，控制布局方式：线性 / 网格 / 瀑布流，如`LinearLayoutManager`）；
5. 绑定 Adapter，可选设置`ItemDecoration`（分割线）、`ItemAnimator`（增删动画）。

基本原理（核心：ViewHolder 复用机制）

- 核心：回收屏幕**不可见的 Item**，复用其 View 和 ViewHolder，减少 View 的创建和`findViewById`次数，降低内存开销、提升性能；
- 关键组件：
  1. **LayoutManager**：负责 Item 的布局、回收、复用，决定 RecyclerView 的显示形式；
  2. **RecycledPool**：复用池，存储回收的 ViewHolder，供新 Item 快速复用；
  3. **Adapter**：负责数据与 ViewHolder 的绑定，通知数据变化；
- 流程：滑动时，不可见的 Item 被回收至复用池，新进入屏幕的 Item 从复用池获取 ViewHolder，仅更新数据，无需重新创建 View。



**序列化的作用 + Android 两种序列化的区别**

1. 序列化的核心作用

1. **对象持久化**：将对象转换为字节流，保存到文件 / 数据库，下次可恢复为对象；

2. **跨进程 / 组件数据传递**：如 Activity/Fragment 之间通过 Intent 传对象、AIDL 跨进程通信；

3. 网络传输

   ：将对象转换为字节流，通过网络发送给服务端 / 其他设备。

   本质

   ：解决对象在内存与字节流之间的转换问题，实现对象的跨介质传输 / 存储。

   

2. Android 两种序列化方式核心区别

Android 支持**Serializable**（Java 原生）和**Parcelable**（Android 专属），核心差异如下：

|   特性    |                    Serializable                    |                Parcelable                |
| :-------: | :------------------------------------------------: | :--------------------------------------: |
| 所属体系  |                 Java 原生，跨平台                  |      Android 专属，仅适用于 Android      |
| 实现方式  |            实现接口，自动序列化（反射）            |       实现接口，手动重写 4 个方法        |
| 执行效率  |             低（反射 + 大量临时对象）              |        高（无反射，直接内存操作）        |
| 内存开销  |                         大                         |                    小                    |
| 序列化 ID | 需显式定义`serialVersionUID`（避免版本不一致报错） |                   无需                   |
| 适用场景  |              轻量持久化（如文件存储）              | 跨进程 / 组件传对象（Intent/AIDL，推荐） |

#### 插值器（Interpolator）& 估值器（TypeEvaluator）

1. 插值器（Interpolator，API21 + 对应 TimeInterpolator）

- 核心：**控制动画的变化速率**，决定动画在不同时间点的**进度占比**（0→1）；
- 作用：如加速、减速、匀速、先快后慢、弹跳等效果，不关心动画的实际属性值；
- 系统自带：`LinearInterpolator`（匀速）、`AccelerateInterpolator`（加速）、`DecelerateInterpolator`（减速）、`OvershootInterpolator`（回弹）等；
- 自定义：实现`TimeInterpolator`接口，重写`getInterpolation(float input)`方法（input 为时间进度 0→1，返回动画进度 0→1）。

2. 估值器（TypeEvaluator）

- 核心：**根据插值器的动画进度，计算出属性的实际值**；
- 作用：将插值器的抽象进度（0→1），转换为具体的属性值（如坐标、颜色、大小），是属性动画的核心；
- 系统自带：`IntEvaluator`（整型）、`FloatEvaluator`（浮点型）、`ArgbEvaluator`（颜色）；
- 自定义：实现`TypeEvaluator`接口，重写`evaluate(float fraction, T startValue, T endValue)`方法（fraction 为插值器返回的进度，返回实际属性值）。

**二者协同关系**

**插值器给出「动画进度」，估值器根据进度计算「实际属性值」**，共同决定属性动画的最终效果：

`时间→插值器→动画进度（0→1）→估值器→实际属性值→View属性更新`。



#### Android 中数据存储方式（五大类 + 特点 + 适用场景）

Android 提供 5 种核心存储方式，覆盖轻量配置、结构化数据、大文件、跨应用共享等所有场景：



**SharedPreferences**

- 形式：轻量**键值对**存储，底层为 XML 文件，默认私有；
- 特点：存取简单，支持基本数据类型（String/int/boolean 等）；
- 适用：存储应用配置（如用户名、开关状态、字体大小），不适合大量数据。



**文件存储**

- 分类：**内部存储**（`/data/data/包名/files/`，私有，无需权限）、**外部存储**（SD 卡，公有 / 私有，需读写权限）；
- 形式：字节流 / 字符流读写，支持任意格式文件（文本、图片、视频）；
- 适用：存储大文件（如缓存、下载的资源、日志文件）。



**SQLite 数据库**

- 特点：Android 内置**轻量关系型数据库**，支持 SQL 语句，事务管理，适合结构化数据；

- 操作：通过`SQLiteOpenHelper`创建 / 管理数据库，`SQLiteDatabase`执行增删改查；

- 适用：存储结构化、关联性数据（如本地通讯录、订单记录）。

  

**ContentProvider**

- 核心：Android**跨应用数据共享的标准方式**，封装底层数据源（如 SQLite / 文件），对外提供统一的增删改查接口；

- 特点：天生单例，支持权限控制，跨进程通信；

- 适用：需要给其他应用共享数据（如系统通讯录、媒体库，自定义应用的共享数据）。

  

**网络存储**

- 形式：将数据存储到**服务器 / 云平台**（如阿里云、Firebase），通过网络请求（Http/Retrofit）存取；
- 特点：数据永久保存，可跨设备同步，无需本地内存；
- 适用：大量数据、需要跨设备共享的场景（如用户信息、应用内容、云相册）。



### Android源码相关分析

Android动画框架实现原理

invalidate和postInvalidate的区别及使用

Activity-Window-View三者的差别

HttpUrlConnection 和 okhttp关系

Bitmap对象的理解

looper架构

ActivityThread，AMS，WMS的工作原理

自定义View如何考虑机型适配

自定义View的事件

AstncTask+HttpClient 与 AsyncHttpClient有什么区别？

LaunchMode应用场景

SpareArray原理

请介绍下ContentProvider 是如何实现数据共享的？

AndroidService与Activity之间通信的几种方式

IntentService原理及作用是什么？

说说Activity、Intent、Service 是什么关系

ApplicationContext和ActivityContext的区别

SP是进程同步的吗?有什么方法做到同步？

谈谈多线程在Android中的使用

进程和 Application 的生命周期

RecycleView原理

AndroidManifest的作用与理解



### 常见的一些原理性问题

Handler机制和底层实现

Handler、Thread和HandlerThread的差别

handler发消息给子线程，looper怎么启动？

关于Handler，在任何地方new Handler 都是什么线程下?

ThreadLocal原理，实现及如何保证Local属性？

请解释下在单线程模型中Message、Handler、Message Queue、Looper之间的关系

请描述一下View事件传递分发机制

Touch事件传递流程

事件分发中的onTouch 和onTouchEvent 有什么区别，又该如何使用？

View和ViewGroup分别有哪些事件分发相关的回调方法

View刷新机制

View绘制流程

自定义控件原理

自定义View如何提供获取View属性的接口？

Android代码中实现WAP方式联网

AsyncTask机制

AsyncTask原理及不足

如何取消AsyncTask？

为什么不能在子线程更新UI？

ANR产生的原因是什么？

ANR定位和修正

oom是什么？

什么情况导致oom？

有什么解决方法可以避免OOM？

Oom 是否可以try catch？为什么？

内存泄漏是什么？

什么情况导致内存泄漏？

如何防止线程的内存泄漏？

内存泄露场的解决方法

内存泄漏和内存溢出区别？

LruCache默认缓存大小

ContentProvider的权限管理(解答：读写分离，权限控制-精确到表级，URL控制)

如何通过广播拦截和abort一条短信？

广播是否可以请求网络？

广播引起anr的时间限制是多少？

计算一个view的嵌套层级

Activity栈

Android线程有没有上限？

线程池有没有上限？

ListView重用的是什么？

Android为什么引入Parcelable？

有没有尝试简化Parcelable的使用？



### 开发中常见的一些问题

混合开发有了解吗？

知道哪些混合开发的方式？说出它们的优缺点和各自使用场景？（解答：比如:RN，weex，H5，小程序，WPA等。做Android的了解一些前端js等还是很有好处的)；

屏幕适配的处理技巧都有哪些?

服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？

动态布局的理解

怎么去除重复代码？

画出 Android 的大体架构图

Recycleview和ListView的区别

ListView图片加载错乱的原理和解决方案

动态权限适配方案，权限组的概念

Android系统为什么会设计ContentProvider？

下拉状态栏是不是影响activity的生命周期

如果在onStop的时候做了网络请求，onResume的时候怎么恢复？

Bitmap 使用时候注意什么？

Bitmap的recycler()

Android中开启摄像头的主要步骤

ViewPager使用细节，如何设置成每次只初始化当前的Fragment，其他的不初始化？

点击事件被拦截，但是想传到下面的View，如何操作？

微信主页面的实现方式

微信上消息小红点的原理

CAS介绍（这是阿里巴巴的面试题，我不是很了解，可以参考博客: CAS简介）



### 混合开发面试题
大厂除了技术深度之外，还要求你具备一些广度的知识，比如你要会前端知识，会混合开发，至少会一种脚本语言，C c++更不用说了，也是必会的。

Hybrid做过吗？

Hybrid通信原理是什么，有做研究吗？

react native有多少了解？讲一下原理。

weex了解吗？如何自己实现类似技术？

flutter了解吗？内部是如何实现跨平台的？

Dart语言有研究贵吗？

快应用了解吗？跟其她方式相比有什么优缺点？

说说你用过的混合开发技术有哪些？各有什么优缺点？

Python会吗？

会不会PHP？

Gradle了解多少？groovy语法会吗？



### 高端技术面试题
这里讲的是大公司需要用到的一些高端Android技术，这里专门整理了一个文档，希望大家都可以看看。这些题目有点技术含量，需要好点时间去研究一下的。

#### 图片

图片库对比

图片库的源码分析

图片框架缓存实现

LRUCache原理

图片加载原理

自己去实现图片库，怎么做？

Glide源码解析

Glide使用什么缓存？

Glide内存缓存如何控制大小？

#### 网络和安全机制

描述一次网络请求的流程

网络框架对比和源码分析

自己去设计网络请求框架，怎么做？

okhttp源码

网络请求缓存处理，okhttp如何处理网络缓存的

从网络加载一个10M的图片，说下注意事项

TCP的3次握手和四次挥手

TCP与UDP的区别

TCP与UDP的应用

HTTP协议

HTTP1.0与2.0的区别

HTTP报文结构

HTTP与HTTPS的区别以及如何实现安全性

如何验证证书的合法性?

https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解?

client如何确定自己发送的消息被server收到?

谈谈你对WebSocket的理解

WebSocket与socket的区别

谈谈你对安卓签名的理解。

请解释安卓为啥要加签名机制?

视频加密传输

App 是如何沙箱化，为什么要这么做？

权限管理系统（底层的权限是如何进行 grant 的）？

#### 数据库

sqlite升级，增加字段的语句

数据库框架对比和源码分析

数据库的优化

数据库数据迁移问题



### 算法

排序算法有哪些？

最快的排序算法是哪个？

手写一个冒泡排序

手写快速排序代码

快速排序的过程、时间复杂度、空间复杂度

手写堆排序

堆排序过程、时间复杂度及空间复杂度

写出你所知道的排序算法及时空复杂度，稳定性

二叉树给出根节点和目标节点，找出从根节点到目标节点的路径

给阿里2万多名员工按年龄排序应该选择哪个算法？

GC算法(各种算法的优缺点以及应用场景)

蚁群算法与蒙特卡洛算法

子串包含问题(KMP 算法)写代码实现

一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法

万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射->hash分组->多文件读写效率->磁盘寻址以及应用层面对寻址的优化)

百度POI中如何试下查找最近的商家功能(提示：坐标镜像+R树)。

两个不重复的数组集合中，求共同的元素。

两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？

一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法

一张Bitmap所占内存以及内存占用的计算

2000万个整数，找出第五十大的数字？

烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？

求1000以内的水仙花数以及40亿以内的水仙花数

5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同

时针走一圈，时针分针重合几次

N*N的方格纸,里面有多少个正方形

x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完？



### 插件化、模块化、组件化、热修复、增量更新、Gradle

对热修复和插件化的理解

插件化原理分析

模块化实现（好处，原因）

热修复,插件化

项目组件化的理解

描述清点击 Android Studio 的 build 按钮后发生了什么



### 架构设计和设计模式

谈谈你对Android设计模式的理解

MVC MVP MVVM原理和区别

你所知道的设计模式有哪些？

项目中常用的设计模式

手写生产者/消费者模式

写出观察者模式的代码

适配器模式，装饰者模式，外观模式的异同？

用到的一些开源框架，介绍一个看过源码的，内部实现过程。

谈谈对RxJava的理解

RxJava的功能与原理实现

RxJava的作用，与平时使用的异步操作来比的优缺点

说说EventBus作用，实现方式，代替EventBus的方式

从0设计一款App整体架构，如何去做？

说一款你认为当前比较火的应用并设计(比如：直播APP，P2P金融，小视频等)

谈谈对java状态机理解

Fragment如果在Adapter中使用应该如何解耦？

Binder机制及底层实现

对于应用更新这块是如何做的？(解答：灰度，强制更新，分区域更新)？

实现一个Json解析器(可以通过正则提高速度)

统计启动时长,标准



### 性能优化

如何对Android 应用进行性能分析以及优化?

ddms 和 traceView

性能优化如何分析systrace？

用IDE如何分析内存泄漏？

Java多线程引发的性能问题，怎么解决？

启动页白屏及黑屏解决？

启动太慢怎么解决？

怎么保证应用启动不卡顿？

App启动崩溃异常捕捉

自定义View注意事项

现在下载速度很慢,试从网络协议的角度分析原因,并优化(提示：网络的5层都可以涉及)。

Https请求慢的解决办法（提示：DNS，携带数据，直接访问IP）

如何保持应用的稳定性

RecyclerView的原理

ListView的优化

RecycleView优化

View渲染

Bitmap如何处理大图，如一张30M的大图，如何预防OOM

java中的四种引用的区别以及使用场景

强引用置为null，会不会被回收？



### NDK、jni、Binder、AIDL、进程通信有关

请介绍一下NDK

什么是NDK库?

jni用过吗？

如何在jni中注册native函数，有几种注册方式?

Java如何调用c、c++语言？

jni如何调用java层代码？

进程间通信的方式？

Binder机制

简述IPC？

什么是AIDL？

AIDL解决了什么问题？

AIDL如何使用？

Android 上的 Inter-Process-Communication 跨进程通信时如何工作的？

多进程场景遇见过么？

Android进程分类？

进程和 Application 的生命周期？

进程调度

谈谈对进程共享和线程安全的认识

谈谈对多进程开发的理解以及多进程应用场景

什么是协程？



### framework层、ROM定制、Ubuntu、Linux之类的问题

java虚拟机的特性

谈谈对jvm的理解

JVM内存区域，开线程影响哪块内存

对Dalvik、ART虚拟机有什么了解？

Art和Dalvik对比

虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派)

谈谈你对双亲委派模型理解

JVM内存模型，内存区域

类加载机制

谈谈对ClassLoader(类加载器)的理解

谈谈对动态加载（OSGI）的理解

内存对象的循环引用及避免

内存回收机制、GC回收策略、GC原理时机以及GC对象

垃圾回收机制与调用System.gc()区别

Ubuntu编译安卓系统

系统启动流程是什么？（提示：Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程）

大体说清一个应用程序安装到手机上时发生了什么

简述Activity启动全部过程

App启动流程，从点击桌面开始

逻辑地址与物理地址，为什么使用逻辑地址？

Android为每个应用程序分配的内存大小是多少？

Android中进程内存的分配，能不能自己分配定额内存？

进程保活的方式

如何保证一个后台服务不被杀死？（相同问题：如何保证service在后台不被kill？）比较省电的方式是什么？

App中唤醒其他进程的实现方式
