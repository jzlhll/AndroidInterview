### Android基础知识点

#### 四大组件

**Activity（活动）、Service（服务）、BroadcastReceiver（广播接收器）、ContentProvider（内容提供者）**，是 Android 应用的核心组成单元，由系统统一调度管理。



2. 四大组件生命周期 + 简单用法

Activity

- 生命周期：**创建**onCreate→**可见**onStart→**可交互**onResume→**暂停**onPause→**后台**onStop→**销毁**onDestroy（可重启：onRestart）；
- 用法：作为应用界面载体，配置 AndroidManifest，通过 Intent 启动，重写生命周期处理业务（如初始化 / 释放资源）。

Service

- 生命周期（两种）：① 启动式：onCreate→onStartCommand→onDestroy；② 绑定式：onCreate→onBind→onUnbind→onDestroy；
- 用法：后台执行耗时任务（非 UI），可通过 startService 启动 /stopService 停止，或 bindService 绑定（与组件通信），前台 Service 需加通知保活。

BroadcastReceiver

- 生命周期：仅**onReceive(Context, Intent)**，执行完即销毁（生命周期极短）；
- 用法：监听系统 / 应用广播（如网络变化、开机完成），分**静态注册**（Manifest 配置，常驻）、**动态注册**（代码 register，随组件生命周期）。

ContentProvider

- 生命周期：**onCreate**（初始化），无销毁方法，随应用进程消亡；
- 用法：跨应用 / 进程数据共享，封装增删改查（query/insert/update/delete），通过 ContentResolver 访问，底层通常关联数据库。



Activity 之间的通信方式

1. **Intent+Bundle**：传基础数据（String/int）、序列化对象（Serializable/Parcelable，推荐后者）；

2. **静态变量**：慎用，易内存泄漏；

3. **接口回调**：带返回值通信（如 A 跳 B，B 返回数据给 A）；

4. **第三方框架**：EventBus/ARouter（复杂场景）；

5. **轻量持久化**：SharedPreferences（简单数据共享）。

   

Activity 各种情况下的基础生命周期

正常启动

`onCreate()` → `onStart()` → `onResume()`（最终可交互状态）

正常销毁（按返回键 /finish ()）

`onPause()` → `onStop()` → `onDestroy()`（最终销毁释放资源）



横竖屏切换的 Activity 生命周期

默认情况（销毁重建，系统保存临时数据）

```
onPause()` → `onStop()` → `onSaveInstanceState()`（保存状态） → `onDestroy()` → `onCreate()` → `onRestoreInstanceState()`（恢复状态） → `onStart()` → `onResume()
```

禁止重建（配置后，不销毁，仅回调配置变更）

在 Manifest 给 Activity 加`android:configChanges="orientation|screenSize"`，切换时**仅执行 onConfigurationChanged ()**，无其他生命周期回调。



Activity 与 Fragment 生命周期比较

1. **依赖关系**：Fragment 依赖 Activity 存在，生命周期随 Activity 变化，**Activity 先创建，Fragment 后创建；Activity 先销毁，Fragment 后销毁**；
2. **独有方法**：Fragment 多 4 个核心方法：`onAttach()`（绑定 Activity）、`onCreateView()`（创建视图）、`onViewCreated()`（视图初始化）、`onDestroyView()`（销毁视图）；
3. **对应关系**：Activity→onCreate () 对应 Fragment→onAttach ()/onCreate ()；Activity→onResume () 对应 Fragment→onResume ()；Activity→onDestroy () 对应 Fragment→onDestroy ()/onDetach ()。



Activity 上有 Dialog 时按 Home 键的生命周期

普通 Dialog 是 Activity 的**弹窗附属**，不改变 Activity 的进程状态，按 Home 键走**应用退后台**流程：

```
onPause()` → `onSaveInstanceState()`（保存状态） → `onStop()
```

（Dialog 随 Activity 隐藏，无额外生命周期回调，DialogFragment 同理）。



两个 Activity 跳转必然执行的方法（A 跳 B）

**必然执行**（无论 B 是什么启动模式 / 主题）：

A 的`onPause()` → B 的`onCreate()` → B 的`onStart()` → B 的`onResume()`

（A 的`onStop()`非必然，如 B 是透明主题，A 仍可见，不会执行 onStop ()）。



前台切后台 / 弹 Dialog 的生命周期

前台切后台→再回前台

- 切后台：`onPause()` → `onSaveInstanceState()` → `onStop()`；
- 回前台：`onRestart()` → `onStart()` → `onResume()`。



弹出**普通 Dialog**

Activity**无任何生命周期方法回调**（Dialog 不改变 Activity 的 “可见可交互” 状态，仅遮挡界面）。



**Activity 绑定 Service 的核心实现**

通过`bindService()`实现**进程内绑定**，核心步骤：

1. Service 重写`onBind(Intent)`，返回自定义`IBinder`子类实例（暴露 Service 方法）；

2. Activity 中创建`ServiceConnection`，重写`onServiceConnected`（绑定成功，获取 IBinder 实例）、`onServiceDisconnected`（绑定断开）；

3. Activity 调用`bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE)`完成绑定；

4. Activity 销毁前调用`unbindService(serviceConnection)`解绑（必做，避免内存泄漏）。

   

**Activity 启动自身对应 Service 的方式**

分**启动式**和**绑定式**（可单独 / 混合使用），核心代码：

```
// 1. 启动式（后台服务，新版用startForegroundService开启前台服务）
Intent startIntent = new Intent(Activity.this, MyService.class);
startService(startIntent); // 停止：stopService(startIntent)

// 2. 绑定式（见问题5，可调用Service方法）
bindService(bindIntent, serviceConnection, Context.BIND_AUTO_CREATE);
```

**混合式**：既`startService`又`bindService`，需同时`stop`+`unbind`，Service 才会销毁。



**Service 和 Activity 的数据交互方式（按场景排序）**

1. **绑定式直接调用**（进程内最常用）：Activity 通过 IBinder 实例直接调用 Service 的公开方法；

2. **广播**（简单跨进程 / 轻量数据）：Service 发送本地广播，Activity 动态注册接收；

3. **Messenger**（跨进程轻量）：基于 AIDL，通过`Message`/`Handler`实现跨进程双向通信；

4. **AIDL**（跨进程复杂场景）：定义接口，实现跨进程的方法调用和复杂数据传递；

5. **ViewModel+LiveData**（进程内推荐）：共享 ViewModel，LiveData 实现数据观察，生命周期感知。

   

**Service 的两种开启方式 + 核心特点**

|                           开启方式                           |              核心方法               |                           核心特点                           |                  适用场景                  |
| :----------------------------------------------------------: | :---------------------------------: | :----------------------------------------------------------: | :----------------------------------------: |
|                            启动式                            | startService/startForegroundService | 与启动组件解耦，独立后台运行；多次启动仅调用 onStartCommand；需手动停止 |     纯后台耗时任务（如下载、播放音乐）     |
|                            绑定式                            |             bindService             | 与绑定组件生命周期绑定；组件销毁需解绑；可直接调用 Service 方法 | 需与 Activity 交互的后台任务（如播放控制） |
| **混合式**：同时启动 + 绑定，需同时执行`stopService`和`unbindService`，Service 才会执行`onDestroy`。 |                                     |                                                              |                                            |



**Service 的完整生命周期**

分三种启动模式，核心流程（核心方法：onCreate→onStartCommand→onBind→onUnbind→onDestroy）：

1. **启动式**：`onCreate()`（仅首次）→`onStartCommand()`（多次启动多次调用）→`onDestroy()`（停止后）；

2. **绑定式**：`onCreate()`（仅首次）→`onBind()`（仅首次）→`onUnbind()`（解绑时）→`onDestroy()`（无绑定后）；

3. 混合式

   ```
   onCreate()→onStartCommand()→onBind()→onUnbind()→onDestroy()（需 unbind 且 stop）；
   ```

   关键onCreate仅在 Service 首次创建时调用，无论哪种方式，只有onDestroy能释放资源。



**对 ContentProvider 的理解**

Android**跨应用 / 进程数据共享的标准核心组件**，是系统提供的统一数据访问接口；

- 底层可封装数据库、SP、文件等数据源，对外暴露`query/insert/update/delete`抽象方法，隐藏数据实现细节；

- 天生**单例**，随应用进程启动，支持权限控制，保证数据访问安全；

- 系统自带实现（如联系人、短信、媒体库），应用可自定义实现，通过`ContentResolver`访问，是跨应用数据交互的官方标准。

  

**ContentProvider、ContentResolver、ContentObserver 关系**

三者**协同工作**，实现**数据共享 + 数据变化监听**，分工明确：

- **ContentProvider**：**数据提供者**，封装数据源和操作，对外提供统一访问入口，数据变化时调用`notifyChange()`发送通知；

- **ContentResolver**：**数据访问者**，Activity/Fragment 通过它访问 ContentProvider，无需关心底层数据源，跨应用透明访问；

- **ContentObserver**：**数据监听器**，通过 ContentResolver 注册，监听指定 Uri 的数据变化，收到通知后回调`onChange()`，实现数据实时同步。

  

**对 BroadcastReceiver 的理解**

Android 的**组件间消息通信机制**，用于监听系统 / 应用发出的**广播事件**，实现跨组件（跨进程 / 跨应用）的松耦合通信；

- 生命周期**极短**：仅`onReceive()`方法执行期，执行完立即销毁，**不能执行耗时操作**（否则 ANR，可通过 IntentService 处理）；

- 核心作用：监听系统事件（如网络变化、开机完成）、实现应用内 / 应用间的消息通知；

- 由系统统一调度，接收广播需先注册，发送广播通过`sendBroadcast()`系列方法。

  

**广播的核心分类**

按**传递方式 / 作用域 / 注册方式**分三类（面试高频）：

1. **按传递方式**：无序广播（默认，异步，所有接收者同时收到，不可截断 / 修改）、有序广播（同步，按优先级接收，可截断 / 修改数据）；
2. **按作用域**：全局广播（默认，跨应用，所有应用可接收）、本地广播（仅应用内，安全高效）；
3. **按注册方式**：静态广播（Manifest 注册，常驻系统，不受组件生命周期影响）、动态广播（代码注册，随组件生命周期，灵活）；
4. **按发送方**：系统广播（系统发出，如开机、网络变化）、自定义广播（应用自行定义发送）。



**广播的使用方式 + 适用场景**

1. 定义 Receiver：继承`BroadcastReceiver`，重写`onReceive()`处理广播；
2. 注册 Receiver：静态（Manifest）/ 动态（代码）；
3. 发送广播：`sendBroadcast()`（无序）、`sendOrderedBroadcast()`（有序）、`sendLocalBroadcast()`（本地）。



- 系统广播：监听网络变化、电量低、开机完成、安装 / 卸载应用；
- 本地广播：应用内 Activity/Service/Fragment 之间的轻量通信；
- 有序广播：短信拦截、广播优先级处理（如系统通知先被系统应用处理）；
- 全局广播：跨应用的简单消息通知（如应用升级提醒）。

```xml
<!-- 1. Manifest注册 -->
<receiver android:name=".MyReceiver">
    <intent-filter>
        <action android:name="com.test.MY_ACTION" /> <!-- 自定义广播action -->
    </intent-filter>
</receiver>
```

```java
// 2. 发送广播
Intent intent = new Intent("com.test.MY_ACTION");
intent.setPackage(getPackageName()); // 8.0后必须指定包名，否则静态Receiver收不到
sendBroadcast(intent);

// 3. 定义Receiver
public class MyReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 处理广播逻辑
    }
}
```

**动态注册（代码中，随组件生命周期）**

```java
// 1. 定义Receiver
MyReceiver receiver = new MyReceiver();
// 2. 注册（如Activity的onCreate）
IntentFilter filter = new IntentFilter("com.test.MY_ACTION
```





#### Activity 四种启动模式对比

|     启动模式     |           核心特点           |          适用场景          |
| :--------------: | :--------------------------: | :------------------------: |
| standard（默认） | 每次启动新建实例，多实例同栈 |  普通页面（如列表项详情）  |
|    singleTop     |    栈顶复用，非栈顶则新建    | 推送通知跳转、避免栈顶重复 |
|    singleTask    |  任务栈内复用，清空栈顶实例  | 应用主界面、首页（单实例） |
|  singleInstance  | 独占独立任务栈，全局唯一实例 | 系统级页面（如电话、相册） |



#### Activity 状态保存与恢复

核心触发场景

Activity**非主动销毁**时触发（横竖屏切换、内存不足被回收、切后台），**主动 finish () 不触发**。

核心方法

1. **保存**：`onSaveInstanceState(Bundle outState)` → 在 onPause/onStop 前调用，存入基础数据 / Parcelable 对象；
2. **恢复**：① `onRestoreInstanceState(Bundle savedInstanceState)`（onStart 后执行，Bundle 非空）；② 直接在`onCreate(Bundle savedInstanceState)`中恢复（需判空，首次创建 Bundle 为 null）。



```java
// 保存
@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    outState.putString("name", "test");
    outState.putInt("age", 20);
}
// 恢复
@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    super.onRestoreInstanceState(savedInstanceState);
    String name = savedInstanceState.getString("name");
    int age = savedInstanceState.getInt("age");
}
```

仅保存**临时状态数据**，持久化数据需用 SP / 数据库；Bundle 仅支持可序列化数据类型。



**Fragment 各种情况下的生命周期**

基于**Fragment 依赖 Activity**，核心场景生命周期流程如下（核心方法：onAttach→onCreate→onCreateView→onStart→onResume→onPause→onStop→onDestroyView→onDestroy→onDetach）：

- 正常添加：`onAttach`→`onCreate`→`onCreateView`→`onStart`→`onResume`
- 显示 / 隐藏：隐藏→`onPause`→`onStop`→`onDestroyView`；显示→`onCreateView`→`onStart`→`onResume`
- Fragment 跳 Activity：`onPause`→`onStop`→`onDestroyView`（Activity 遮挡时）
- 返回到原 Fragment：`onCreateView`→`onStart`→`onResume`
- 正常销毁：`onPause`→`onStop`→`onDestroyView`→`onDestroy`→`onDetach`
- 横竖屏切换：销毁重建→全程走上述销毁 + 创建流程；Activity 配置`configChanges`→仅 Fragment 重建（同销毁 + 创建）



**Fragment 状态保存 + startActivityForResult 方法归属 / 使用**

- **方法归属**：① 旧版（API23 前）：是**Activity 的方法**，Fragment 需通过`getActivity().startActivityForResult()`调用；② 新版（API23+）：Fragment**自身提供**`startActivityForResult()`，底层仍依赖 Activity；③ 最新推荐：用`registerForActivityResult`替代（废弃旧方法）。
- **使用场景**：Fragment 中启动其他 Activity/Fragment，**需要获取目标组件返回数据**时（如选择图片、选择联系人后返回结果）。
- **状态保存**：通过`onSaveInstanceState(Bundle)`保存临时数据（如输入框内容），重建后通过`getArguments()`/`onCreateView`恢复，与 Activity 一致。



**实现 Fragment 滑动的核心方式**

**主流方案：ViewPager2 + Fragment 适配器 步骤极简：

1. 布局中添加`ViewPager2`（可选搭配`TabLayout`实现顶部标签）；

2. 自定义适配器继承`FragmentStatePagerAdapter`（大量 Fragment，懒加载）/`FragmentPagerAdapter`（少量 Fragment，缓存）；

3. Activity/Fragment 中绑定适配器，传入 Fragment 列表；

   ViewPager2 基于 RecyclerView，支持双向滑动、懒加载、更优的性能。



Fragment 之间传递数据的方式（按推荐度排序）

1. **Bundle（最推荐）**：发送方`fragment.setArguments(bundle)`，接收方`getArguments()`获取（生命周期安全，无内存泄漏）；

2. **ViewModel**：共享`ViewModel`（通过`getActivity()`获取），跨 Fragment/Activity 共享数据，生命周期感知；

3. **接口回调**：Fragment 定义接口，宿主 Activity 实现，实现 Fragment 间间接通信（需返回数据时用）；

4. **事件总线**：EventBus/ARouter（复杂业务场景，简化通信）；

5. **慎用**：静态变量、Application 全局对象（易内存泄漏）。

   

#### 五类动画

**1. 帧动画（Frame Animation）**

- 核心：逐帧播放预定义图片序列，模拟动画效果；
- 实现：xml（drawable 下，`<animation-list>`）/ 代码创建`AnimationDrawable`，控制 start/stop；
- 注意：避免大量高清图，易 OOM；仅适用于简单逐帧效果（如加载动画、小图标动效）。

**2. 视图动画（补间动画，Tween Animation）**

- 核心：对**View 的显示效果**做平移 / 缩放 / 旋转 / 淡入淡出，**不改变 View 实际属性**（如位置、大小）；
- 类型：Translate/Scale/Rotate/Alpha Animation，支持组合动画；
- 实现：xml（anim 下）/ 代码创建，通过`startAnimation()`启动；
- 局限：仅支持 View，无属性改变，适用于简单 UI 动效（如控件入场 / 退场）。

**3. 属性动画（Property Animation，API3.0+）**

- 核心：**修改 View 的实际属性**（如 x/y/width/alpha），支持任意对象（非 View）的属性动画；
- 核心类：`ValueAnimator`（核心，控制数值变化）、`ObjectAnimator`（封装 ValueAnimator，直接操作属性）、`AnimatorSet`（组合动画）；
- 特点：可自定义插值器 / 估值器，支持动画监听，动效真实（属性同步改变）；
- 适用：复杂 UI 动效、非 View 对象动画（如自定义控件属性变化）。



**4.MotionLayout（ConstraintLayout 2.0+）**

- 核心：`ConstraintLayout`的子类，融合**布局约束 + 属性动画**，一站式实现复杂交互动效；

- 特点：可视化编辑（Android Studio Motion Editor）、支持触摸联动、关键帧动画、过渡状态控制；

- 实现：xml（res/motion 下）定义动效规则，布局直接引用；

- 适用：页面过渡、控件触摸交互动效（如侧滑、下拉刷新、按钮联动），替代复杂的属性动画组合。

  

**5. Lottie（第三方动画库，Airbnb）**

- 核心：解析 AE（After Effects）制作的动画文件（json 格式），原生端直接渲染；

- 特点：跨平台（Android/iOS/ 前端）、设计师自主制作，无需开发手写动画，支持动效控制（播放 / 暂停 / 进度）；

- 实现：导入依赖，布局添加`LottieAnimationView`，设置 json 文件路径即可；

- 适用：复杂精美动效（如启动页、节日动效、个性化控件），提升开发效率。

  

**SurfaceView 详解**

- 拥有**独立的绘图表面**，与 UI 线程分离，绘图在**子线程**执行，避免阻塞主线程；
- 采用**双缓冲机制**，绘图无闪烁，支持高频次绘制（如每秒 30/60 帧）；
- 继承自 View，但与普通 View 分离，可在底层绘制，适合叠加在其他 View 下 / 上。

1. 自定义类继承`SurfaceView`，实现`SurfaceHolder.Callback`（监听表面创建 / 销毁 / 改变）；
2. 通过`getHolder()`获取`SurfaceHolder`，设置`setFormat`/`setKeepScreenOn`等；
3. 在`surfaceCreated()`中开启**绘图子线程**，在`surfaceDestroyed()`中停止线程、释放资源；
4. 绘图时通过`SurfaceHolder.lockCanvas()`获取画布，绘制完成后`unlockCanvasAndPost(canvas)`提交。

高频次绘图场景（普通 View 易卡顿 / ANR）：**相机预览、视频播放、游戏开发、实时绘图（如波形图）**。

与普通 View 的核心区别

普通 View 绘图在**UI 线程**，仅适用于低频次绘制；

SurfaceView 绘图在子线程，双缓冲，支持高频绘制，内存开销稍大。



**RecyclerView 的使用和基本原理**

1. 布局中引入`RecyclerView`，添加依赖（AndroidX）；
2. 定义**ViewHolder**：继承`RecyclerView.ViewHolder`，绑定控件（避免多次 findViewById）；
3. 定义**Adapter**：继承`RecyclerView.Adapter<自定义ViewHolder>`，重写 3 个方法：`onCreateViewHolder`（创建 ViewHolder）、`onBindViewHolder`（绑定数据）、`getItemCount`（返回数据量）；
4. 代码中设置**LayoutManager**（核心，控制布局方式：线性 / 网格 / 瀑布流，如`LinearLayoutManager`）；
5. 绑定 Adapter，可选设置`ItemDecoration`（分割线）、`ItemAnimator`（增删动画）。

基本原理（核心：ViewHolder 复用机制）

- 核心：回收屏幕**不可见的 Item**，复用其 View 和 ViewHolder，减少 View 的创建和`findViewById`次数，降低内存开销、提升性能；
- 关键组件：
  1. **LayoutManager**：负责 Item 的布局、回收、复用，决定 RecyclerView 的显示形式；
  2. **RecycledPool**：复用池，存储回收的 ViewHolder，供新 Item 快速复用；
  3. **Adapter**：负责数据与 ViewHolder 的绑定，通知数据变化；
- 流程：滑动时，不可见的 Item 被回收至复用池，新进入屏幕的 Item 从复用池获取 ViewHolder，仅更新数据，无需重新创建 View。



**序列化的作用 + Android 两种序列化的区别**

1. 序列化的核心作用

1. **对象持久化**：将对象转换为字节流，保存到文件 / 数据库，下次可恢复为对象；

2. **跨进程 / 组件数据传递**：如 Activity/Fragment 之间通过 Intent 传对象、AIDL 跨进程通信；

3. 网络传输

   ：将对象转换为字节流，通过网络发送给服务端 / 其他设备。

   本质

   ：解决对象在内存与字节流之间的转换问题，实现对象的跨介质传输 / 存储。

   

2. Android 两种序列化方式核心区别

Android 支持**Serializable**（Java 原生）和**Parcelable**（Android 专属），核心差异如下：

|   特性    |                    Serializable                    |                Parcelable                |
| :-------: | :------------------------------------------------: | :--------------------------------------: |
| 所属体系  |                 Java 原生，跨平台                  |      Android 专属，仅适用于 Android      |
| 实现方式  |            实现接口，自动序列化（反射）            |       实现接口，手动重写 4 个方法        |
| 执行效率  |             低（反射 + 大量临时对象）              |        高（无反射，直接内存操作）        |
| 内存开销  |                         大                         |                    小                    |
| 序列化 ID | 需显式定义`serialVersionUID`（避免版本不一致报错） |                   无需                   |
| 适用场景  |              轻量持久化（如文件存储）              | 跨进程 / 组件传对象（Intent/AIDL，推荐） |

#### 插值器（Interpolator）& 估值器（TypeEvaluator）

1. 插值器（Interpolator，API21 + 对应 TimeInterpolator）

- 核心：**控制动画的变化速率**，决定动画在不同时间点的**进度占比**（0→1）；
- 作用：如加速、减速、匀速、先快后慢、弹跳等效果，不关心动画的实际属性值；
- 系统自带：`LinearInterpolator`（匀速）、`AccelerateInterpolator`（加速）、`DecelerateInterpolator`（减速）、`OvershootInterpolator`（回弹）等；
- 自定义：实现`TimeInterpolator`接口，重写`getInterpolation(float input)`方法（input 为时间进度 0→1，返回动画进度 0→1）。

2. 估值器（TypeEvaluator）

- 核心：**根据插值器的动画进度，计算出属性的实际值**；
- 作用：将插值器的抽象进度（0→1），转换为具体的属性值（如坐标、颜色、大小），是属性动画的核心；
- 系统自带：`IntEvaluator`（整型）、`FloatEvaluator`（浮点型）、`ArgbEvaluator`（颜色）；
- 自定义：实现`TypeEvaluator`接口，重写`evaluate(float fraction, T startValue, T endValue)`方法（fraction 为插值器返回的进度，返回实际属性值）。

**二者协同关系**

**插值器给出「动画进度」，估值器根据进度计算「实际属性值」**，共同决定属性动画的最终效果：

`时间→插值器→动画进度（0→1）→估值器→实际属性值→View属性更新`。



#### Android 中数据存储方式（五大类 + 特点 + 适用场景）

Android 提供 5 种核心存储方式，覆盖轻量配置、结构化数据、大文件、跨应用共享等所有场景：



**SharedPreferences**

- 形式：轻量**键值对**存储，底层为 XML 文件，默认私有；
- 特点：存取简单，支持基本数据类型（String/int/boolean 等）；
- 适用：存储应用配置（如用户名、开关状态、字体大小），不适合大量数据。



**文件存储**

- 分类：**内部存储**（`/data/data/包名/files/`，私有，无需权限）、**外部存储**（SD 卡，公有 / 私有，需读写权限）；
- 形式：字节流 / 字符流读写，支持任意格式文件（文本、图片、视频）；
- 适用：存储大文件（如缓存、下载的资源、日志文件）。



**SQLite 数据库**

- 特点：Android 内置**轻量关系型数据库**，支持 SQL 语句，事务管理，适合结构化数据；

- 操作：通过`SQLiteOpenHelper`创建 / 管理数据库，`SQLiteDatabase`执行增删改查；

- 适用：存储结构化、关联性数据（如本地通讯录、订单记录）。

  

**ContentProvider**

- 核心：Android**跨应用数据共享的标准方式**，封装底层数据源（如 SQLite / 文件），对外提供统一的增删改查接口；

- 特点：天生单例，支持权限控制，跨进程通信；

- 适用：需要给其他应用共享数据（如系统通讯录、媒体库，自定义应用的共享数据）。

  

**网络存储**

- 形式：将数据存储到**服务器 / 云平台**（如阿里云、Firebase），通过网络请求（Http/Retrofit）存取；
- 特点：数据永久保存，可跨设备同步，无需本地内存；
- 适用：大量数据、需要跨设备共享的场景（如用户信息、应用内容、云相册）。



### Android源码相关分析

**Activity-Window-View-surface **

|      组件名称      |                 核心定位                 |                           核心职责                           |                           关键关联                           |               运行进程                |                           核心作用                           |
| :----------------: | :--------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :-----------------------------------: | :----------------------------------------------------------: |
|    **Activity**    |       应用层页面业务与生命周期载体       | 管理页面生命周期（onCreate/onResume 等）、处理业务逻辑、与 AMS 通信调度 | 持有唯一**PhoneWindow（Window 具体实现）**，通过 setContentView 将布局加载到 Window 的内容区域 | 应用自身进程（ActivityThread 主线程） | 页面业务逻辑与生命周期的核心管理者，是应用与用户交互的业务入口，不直接参与视图绘制 |
|     **Window**     | 框架层视图容器抽象（实现为 PhoneWindow） | 管理窗口属性（标题栏、大小、位置、背景），承载整个 View 树，作为 Activity 与视图系统的中间衔接层 | 内部持有**DecorView（View 树的根节点）**，并与**ViewRootImpl**建立关联，由 ViewRootImpl 负责 View 树的实际调度与系统通信 |             应用自身进程              | 视图的 “容器壳”，不直接处理绘制，仅提供视图承载环境，衔接 Activity 业务与 View 绘制、系统窗口服务 |
|      **View**      |       框架层 UI 基本绘制与交互单元       | 执行 onMeasure（测量）、onLayout（布局）、onDraw（绘制），处理触摸、点击等交互事件 | 所有 View 构成树状结构，**根节点为 DecorView**，测量、布局、绘制流程统一由**ViewRootImpl**调度，绘制内容输出到 Surface |        应用自身进程（主线程）         | UI 界面的基础构成单元，负责具体的视觉呈现与用户交互响应，执行逻辑受 ViewRootImpl 管控 |
|    **Surface**     |       框架层绘图内存缓冲区（画布）       | 分配图形内存，存储 View 绘制后的像素数据，为图像合成提供原始素材 | 每个 Window 对应一个 Surface，**由 ViewRootImpl 负责其创建、更新、销毁与提交**，直接与 SurfaceFlinger 交互 |             应用自身进程              | View 绘制的 “画布载体”，存储绘制结果，是应用端绘制与系统端合成的衔接点，生命周期由 ViewRootImpl 控制 |
| **WindowManager**  |       应用端窗口管理代理（客户端）       | 负责应用内 Window 的添加、移除、属性更新，向系统 WMS 发起窗口注册 / 更新请求 | 与 WMS 通过 Binder 通信，**通过 ViewRootImpl 完成窗口属性、Surface 信息的传递与交互**，管理应用所有 Window 实例 |             应用自身进程              | 应用与系统窗口服务的 “通信桥梁”，不直接操作 View，仅协调 Window 与 WMS 的交互逻辑 |
| **SurfaceFlinger** |         系统层图像合成与显示服务         | 收集所有应用 / 系统窗口的 Surface 图像数据，按窗口层级、透明度完成图层合成，将最终画面提交给硬件显示模块 | 接收**ViewRootImpl**提交的 Surface 数据，与 WMS 协作管理窗口层级，是屏幕显示的最终处理者 |    系统独立进程（SurfaceFlinger）     | 系统显示核心，负责多窗口图像的合成与输出，保障界面显示的流畅性与统一性 |

1. **Window、DecorView、ViewRootImpl 三者核心关系**

   - **Window（PhoneWindow）是 “容器载体”**：每个 Activity 对应一个 PhoneWindow，它是视图的 “壳”，不参与具体绘制，仅管理窗口属性（如标题栏、背景），内部持有两个核心对象 ——**DecorView**和**ViewRootImpl**。
   - **DecorView 是 “View 树根节点”**：是整个 View 树的最顶层 View，内部包含标题栏和内容栏（setContentView 加载的布局会放入内容栏），所有 UI 控件最终都嵌套在 DecorView 下，是 View 绘制的起点。
   - **ViewRootImpl 是 “视图调度中枢”**：并非 View，而是 View 树的管理者，与 Window、DecorView 一一绑定，**统一调度 DecorView 及所有子 View 的测量、布局、绘制流程**，同时负责管理 Surface、与 WMS 通信、向 SurfaceFlinger 提交绘制数据，是应用端视图与系统服务的核心衔接点。

   

2. **整体层级与协作链路**

   从应用业务到屏幕显示，形成完整闭环：**Activity（业务调度）→Window（容器承载，关联 DecorView+ViewRootImpl）→DecorView（View 树根）→View（具体绘制，受 ViewRootImpl 调度）→Surface（画布，由 ViewRootImpl 管理）→WindowManager（通过 ViewRootImpl 与 WMS 通信）→SurfaceFlinger（合成显示）**。

   核心逻辑：Activity 创建 Window 并挂载 DecorView，ViewRootImpl 接管 View 树调度，驱动 View 完成绘制并写入 Surface，再通过 WindowManager 向 WMS 注册窗口，最终由 ViewRootImpl 将 Surface 提交给 SurfaceFlinger 合成显示。

   

3. **进程与职责边界**

   - 应用端（Activity、Window、DecorView、View、ViewRootImpl、Surface、WindowManager）均运行在**应用自身进程**，其中 ViewRootImpl 是核心枢纽，既管控 View 绘制逻辑，又负责跨进程通信；
   - 系统端（SurfaceFlinger）运行在**独立系统进程**，专注于图像合成与显示，通过 ViewRootImpl 接收应用绘制数据，实现应用与系统显示的解耦，保障显示效率与稳定性。





**HttpUrlConnection 和 okhttp 关系**

**基础与封装关系**：HttpUrlConnection 是 Android 原生基础网络 API，隶属[java.net](https://java.net)包，功能简洁轻量，需手动封装连接池、超时、重试等；OkHttp 是 Square 开源的第三方网络框架，基于 Socket 封装，是对原生网络能力的高级增强。

**底层兼容与替代**：Android 4.4 后，系统原生 HttpUrlConnection 底层复用 OkHttp 核心逻辑，高版本中使用原生 HttpUrlConnection 本质是间接用 OkHttp，Google 官方推荐高版本优先用 OkHttp 替代原生。

**功能互补与进阶**：HttpUrlConnection 无第三方依赖，适合轻量简单请求，低版本兼容性好；OkHttp 实现连接池复用、拦截器、自动重连、HTTPS 适配等高级功能，是 Android 主流网络框架，Retrofit 也以其为底层。



**Bitmap 对象的理解**

**核心定义**：Bitmap 是 Android 表示位图的核心对象，存储图片像素数据（颜色、透明度、像素排列等），是图片加载、处理、展示的基础，所有可视化图片最终都会转换为 Bitmap。

**内存特性**：Bitmap 是内存占用大户，内存与分辨率、色彩模式（如 ARGB_8888）直接相关；Android 8.0 前像素数据存 Native 堆，8.0 后移至 Java 堆，由 GC 统一管理。

**使用注意事项**：管理不当易引发 OOM 和内存泄漏，需通过图片压缩、Bitmap 复用、及时回收（recycle ()）、弱引用持有优化；同时提供像素操作、缩放、裁剪等 API，是图片处理核心。



**ActivityThread，AMS，WMS 的工作原理**

|             组件名称              |                           核心定位                           |       运行进程        |                         核心工作原理                         |                           关键关联                           |
| :-------------------------------: | :----------------------------------------------------------: | :-------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|       **ApplicationThread**       | 应用端与 AMS 通信的**Binder 代理类**（ActivityThread 内部类） |     应用自身进程      | 作为应用进程的 “通信代表”，通过 Binder 机制接收 AMS 发送的所有指令（如组件启动、生命周期调度），并将指令转发给 ActivityThread 的主线程 Handler 执行，同时向 AMS 反馈应用组件的状态变化 | 隶属于 ActivityThread，与 AMS 通过 Binder 双向通信，是 AMS 与 ActivityThread 的通信桥梁 |
|        **ActivityThread**         |     应用进程**主线程（UI 线程）**，应用进程的核心调度者      |     应用自身进程      | 应用启动时从 main () 方法入口，初始化主线程 Looper 与消息循环；通过 ApplicationThread 接收 AMS 指令，调度四大组件（Activity/Service 等）的生命周期方法执行；负责 UI 操作的主线程调度，保证所有 UI 操作在主线程执行 | 持有 ApplicationThread 实例，关联 Application、Window，与 WMS 通过 ViewRootImpl 间接交互 |
| **AMS（ActivityManagerService）** |            系统 “组件管家”，Android 核心系统服务             | SystemServer 系统进程 | 统一管理所有应用的四大组件生命周期；维护进程优先级列表，按规则进行进程的创建、唤醒与回收；管理 Activity 任务栈与启动模式，通过 Binder 向应用的 ApplicationThread 发送组件调度指令 | 与所有应用的 ApplicationThread 通信，配合 WMS 完成组件与窗口的联动，是系统组件调度的总控中心 |
|  **WMS（WindowManagerService）**  |            系统 “窗口管家”，Android 核心系统服务             | SystemServer 系统进程 | 管理所有应用 / 系统窗口的创建、布局、显示与隐藏；维护窗口层级关系，与应用端 ViewRootImpl 交互调度 View 树的测量、布局、绘制；处理触摸事件的分发，配合 AMS 实现组件生命周期与窗口状态的联动 | 与 AMS 协同工作，通过 ViewRootImpl 与应用端 Window/View 交互，关联 SurfaceFlinger 完成窗口图像合成 |



**LaunchMode 应用场景和 taskAffinity，clearFlags，addFlags 等影响**

**LaunchMode 及应用场景**：

standard（默认，每次新建，适用于普通页面）；

singleTop（栈顶复用，适用于通知跳转、搜索页）；

singleTask（栈内单例，适用于首页、设置页）；

singleInstance（全局单例，适用于电话、音乐页）。

**taskAffinity 的影响**：

标记 Activity 所属任务栈，默认是应用包名，可自定义；

配合 singleTask/allowTaskReparenting，实现跨应用任务栈管理或 Activity 切换任务栈。

**clearFlags 的影响**：

启动时清除任务栈实例，核心标记 FLAG_ACTIVITY_CLEAR_TOP（清空目标上方 Activity）、FLAG_ACTIVITY_CLEAR_TASK（清空整个任务栈），解决 Activity 堆积问题。

**addFlags 的影响**：

动态修改启动行为，优先级高于清单配置，核心标记 FLAG_ACTIVITY_NEW_TASK（新建任务栈，适用于 Service 启动 Activity）、FLAG_ACTIVITY_SINGLE_TOP（动态栈顶复用）、FLAG_ACTIVITY_NO_HISTORY（不保留在任务栈）。



**请介绍下 ContentProvider 是如何实现数据共享的？**

**核心实现基础**：ContentProvider 是 Android 跨进程数据共享标准方案，底层基于 Binder 机制，屏蔽跨进程通信细节，提供统一访问接口。

**统一数据访问接口**：封装底层存储（SQLite、文件、SP 等），对外提供 insert、delete、update、query 四大操作，外部无需关心存储方式，实现解耦。

**唯一 Content URI 标识**：通过 content:// 包名 / 数据源 / ID 的 URI 唯一标识数据源，外部通过 URI 指定操作目标，内部用 UriMatcher 匹配 URI，定位数据源。

**ContentResolver 中介**：外部应用通过 ContentResolver 调用四大操作，ContentResolver 作为中间层，通过 Binder 将请求传递给目标 ContentProvider，处理跨进程通信。

**权限控制机制**：在清单中配置读写权限，外部应用需申请授权才能访问，可自定义权限细化控制，保障数据安全。

**数据变化通知**：通过 ContentObserver 监听数据变化，ContentProvider 数据变更时调用 notifyChange ()，外部注册观察者可实时感知，实现数据同步。



**IntentService 原理及作用是什么？**

**核心作用**：IntentService 是 Service 子类，解决普通 Service 运行在主线程无法执行耗时任务的问题，异步串行处理后台任务，执行完毕自动停止，适用于一次性后台任务（下载、同步）。

**核心原理**：底层基于 HandlerThread+Handler 实现，创建时启动带 Looper 的子线程 HandlerThread，创建 ServiceHandler 绑定其 Looper，使 handleMessage () 在子线程执行；多次启动的 Intent 按序放入消息队列，串行处理；所有任务完成后自动调用 stopSelf () 终止服务，是单例设计，多次启动不新建实例。



**说说 Activity、Intent、Service 是什么关系？**

**Activity 与 Service**：同属四大组件，由 AMS 管理生命周期，默认运行在主线程；Activity 负责带 UI 交互，Service 负责无 UI 后台任务，功能互补，共同构成应用核心载体。

**Intent**：组件间通信 “信使”，封装目标组件、操作动作、传递数据，是组件启动、调用、交互的核心载体，无 Intent 无法实现组件调度。

**三者关联**：Activity/Service 通过 Intent 启动对方，AMS 通过 Intent 匹配目标组件；Intent 通过 putExtra 传递数据，是组件间数据交互主要方式；bindService 绑定后，Activity 与 Service 建立关联，需手动解绑避免泄漏。



**ApplicationContext 和 ActivityContext 的区别**

**生命周期不同**：ApplicationContext 是全局上下文，生命周期与应用进程一致，全局单例；ActivityContext 与所属 Activity 绑定，Activity 销毁即回收，每个 Activity 对应一个。

**使用范围不同**：ApplicationContext 适用于全局非 UI 操作（获取系统服务、SP、数据库），可在任意位置使用；ActivityContext 适用于 UI 相关操作（创建 View、弹窗、加载布局），依赖窗口环境。

**内存泄漏风险不同**：持有 ActivityContext 引用易导致泄漏，ApplicationContext 无此风险，工具类、单例优先用 ApplicationContext。

**资源与配置关联不同**：ActivityContext 关联当前 Activity 主题、配置，资源随配置变化；ApplicationContext 关联应用默认配置，资源固定。

**获取方式不同**：ApplicationContext 通过 getApplicationContext ()/getApplication () 获取；ActivityContext 通过 this、getActivity () 获取。



**SP 是进程同步的吗？有什么方法做到同步？**

**SP 进程同步性**：SP 不是进程同步的，仅单进程内通过 synchronized 保证线程安全，跨进程读写 XML 文件无锁机制，会出现数据覆盖、脏数据。

**实现进程同步方法**：

**ContentProvider 封装**：将 SP 操作封装到 ContentProvider，利用 Binder 的跨进程同步机制，官方推荐，稳定规范；

**MMKV 替代**：基于 mmap 与跨进程互斥锁，效率高，是工业级首选；

~~**自定义 AIDL 锁**：通过 AIDL 实现跨进程加解锁，实现复杂；~~

**文件锁**：用 FileLock 对 XML 加锁，兼容性一般，效率较低。



**谈谈多线程在 Android 中的使用**

**核心原则**：主线程仅执行 UI 操作，耗时任务（网络、IO、图片处理）必须放子线程，避免 ANR；子线程不能直接更新 UI，需通过主线程接口切换。

**常用实现方式**：

**Thread+Handler**：基础方式，手动管理线程，易泄漏；

**HandlerThread**：带 Looper 的子线程，适合串行后台任务；

**ThreadPoolExecutor**：线程池，复用线程，适合并发，推荐自定义；

**Coroutine**：Kotlin 协程，轻量非阻塞，生命周期绑定，自动取消，官方首选；

~~**RxJava**：响应式编程，适合复杂异步业务，学习成本高。~~

**注意事项**：避免子线程持有 Activity 强引用，用弱引用或生命周期作用域；UI 更新通过 Handler、runOnUiThread 等；多线程共享数据需保证线程安全；手动处理子线程异常；用线程池 / 协程复用线程，及时回收资源。



**进程和 Application 的生命周期**

**Android 进程生命周期**：系统按进程优先级调度，优先级从高到低：前台进程、可见进程、服务进程、后台进程、空进程；优先级决定回收概率，进程从 Zygote 孵化到组件运行，最终因退出或内存不足被回收。

**Application 生命周期**：单例全局上下文，生命周期与进程基本一致，仅 onCreate () 一个核心回调，进程启动时执行一次，做全局初始化；进程销毁时 Application 被销毁，无 onDestroy ()；配置变化导致 Activity 重建时，Application 不重新创建。

**两者关系**：单进程应用中，Application 与进程生命周期一致；多进程应用中，每个进程创建独立 Application 实例；进程优先级决定 Application 存活，提升进程优先级可延长其生命周期。



**AndroidManifest 的作用与理解**

**核心定位**：Android 应用全局核心配置文件，是应用运行必要文件，系统通过其了解应用组成、能力、规则，所有四大组件必须在此注册。

**核心作用**：注册四大组件，配置启动模式、权限、进程；声明应用包名、图标、主题、Application 等基本信息；申请系统权限，区分普通与危险权限；配置 SDK 版本，适配系统；指定应用启动页；声明自定义权限，控制跨应用访问；配置多进程、Intent 过滤、元数据、系统特性等。

**核心理解**：是应用与系统的 “契约”，配置打包后不可修改，直接影响应用运行、兼容、权限与组件调度，配置错误会导致崩溃或功能失效，是 Android 开发不可或缺的核心文件。



**为什么不能在子线程更新UI？**

Android 通过**ViewRootImpl**对 UI 操作做严格的线程校验，其内部`checkThread()`方法会检测执行 UI 操作的线程是否为应用**主线程（ActivityThread）**：

核心根源是**UI 组件线程非安全 + 系统无同步设计**，为避免多线程操作的混乱和性能损耗，Android 通过 ViewRootImpl 的线程校验 + 主线程统一调度，从设计和代码层面双重禁止子线程更新 UI。



**OOM 是什么？**

OOM 即内存溢出（OutOfMemoryError），是应用申请内存时，超出系统分配的最大内存阈值，虚拟机无法分配内存，触发的系统级错误，会直接导致应用崩溃。

**什么情况导致 OOM？**

大图片 / Bitmap 未优化、内存泄漏长期累积、一次性加载大量对象 / 资源、资源未及时释放、第三方库占用内存过高。

**有什么解决方法可以避免 OOM？**

优化 Bitmap（压缩、复用、回收）、修复内存泄漏、复用对象 / 线程池、及时释放资源、分块处理大文件、使用软 / 弱引用。

**OOM 是否可以 try catch？为什么？**

不可以。OOM 属于 Error（系统级错误），非 Exception，此时内存耗尽、虚拟机状态不稳定，捕获后无法恢复，无实际意义。

**内存泄漏是什么？**

无用对象因被强引用持续持有，GC 无法回收，长期占用内存的现象，会逐步耗尽内存，间接引发 OOM。

**什么情况导致内存泄漏？**

长生命周期对象持有短生命周期引用、资源未关闭 / 注销、静态集合未清空、非静态内部类隐式持有外部引用、匿名内部类持有引用。

**如何防止线程的内存泄漏？**

用弱引用持有上下文 / View、页面销毁时取消线程任务、使用静态内部类 + 弱引用、Handler 及时移除消息、用线程池管理线程。

**内存泄漏场景的解决方法？**

单例 / 工具类用 ApplicationContext、静态集合定期清空、资源使用后立即关闭 / 注销、内部类改为静态 + 弱引用、用工具定位并修复引用。

**内存泄漏和内存溢出区别？**

内存泄漏是无用对象无法被 GC 回收，持续占用内存；内存溢出是申请内存超出阈值，无法分配。泄漏是逐步累积，溢出是瞬间崩溃；泄漏是因，溢出是果。



**LruCache 默认缓存大小**

LruCache 无固定硬编码默认值，其默认缓存大小需开发者在实例化时手动指定；框架推荐的通用默认配置为**当前应用进程最大可用内存的 1/8**，开发者可根据业务需求调整该阈值。



**ContentProvider 的权限管理**

1. 读写分离：在 AndroidManifest 中通过`android:readPermission`、`android:writePermission`分别配置读、写独立权限，实现读写权限的分离管控，外部应用需分别申请授权；

2. 权限控制 - 精确到表级：通过自定义细分权限，结合 UriMatcher 匹配不同数据表的 Content URI，对不同数据表单独配置读写权限，实现表级别的精准权限控制；

3. URL 控制：基于 Content URI 的分级设计，通过匹配不同 URI 路径（对应不同数据资源），仅对授权的 URI 开放数据访问权限，限制外部应用对非授权数据的访问。

   

**如何通过广播拦截和 abort 一条短信？**

1. 注册**有序广播**，指定 Action 为`android.provider.Telephony.SMS_RECEIVED`，并将广播优先级设为最高（如 1000），确保先于其他应用接收短信广播；
2. 在 AndroidManifest 中申请`RECEIVE_SMS`短信接收权限（高版本需结合动态授权）；
3. 在广播接收器的`onReceive`方法中，直接调用`abortBroadcast()`方法，终止广播的后续分发，实现短信拦截；
4. 注意：Android 8.0 + 对静态注册该短信广播做了限制，需采用**动态注册**方式，且部分厂商系统会限制短信拦截权限。



**广播是否可以请求网络？**

可以，但不能直接在广播接收器的`onReceive`方法中执行。因为`onReceive`运行在主线程，直接请求网络会因耗时触发 ANR；需在`onReceive`中开启子线程处理网络请求，或启动 Service/IntentService 执行网络操作，同时避免子线程持有页面强引用导致内存泄漏。



**广播引起 anr 的时间限制是多少？**

前台广播的`onReceive`方法若**10 秒内未执行完成**，触发 ANR；后台广播的超时时间为**60 秒**，超出则触发 ANR。



**Android 线程有没有上限？**

Android 系统对线程数量无**强制硬上限**，但存在实际内存限制：每个线程会分配固定栈空间（主线程默认 1MB，子线程默认 512KB 左右），创建过多线程会快速耗尽进程内存，最终引发 OOM，因此实际开发中不能无限制创建线程。



**线程池有没有上限？**

线程池的线程数量是否有上限，由其创建方式决定：

1. 自定义`ThreadPoolExecutor`：可通过`corePoolSize`（核心线程数）、`maximumPoolSize`（最大线程数）手动指定上限，是开发推荐方式；
2. 系统封装线程池：`FixedThreadPool`有固定线程数上限，`CachedThreadPool`最大线程数为`Integer.MAX_VALUE`（理论无上限，易引发 OOM），`ScheduledThreadPool`可指定核心线程数上限。



**Android 为什么引入 Parcelable？**

为解决**跨进程数据传递的效率问题**，适配 Android 的 Binder 跨进程通信机制：

1. Java 原生的 Serializable 基于磁盘序列化，包含大量反射、IO 操作，效率低、内存开销大；
2. Parcelable 是 Android 专属的序列化方式，基于**内存序列化**，无反射开销，仅序列化数据本身，效率远高于 Serializable；
3. 可精准控制序列化 / 反序列化过程，减少数据冗余，更适合移动端有限的内存和性能资源环境，是 Android 跨进程数据传递的首选方式。

**有没有尝试简化 Parcelable 的使用？**

有，官方和第三方均有成熟的简化方案，核心是避免手动编写繁琐的序列化 / 反序列化代码：

1. Android Studio 原生支持：通过快捷键（Alt+Insert）选择 Parcelable，可**自动生成**`writeToParcel`、`CREATOR`等核心代码，无需手动编写；
2. Kotlin 官方简化：通过`kotlin-parcelize`插件，仅需给数据类添加`@Parcelize`注解，即可自动实现 Parcelable 接口，无需重写任何方法；
3. 第三方库：如 AutoParcel 等，通过注解方式自动生成 Parcelable 实现代码，简化开发流程。



### 开发中常见的一些问题

**屏幕适配的处理技巧都有哪些？**

1. 基础适配：使用 dp/sp 单位（dp 适配尺寸、sp 适配字体），避免硬编码像素值；2. 资源分类：按分辨率分 xxhdpi/xdpi 等目录存放图片，使用矢量图（VectorDrawable）适配所有分辨率；3. 布局适配：用 ConstraintLayout 实现弹性布局，替代 LinearLayout/RelativeLayout，适配不同屏幕比例；4. 百分比适配：使用 PercentLayout 或自定义百分比布局参数，按屏幕占比设置控件大小；5. 今日头条适配：修改 DisplayMetrics 的 density 值，让不同分辨率设备的 dp 值统一；6. 折叠屏 / 平板适配：通过 xlarge 等限定符、分屏模式监听做针对性布局；7. 动态适配：运行时根据屏幕尺寸 / 方向动态调整布局参数。



**服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？**

核心通过**序列号标记 + 串行处理**实现：1. 客户端：为每个待发送数据添加唯一递增序列号，多线程用单线程池 / 串行队列保证发送顺序，多进程通过 ContentProvider/AIDL 实现串行发送；2. 服务端：接收数据后先缓存，按序列号排序，仅当连续序列号数据全部接收后，再按序处理，丢弃乱序 / 重复数据；3. 兜底：若数据丢失，客户端根据服务端的缺失序列号反馈，重传对应数据。



**画出 Android 的大体架构图**

Android 采用**分层架构**，从底层到上层依次为：

1. Linux 内核层：提供进程管理、内存管理、驱动管理（相机 / 网络 / 屏幕）、Binder 通信等核心底层能力；

2. 硬件抽象层（HAL）：封装 Linux 内核驱动，为上层提供统一的硬件访问接口，解耦硬件与系统；

3. 系统运行库层：包含 C/C++ 核心库（如 OpenGL、SSL）+ Android 运行时（ART/VM），负责代码编译 / 运行、内存管理；

4. 应用框架层：提供四大组件、系统服务（AMS/WMS）、各种工具类（View、Handler），封装核心能力供应用层调用；

5. 应用层：包含系统应用（设置、短信）和第三方应用，基于应用框架层开发，运行在 ART 虚拟机中。

   （层级关系：应用层 → 应用框架层 → 系统运行库层 → 硬件抽象层 → Linux 内核层）

   

**动态权限适配方案，权限组的概念**

**权限组**：Android 将功能相关的危险权限归为一个权限组（如相机组含 CAMERA，存储组含 READ_EXTERNAL_STORAGE/WRITE_EXTERNAL_STORAGE），申请组内任意一个权限，用户授权后整组权限均被授予，普通权限无需动态适配，系统自动授予。

**动态权限适配方案**：1. 适配前提：仅对 Android6.0（API23）+ 的危险权限做动态适配；2. 核心步骤：先通过 checkSelfPermission 判断是否已授权，未授权则调用 requestPermissions 申请，在 onRequestPermissionsResult/ActivityResultContracts 中处理授权结果；3. 优化细节：未授权时向用户解释权限用途，若用户拒绝且勾选 “不再询问”，引导至应用设置页开启权限；4. 工具适配：使用 RxPermissions/XXPermissions 等第三方库简化适配代码。



**Android 系统为什么会设计 ContentProvider？**

核心为了解决**Android 跨进程数据共享**的核心需求，同时做了多层优化：1. 屏蔽 Binder 底层复杂度：基于 Binder 实现跨进程通信，为开发者提供统一的 insert/query 等上层接口，无需手动处理 Binder 通信；2. 统一数据访问规范：封装底层数据存储（SQLite / 文件 / SP），外部应用通过 Content URI 统一访问，实现数据存储与访问的解耦；3. 精细化权限控制：支持读写分离、表级别的权限管控，保证共享数据的安全性；4. 系统级数据共享：系统通讯录、短信、媒体库等核心数据均通过 ContentProvider 实现共享，让第三方应用可合规访问；5. 数据变化通知：配合 ContentObserver 实现数据变化的实时监听，保证数据同步。



**下拉状态栏是不是影响 activity 的生命周期**

**不影响**。普通手机端下拉状态栏（仅显示通知 / 快捷设置），仅会触发 Activity 的 onWindowFocusChanged (false)（失去窗口焦点），不会执行 onPause、onStop 等生命周期回调；仅当在部分平板 / 折叠屏设备中，下拉状态栏导致 Activity 被完全遮挡并进入后台时，才会触发 onPause/onStop，手机端无此情况，Activity 生命周期保持不变。



**如果在 onStop 的时候做了网络请求，onResume 的时候怎么恢复？**

首先不建议在 onStop 中执行网络请求（易引发内存泄漏），若已实现，恢复方案：1. 状态记录：在 ViewModel 中维护请求状态（未完成 / 完成 / 失败）和请求结果，ViewModel 生命周期独立于 Activity，不会因页面销毁而丢失；2. onResume 恢复：在 onResume 中判断 ViewModel 中的请求状态，未完成则继续监听请求回调，失败则触发重传，完成则直接取结果更新 UI；3. 生命周期绑定：用 Lifecycle 感知组件绑定网络请求，页面销毁时暂停请求，onResume 时自动恢复；4. 兜底：若未使用 ViewModel，可通过全局变量 / SP 记录请求序列号和状态，onResume 时根据序列号重新请求或获取缓存结果。



**Bitmap 使用时候注意什么？**

1. 强制压缩：对图片做尺寸压缩（按屏幕分辨率缩放）+ 质量压缩，减少内存占用；2. 复用内存：使用 inBitmap 属性复用已存在的 Bitmap 内存，避免频繁创建销毁；3. 及时回收：不再使用时调用 recycle ()，并置空引用；4. 异步处理：图片加载、裁剪、旋转等操作放在子线程，避免阻塞主线程；5. 弱引用持有：用 WeakReference 持有非核心 Bitmap 对象，让 GC 可及时回收；6. 避免大图片：不一次性加载超大图片（如长图），采用分块加载；7. 判空校验：使用前判断 Bitmap 是否为 null、是否已被回收。



**Bitmap 的 recycler ()**

注：正确方法为 recycle ()，作用是**手动释放 Bitmap 的像素数据**：1. 内存管理：Android8.0 前，Bitmap 的像素数据存于 Native 堆，GC 无法自动回收，需手动调用 recycle () 释放；8.0 后像素数据移至 Java 堆，GC 可自动回收，但调用该方法能加速内存释放；2. 使用注意：调用后 Bitmap 不可再使用，否则抛出 IllegalStateException，使用前需通过 isRecycled () 判断状态；3. 执行线程：建议在子线程调用，避免阻塞主线程；4. 配合操作：调用后需立即将 Bitmap 对象置空，避免强引用持有。

**Android 中开启摄像头的主要步骤**

分**调用系统相机**和**自定义相机**两种核心方式：

申请存储权限（Android6.0 + 动态申请）；2. 创建 Intent，设置 Action 为 MediaStore.ACTION_IMAGE_CAPTURE；3. 通过 ActivityResultLauncher 启动相机，接收拍摄的图片数据；4. 解析返回的 Bitmap / 图片路径，做后续处理。

动态申请 CAMERA + 存储权限；2. 布局中添加 SurfaceView/TextureView 作为相机预览界面；3. 获取 Camera（低版本）/CameraManager（Android5.0+）实例，打开指定摄像头；4. 将预览界面与相机绑定，设置预览参数并开启预览；5. 调用拍照 / 录像方法，处理拍摄结果；6. 页面销毁时，及时释放相机资源，避免占用系统资源。



**ViewPager 使用细节，如何设置成每次只初始化当前的 Fragment，其他的不初始化？**

1. 选择适配器：少 Fragment 用 FragmentPagerAdapter（缓存 Fragment，不销毁），多 Fragment 用 FragmentStatePagerAdapter（销毁不显示的 Fragment，节省内存）；2. 预加载控制：通过 offscreenPageLimit 设置预加载的 Fragment 数量，默认预加载左右各 1 个；3. 避免泄漏：Fragment 中避免持有 Activity 强引用，页面销毁时清空数据、解除监听。

仅初始化当前 Fragment 的方法

1. 首选 ViewPager2：ViewPager2 基于 RecyclerView 实现，**默认 offscreenPageLimit=0**，仅初始化当前 Fragment，是官方推荐方案，直接使用即可；2. 原生 ViewPager：设置 viewPager.setOffscreenPageLimit (0)（部分 Android 版本兼容），并重写 PagerAdapter 的 getItemPosition 方法返回 POSITION_NONE，强制不预加载；3. 兜底方案：若上述方法无效，可让 Fragment 实现懒加载，即预加载时仅创建视图，在 Fragment 可见时再初始化数据。

 

**CAS 介绍**

CAS 即**Compare And Swap（比较并交换）**，是**无锁并发编程**的核心原子算法，基于 CPU 硬件指令（cmpxchg）实现，保证操作的原子性；1. 核心原理：包含三个核心值 —— 内存值 V、预期值 A、更新值 B，算法逻辑为：比较内存值 V 与预期值 A，若相等则将内存值 V 更新为 B，返回操作成功；若不相等则不做任何操作，返回操作失败，失败后可通过循环自旋重试；2. 核心优势：无需加锁（synchronized/Lock），避免线程阻塞和锁竞争，并发效率更高；3. 存在问题：ABA 问题（内存值从 A 变 B 再变 A，CAS 会误判为未修改）、循环自旋消耗 CPU（重试次数过多）、仅能保证单个变量的原子性；4. Android 应用：Java 中的 AtomicInteger/AtomicBoolean 等原子类，以及 Android 中的并发工具，均基于 CAS 实现，用于解决多线程下的变量原子更新问题。



### 混合开发面试题
大厂除了技术深度之外，还要求你具备一些广度的知识，比如你要会前端知识，会混合开发，至少会一种脚本语言，C c++更不用说了，也是必会的。

Hybrid做过吗？

Hybrid通信原理是什么，有做研究吗？

react native有多少了解？讲一下原理。

weex了解吗？如何自己实现类似技术？

flutter了解吗？内部是如何实现跨平台的？

Dart语言有研究过吗？

快应用了解吗？跟其她方式相比有什么优缺点？

说说你用过的混合开发技术有哪些？各有什么优缺点？

Python会吗？

会不会PHP？

Gradle了解多少？groovy语法会吗？



### 高端技术面试题
这里讲的是大公司需要用到的一些高端Android技术，这里专门整理了一个文档，希望大家都可以看看。这些题目有点技术含量，需要好点时间去研究一下的。

#### 图片

图片库对比

图片库的源码分析

图片框架缓存实现

LRUCache原理

图片加载原理

自己去实现图片库，怎么做？

Glide源码解析

Glide使用什么缓存？

Glide内存缓存如何控制大小？

#### 网络和安全机制

描述一次网络请求的流程

网络框架对比和源码分析

自己去设计网络请求框架，怎么做？

okhttp源码

网络请求缓存处理，okhttp如何处理网络缓存的

从网络加载一个10M的图片，说下注意事项

TCP的3次握手和四次挥手

TCP与UDP的区别

TCP与UDP的应用

HTTP协议

HTTP1.0与2.0的区别

HTTP报文结构

HTTP与HTTPS的区别以及如何实现安全性

如何验证证书的合法性?

https中哪里用了对称加密，哪里用了非对称加密，对加密算法（如RSA）等是否有了解?

client如何确定自己发送的消息被server收到?

谈谈你对WebSocket的理解

WebSocket与socket的区别

谈谈你对安卓签名的理解。

请解释安卓为啥要加签名机制?

视频加密传输

App 是如何沙箱化，为什么要这么做？

权限管理系统（底层的权限是如何进行 grant 的）？

#### 数据库

sqlite升级，增加字段的语句

数据库框架对比和源码分析

数据库的优化

数据库数据迁移问题



### 算法

排序算法有哪些？

最快的排序算法是哪个？

手写一个冒泡排序

手写快速排序代码

快速排序的过程、时间复杂度、空间复杂度

手写堆排序

堆排序过程、时间复杂度及空间复杂度

写出你所知道的排序算法及时空复杂度，稳定性

二叉树给出根节点和目标节点，找出从根节点到目标节点的路径

给阿里2万多名员工按年龄排序应该选择哪个算法？

GC算法(各种算法的优缺点以及应用场景)

蚁群算法与蒙特卡洛算法

子串包含问题(KMP 算法)写代码实现

一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法

万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射->hash分组->多文件读写效率->磁盘寻址以及应用层面对寻址的优化)

百度POI中如何试下查找最近的商家功能(提示：坐标镜像+R树)。

两个不重复的数组集合中，求共同的元素。

两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？

一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法

一张Bitmap所占内存以及内存占用的计算

2000万个整数，找出第五十大的数字？

烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？

求1000以内的水仙花数以及40亿以内的水仙花数

5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同

时针走一圈，时针分针重合几次

N*N的方格纸,里面有多少个正方形

x个苹果，一天只能吃一个、两个、或者三个，问多少天可以吃完？



### 插件化、模块化、组件化、热修复、增量更新、Gradle

对热修复和插件化的理解

插件化原理分析

模块化实现（好处，原因）

热修复,插件化

项目组件化的理解

描述清点击 Android Studio 的 build 按钮后发生了什么



### 架构设计和设计模式

谈谈你对Android设计模式的理解

MVC MVP MVVM原理和区别

你所知道的设计模式有哪些？

项目中常用的设计模式

手写生产者/消费者模式

写出观察者模式的代码

适配器模式，装饰者模式，外观模式的异同？

用到的一些开源框架，介绍一个看过源码的，内部实现过程。

谈谈对RxJava的理解

RxJava的功能与原理实现

RxJava的作用，与平时使用的异步操作来比的优缺点

说说EventBus作用，实现方式，代替EventBus的方式

从0设计一款App整体架构，如何去做？

说一款你认为当前比较火的应用并设计(比如：直播APP，P2P金融，小视频等)

谈谈对java状态机理解

Fragment如果在Adapter中使用应该如何解耦？

Binder机制及底层实现

对于应用更新这块是如何做的？(解答：灰度，强制更新，分区域更新)？

实现一个Json解析器(可以通过正则提高速度)

统计启动时长,标准



### 性能优化

如何对Android 应用进行性能分析以及优化?

ddms 和 traceView

性能优化如何分析systrace？

用IDE如何分析内存泄漏？

Java多线程引发的性能问题，怎么解决？

启动页白屏及黑屏解决？

启动太慢怎么解决？

怎么保证应用启动不卡顿？

App启动崩溃异常捕捉

自定义View注意事项

现在下载速度很慢,试从网络协议的角度分析原因,并优化(提示：网络的5层都可以涉及)。

Https请求慢的解决办法（提示：DNS，携带数据，直接访问IP）

如何保持应用的稳定性

RecyclerView的原理

ListView的优化

RecycleView优化

View渲染

Bitmap如何处理大图，如一张30M的大图，如何预防OOM

java中的四种引用的区别以及使用场景

强引用置为null，会不会被回收？



### NDK、jni、Binder、AIDL、进程通信有关

请介绍一下NDK

什么是NDK库?

jni用过吗？

如何在jni中注册native函数，有几种注册方式?

Java如何调用c、c++语言？

jni如何调用java层代码？

进程间通信的方式？

Binder机制

简述IPC？

什么是AIDL？

AIDL解决了什么问题？

AIDL如何使用？

Android 上的 Inter-Process-Communication 跨进程通信时如何工作的？

多进程场景遇见过么？

Android进程分类？

进程和 Application 的生命周期？

进程调度

谈谈对进程共享和线程安全的认识

谈谈对多进程开发的理解以及多进程应用场景

什么是协程？



### framework层、ROM定制、Ubuntu、Linux之类的问题

java虚拟机的特性

谈谈对jvm的理解

JVM内存区域，开线程影响哪块内存

对Dalvik、ART虚拟机有什么了解？

Art和Dalvik对比

虚拟机原理，如何自己设计一个虚拟机(内存管理，类加载，双亲委派)

谈谈你对双亲委派模型理解

JVM内存模型，内存区域

类加载机制

谈谈对ClassLoader(类加载器)的理解

谈谈对动态加载（OSGI）的理解

内存对象的循环引用及避免

内存回收机制、GC回收策略、GC原理时机以及GC对象

垃圾回收机制与调用System.gc()区别

Ubuntu编译安卓系统

系统启动流程是什么？（提示：Zygote进程 –> SystemServer进程 –> 各种系统服务 –> 应用进程）

大体说清一个应用程序安装到手机上时发生了什么

简述Activity启动全部过程

App启动流程，从点击桌面开始

逻辑地址与物理地址，为什么使用逻辑地址？

Android为每个应用程序分配的内存大小是多少？

Android中进程内存的分配，能不能自己分配定额内存？

进程保活的方式

如何保证一个后台服务不被杀死？（相同问题：如何保证service在后台不被kill？）比较省电的方式是什么？

App中唤醒其他进程的实现方式
