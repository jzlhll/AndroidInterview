### java基础面试知识点

**java 中 == 和 equals 和 hashCode 的区别**

==：基本类型比值，引用类型比内存地址；

equals：默认同 ==，重写后可比较对象内容（如 String）；

hashCode：返回对象哈希值，重写 equals 必须重写它，保证内容相等对象哈希值一致，用于哈希表快速定位。



**String、StringBuffer、StringBuilder 区别**

String 底层 final 字符数组，不可变，频繁拼接效率低；StringBuffer 和 StringBuilder 可变，前者线程安全（方法同步）、效率稍低，后者线程不安全、效率高；单线程用 StringBuilder，多线程用 StringBuffer。



**int、char、long 各占多少字节数**

int 占 4 字节，char 占 2 字节，long 占 8 字节。



**int 与 integer 的区别**

int 是基本类型，存值、默认 0；Integer 是 int 的包装类，是对象、存地址、默认 null；支持自动装箱 / 拆箱，Integer 有 - 128~127 缓存。



**谈谈对 java 多态的理解**

多态是同一行为的不同表现形式，基于继承 / 接口实现、方法重写、父类引用指向子类对象；分编译时（方法重载，同名函数）和运行时（方法重写，申明变量是父类，创建的对象是子类）多态，提升代码扩展性和解耦性。



**类与接口**

* 什么是内部类？内部类的作用

定义在其他类 / 方法中的类；可访问外部类私有成员、封装隐藏类、弥补 Java 单继承、让代码更模块化。

* 抽象类和接口区别

抽象类单继承，含抽象 / 非抽象方法、任意属性，体现 is-a 继承关系；接口多实现，属性默认公静常，Java8 + 可加默认 / 静态方法，体现 like-a 行为规范。

* 抽象类的意义

抽取子类共性，定义统一父类规范；通过抽象方法强制子类实现特有逻辑，约束子类行为；不能实例化，避免无意义对象，提升代码规范性和可维护性。

* 抽象类与接口的应用场景

抽象类：子类是同一种类、有共性属性 / 方法需复用，如动物类抽取出食性、移动等共性；接口：不同类需统一行为、无共性属性，如跑、飞接口，人 / 鸟 / 车均可实现。

* 抽象类是否可以没有方法和属性？

可以，抽象类的核心是 abstract 关键字，与是否有成员无关；但该用法无实际业务意义，开发中极少使用。

* 接口的意义

定义行为契约，强制实现类遵守；弥补 Java 单继承局限，支持多实现；面向接口编程，解耦模块依赖；实现行为层面复用，提升代码扩展性和可维护性。

* 静态属性 / 方法：是否可继承、可重写 + 原因

可继承：子类能通过类名 / 对象直接使用父类静态成员，静态成员属于类本身，随类的继承被子类拥有；

不可重写：重写依赖**运行时多态**，而静态成员是**编译期静态绑定**（绑定到所属类），子类同名静态方法仅为**隐藏 / 遮蔽**父类方法，非重写。

* 静态内部类的设计意图

1. 封装相关逻辑，避免全局类污染命名空间；
2. 不依赖外部类实例，可独立创建使用，解耦与外部类非静态成员的关联；
3. 内聚外部类相关功能（仅需访问外部类静态成员），提升代码整洁性。

	成员内部类：非静态，依赖外部类实例，可访问外部类**所有成员**；

	静态内部类：静态，独立无外部类实例依赖，仅访问外部类**静态成员**；

	局部内部类：定义在方法 / 代码块中，作用域仅限当前区域，可访问外部隐式 final 变量；

	匿名内部类：无类名，定义即实例化，仅一次性使用，可继承类 / 实现接口。

* 项目应用

	成员内部类：实体类的关联辅助类（如早期 HashMap 的 Entry 类）；

	静态内部类：工具类细分功能（如 ArrayList 的 Itr 迭代器）、独立关联组件；

	局部内部类：方法内专用临时类（如方法内自定义排序的比较器，避免全局暴露）；

	匿名内部类：一次性回调 / 接口实现（线程创建、按钮点击事件、集合临时排序）。

* 父类的静态方法能否被子类重写

不能；静态方法属于类，编译期静态绑定到所属类，子类同名静态方法仅**隐藏**父类方法，不具备运行时多态的重写特征。

**闭包和局部内部类的区别**

- 形式：局部内部类是**具名类**，需实例化调用方法；闭包是**代码块**，可直接执行 / 作为参数传递，轻量无类名；
- 变量访问：局部内部类仅能访问外部**final / 有效 final**变量，不可修改；闭包可直接持有并**修改外部变量引用**（Java8+/Kotlin）；
- 状态持有：局部内部类通过类实例持有外部状态；闭包直接绑定外部变量，更简洁地携带状态执行。

> 若闭包**未访问外部类成员 / 变量**：编译为**静态内部类**（单例实现，避免外部类实例依赖，优化性能）；
>
> 若闭包**访问了外部类的非静态成员 / 变量**：编译为**普通局部 / 匿名内部类**，通过内部类实例持有外部类引用，实现对外部变量的访问；



**泛型中 extends 和 super 的区别**

? extends T（上界通配符）：限定泛型为「T 或 T 的子类」

**核心边界**：泛型类型 ≤ T（子类 / 自身）

**编译器推导逻辑**：仅确定泛型是 T 的派生类，但**无法确定具体是 T 的哪一个子类**

- **取数据**：无限制（自由取）→ 所有元素必然是 T 的子类，可安全向上转型为 T，这也是 “适用于消费数据” 的原因；
- **存数据**：仅能存 null（唯一安全）→ 因无法确定具体子类，存任何具体 T 的子类对象，都可能造成集合类型混乱（如？extends Number 存 Integer，实际集合可能是 Double 类型），编译器直接禁止以避免类型安全问题。

? super T（下界通配符）：限定泛型为「T 或 T 的父类」

**核心边界**：泛型类型 ≥ T（父类 / 自身）

**编译器推导逻辑**：仅确定泛型是 T 的基类，但**无法确定具体是 T 的哪一个父类**（最顶层为 Object）

- **存数据**：无限制（自由存）→ T 的对象可向上转型为任意父类，因此存**T 或 T 的子类对象**绝对安全，这也是 “适用于生产数据” 的原因；
- **取数据**：仅能取到 Object 类型→ 因无法确定具体是 T 的哪个父类，编译器只能保证取到的是所有类的父类 Object，无法精准转型为 T 或其直接父类。



**final，finally，finalize 的区别**

- **final**：关键字，修饰类（不可继承）、方法（不可重写）、变量（引用 / 值不可修改）；

- **finally**：异常处理关键字，try-catch-finally 中**必执行块**（JVM 强制退出除外），用于释放资源；

- **finalize**：Object 类的方法，GC 回收对象前调用，**Java9 已废弃**，仅早期用于资源清理。

  

**string 转换成 integer 的方式及原理**

1. `Integer.parseInt(String s)`：转**int 基本类型**，底层解析字符串字符为数字，做进制转换，返回纯数值；
2. `Integer.valueOf(String s)`：转**Integer 对象**，底层调用`parseInt`获 int 值，再通过`IntegerCache`缓存（-128~127 复用对象，超出新建）返回；

字符串非纯数字时，均抛出`NumberFormatException`；`new Integer(String s)`已废弃，开发不用。



**进程和线程的区别**

进程是 OS**资源分配最小单位**，有独立内存 / 资源，开销大，进程间相互独立；

线程是 CPU**调度执行最小单位**，隶属于进程，共享进程资源，开销小；

一个进程可包含多个线程，线程是进程的执行单元。



**序列化的方式**

实现**Serializable**接口（标记型，默认序列化，JVM 自动处理）和android的parceable。

**Serializable 和 Parcelable 的区别**

- 适用平台：Serializable 是 Java 跨平台接口；Parcelable 是**Android 专属**接口；
- 效率：Serializable 依赖反射 / IO，效率低；Parcelable 手动实现，无额外开销，效率高；
- 场景：Serializable 用于**网络传输、文件持久化**；Parcelable 用于 Android**组件间传对象**（Intent/Bundle）。



**谈谈对 kotlin 的理解**

Kotlin 是基于 JVM 的编程语言，Android 官方首选开发语言，**完全兼容 Java**；核心特性：

空安全（从语法避免空指针）、

协程（轻量实现并发）、

扩展函数、数据类、委托等；

语法简洁，代码更安全易维护，与 Java 无缝互操作，并非替代而是互补 Java。



**垃圾回收触发条件**
对象不可达（无引用）、引用置为null、引用超出作用域。JVM自动管理，`System.gc()`仅为建议，不保证立即回收。



**常见编码方式**
Base64（64字符集，末尾=，用于二进制转文本）、

URL编码（%+十六进制，如%20）

Unicode（UTF-8等，\u开头）。特征：Base64含+/=；URL编码含%；Base16仅0-9A-F。

**UTF-8中文字节 & int字节**
UTF-8中文通常3字节（生僻字4字节）；Java中`int`固定4字节（与平台无关）。



**静态代理 vs 动态代理**
静态代理：编译期写死，需为每个类写代理，适用于简单固定场景。
动态代理：运行时生成（JDK基于接口，CGLIB基于继承），适用于AOP、事务等需统一处理多类的场景。



**Java异常体系**
`Throwable`为根：

- `Error`：JVM严重错误（如OOM），不处理。
- Exception
  - 受检异常（Checked）：编译检查（如`IOException`），需`throws`或`try-catch`。
  - 非受检异常（Unchecked）：运行时异常（如`NullPointerException`），无需强制处理。



**解析与分派**

- **解析**：编译期将符号引用转为直接引用（静态）。

- 分派

  - 静态分派：重载，依据参数静态类型（编译期）。
  - 动态分派：重写+多态，依据对象实际类型（运行期，JVM通过vtable实现）。

  

**Java反射理解**
运行时动态获取类结构（字段/方法/构造器），通过`Class`、`Method`等操作对象。用途：框架（Spring）、动态代理。注意：性能开销大、破坏封装性、需处理安全限制。



**Java注解理解**
元数据（`@Override`/`@Deprecated`），用于编译检查、文档生成、框架配置（如Spring）。自定义注解需`@Retention(RUNTIME)` + 反射读取。核心：不改变代码逻辑，提供附加信息。



**依赖注入理解**
IoC实现方式：由容器（如Spring）在运行时将依赖（接口实现）注入对象（构造器/setter）。优势：解耦、便于测试（Mock）、提升可维护性。典型场景：Service注入DAO。



**泛型原理**

**类型擦除**：编译后泛型信息擦除，替换为边界类型（如`Object`），插入强制转换。
例：`List<String>` → 编译为`List`，`get()`返回自动转`String`。

作用：编译期类型安全，运行时无泛型。



**Java String认知**
`final`类，内部`private final char[]/byte[]`，不可变。

支持常量池优化（`"abc"`复用），所有操作（`substring`等）返回新对象。

线程安全，适合作为HashMap的key。



**String不可变原因**

- 安全：常量池共享防篡改、类加载器安全。
- 集合：HashMap的key需hashCode稳定（缓存hash值）。
- 线程安全：无需同步。
- 设计保障：`final`类 + 私有final字段 + 无修改API。





浅拷贝：对象无引用类型成员、或无需独立修改引用成员（追求效率）；

深拷贝：对象包含多层引用类型、或需要完全独立的对象实例（如业务对象拷贝、数据快照）。



### 数据结构

**重写equals与hashCode原因**
保证集合（HashMap/HashSet）正确性：

- **约定**：`equals`相等 → `hashCode`必须相等。
- **后果**：若只重写`equals`，对象存入HashMap后可能因hashCode不同无法查找；反之亦然。需同时重写并保持逻辑一致。

 

**1. HashMap 实现原理**

> 不同的 Key 通过哈希计算得到**相同的哈希值**，映射到 HashMap 数组的**同一个桶位**，这种情况就是哈希冲突（哈希碰撞）。
>
> HashMap 解决哈希冲突的核心位置是**数组的单个桶位**：
>
> 该桶位会承载所有哈希冲突的节点，通过**链表（JDK8 前）/ 链表 + 红黑树（JDK8+）** 结构组织这些冲突节点，让每个桶位成为冲突节点的 “集合容器”，从而解决多节点映射同一桶位的问题（JDK8 + 当链表长度≥8 且数组容量≥64 时，桶内链表转红黑树，优化冲突后的查询效率）。

基于哈希表（数组 + 链表 / 红黑树）实现，通过 key 的哈希值散列到数组桶位，链表解决哈希冲突，JDK8 + 当链表长度≥8 且数组容量≥64 时转红黑树优化查询；非线程安全，允许 null 键值，负载因子 0.75 平衡空间与效率。



**2. HashMap 数据结构**

JDK8 及以后：数组 + 单向链表 + 红黑树，数组是主体，红黑树解决链表过长导致的查询低效问题。



**3. HashMap 源码理解**

核心成员：table（存储节点的数组）、loadFactor（负载因子 0.75）、threshold（扩容阈值 = 容量 * 负载因子）；

核心方法：hash ()（key 的 hashCode 高 16 位异或低 16 位，减少碰撞）、putVal ()（核心存储逻辑）、resize ()（扩容并重新哈希节点）；桶位计算：`(数组长度-1) & hash`（替代取模，效率更高）。



**HashMap put 数据（源码角度）**

计算 key 的 hash 值（null 键 hash 为 0）；2. 若 table 未初始化 / 长度为 0，调用 resize () 初始化；3. 计算桶位，桶位为空则直接新建节点放入；4. 桶位有元素：首节点 key 相同则替换 value；首节点是红黑树则树插入；否则链表尾插，插入后若链表≥8 且数组≥64 则转红黑树，遍历中遇相同 key 则替换；5. size+1 后，若超过 threshold 则 resize ()；6. 返回旧 value（无则 null）。



**ConcurrentHashMap 实现原理**

JDK8 前：分段锁（Segment 数组 + HashEntry），锁粒度为 Segment，并发度 = Segment 数；

JDK8  采用**数组 + 链表 + 红黑树**，结合**CAS+Synchronized**（仅锁桶位首节点），锁粒度更小，并发效率更高；不允许 null 键值，天然线程安全，扩容时分段进行。

|              特性              |        CAS         |    Synchronized    |     ReentrantLock      |
| :----------------------------: | :----------------: | :----------------: | :--------------------: |
|             锁类型             |      无锁机制      |     内置隐式锁     |   显式锁（AQS 实现）   |
|           加解锁方式           | 自旋重试，无加解锁 |    JVM 自动处理    | 手动 lock ()/unlock () |
|            核心优势            | 轻量，无锁竞争开销 | 简单易用，自动管理 | 功能灵活，支持高级特性 |
|            适用场景            |  单个变量原子操作  |    通用简单同步    |     复杂定制化同步     |
| 可重入性(允许嵌套代码继续执行) |     无（非锁）     |        支持        |          支持          |

**ArrayMap 和 HashMap 的对比**

存储结构：

ArrayMap 用两个数组（int [] 存哈希值、Object [] 存键值对），无链表 / 红黑树；

HashMap 是数组 + 链表 + 红黑树；

内存：

ArrayMap 无节点对象，内存占用极低，适合小数据量；

HashMap 节点占内存，大数据量更优；

效率：

ArrayMap 查找用二分法，增删需移动数组，小数据快、大数据慢；

HashMap 哈希直接查找，大数据查询 / 增删高效；

场景：

ArrayMap 是 Android 专属；

HashMap 是 Java 通用，全场景适配；

扩容：

ArrayMap 无负载因子，满了直接扩容

HashMap 负载因子 0.75，提前扩容减少碰撞。



**HashTable 实现原理**

基于**数组 + 单向链表**的哈希表实现，无红黑树优化；

全程通过**方法级 Synchronized**加锁，锁整个哈希表；

不允许 null 键值，初始容量 11，负载因子 0.75，扩容为 2n+1，桶位计算直接用 hashCode% 容量；

线程安全但并发效率极低，已被 ConcurrentHashMap 替代。



**HashMap 和 HashTable 的区别**

1. 线程安全：HashMap 非线程安全；HashTable 线程安全（方法 Synchronized）；
2. null 支持：HashMap 允许 1 个 null 键、多个 null 值；HashTable 完全不允许；
3. 容量 / 扩容：HashMap 初始 16，扩容 2n；HashTable 初始 11，扩容 2n+1；
4. 哈希计算：HashMap 有 hash 扰动，(n-1)&hash；HashTable 直接 hashCode% 容量；
5. 效率：HashMap 远高于 HashTable（HashTable 锁整个表，并发冲突严重）；
6. 继承：HashMap 继承 AbstractMap；HashTable 继承古老的 Dictionary 类。



**HashMap 与 HashSet 的区别**

接口实现：

HashMap 实现 Map，存**键值对**；

HashSet 实现 Set，存**单元素**；

底层依赖：

HashSet 基于 HashMap 实现，元素存于 HashMap 的 key，value 是固定常量 PRESENT；

唯一性：HashMap 仅 key 唯一，value 可重复；HashSet 所有元素唯一；

用途：

HashMap 用于键值映射；HashSet 用于去重集合。



**HashSet 与 HashMap 判断元素重复**

**核心逻辑完全一致**：先通过 key 的`hashCode()`计算哈希值，若哈希值不同，直接判定为不同元素；若哈希值相同，再调用 key 的`equals()`方法，**两者均相同**则判定为重复；HashMap 会替换旧 value，HashSet 直接拒绝添加。



**集合 Set 实现 Hash 怎么防止碰撞**

1. 强制要求元素（HashMap 的 key）重写`hashCode()`，保证哈希值均匀分布，减少同哈希值情况；

2. 重写`equals()`，哈希值相同时精准判断是否为同一元素；

3. 底层依赖 HashMap 的**哈希扰动**和`(n-1)&hash`桶位计算，降低碰撞概率；

4. JDK8 + 链表转红黑树，即使发生碰撞，也能保证查询效率 O (logn)；

5. 合理设置初始容量和负载因子，减少扩容前的桶位拥挤。

   

**ArrayList 和 LinkedList 的区别及应用场景**

核心区别

底层结构：

ArrayList 是**动态数组**（基于 Object []）

LinkedList 是**双向链表**（节点存数据 + 前驱 / 后继指针）；

随机访问：

ArrayList 支持（get (i) O (1)），查询极快；

LinkedList 不支持（遍历 O (n)），查询慢；

增删操作：

ArrayList 尾部增删 O (1)，中间 / 头部需移动元素 O (n)；

LinkedList 增删仅修改指针 O (1)（需先找节点 O (n)，批量操作更优）

内存占用：

ArrayList 连续内存，有扩容冗余（默认 1.5 倍扩容）；LinkedList 节点额外存指针，内存开销大；

方法支持：LinkedList 实现 Deque，支持队列 / 栈操作（offer、pop 等）；ArrayList 无相关方法。

应用场景：

ArrayList：适合**大量查询、少量尾部增删**的场景（如数据展示、数据库查询结果缓存、排行榜）；

LinkedList：适合**大量中间 / 头部增删、队列 / 栈实现**的场景（如任务队列、消息队列、链表结构模拟）。



**数组和链表的区别**

| 维度 |                  数组                   |            链表            |
| :--: | :-------------------------------------: | :------------------------: |
| 存储 |              连续内存空间               |     离散节点，指针连接     |
| 访问 |             随机访问 O (1)              |       顺序访问 O (n)       |
| 增删 | 中间 / 头部 O (n)（移元素），尾部 O (1) | 找到节点后 O (1)（改指针） |
| 内存 |     固定容量 / 扩容冗余，无额外开销     |   节点存指针，内存开销大   |
| 适用 |         大量查询、少量尾部增删          |  大量增删、无随机访问需求  |



**二叉树 DFS（深度优先）& BFS（广度优先）实现**

```java
class TreeNode { int val; TreeNode left, right; TreeNode(int x) { val = x; }
//DFS//（前 / 中 / 后序，核心：递归 / 栈实现，优先走子节点）
void dfsPre(TreeNode root) {
    if (root == null) return;
    System.out.print(root.val + " "); // 前序
    dfsPre(root.left);
    dfsPre(root.right);
}

//BFS （层序，核心：队列实现，按层遍历，优先走同层节点）
void bfs(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    while (!q.isEmpty()) {
        TreeNode node = q.poll();
        System.out.print(node.val + " ");
        if (node.left != null) q.offer(node.left);
        if (node.right != null) q.offer(node.right);
    }
}
```

**堆的结构**

1. 底层是**完全二叉树**（仅最后一层右侧缺节点），可用**数组**高效存储；
2. 分**大顶堆**（父节点值 ≥ 所有子节点）、**小顶堆**（父节点值 ≤ 所有子节点）；
3. 数组索引关系（根从 0 开始）：父节点`i` → 左子`2i+1`、右子`2i+2`；子节点`i` → 父`(i-1)/2`；
4. 核心操作：堆化（调整节点位置维持堆性质）、插入 / 删除顶节点，时间复杂度均 O (logn)。

**堆和树的区别**

1. 堆是**特殊的完全二叉树**，有严格的父子值约束（大 / 小顶堆），普通树无此约束；
2. 堆通常用**数组**存储，普通树多为**链式存储**；
3. 堆核心作用是**快速获取极值**（顶节点），树侧重**数据遍历、查找、有序存储**；
4. 普通树的子节点无顺序要求，堆的子节点隐含大小顺序。



**堆和栈的内存区别（数据结构 + 实际实现）**

数据结构层面

- 堆：完全二叉树，支持快速取极值，插入 / 删除 O (logn)；
- 栈：线性结构，先进后出（FILO），入栈 / 出栈 O (1)。

实际实现层面（Java/JVM）

- 栈（虚拟机栈）：**线程私有**，随方法执行创建 / 销毁，帧栈结构，存局部变量、方法调用信息；自动回收，无 GC，易出现`StackOverflowError`（栈溢出）；
- 堆（堆内存）：**所有线程共享**，存对象、数组、常量池；手动 / 自动 GC 回收，分新生代 / 老年代，易出现`OutOfMemoryError`（堆溢出）。



**树、B + 树的理解**

- **树**：非线性分层数据结构，由根、节点、边组成，解决线性结构查询低效问题；核心是**分层遍历、递归结构**，常见类型：二叉树、二叉搜索树、红黑树（自平衡），适用于内存内数据的有序存储 / 查询。

- B + 树

  平衡多路搜索树

  （B 树的优化版），数据库 / 文件系统核心索引结构，适配磁盘 IO：

  1. 非叶子节点仅存**索引键**，不存数据，可存储更多索引，减少 IO 次数；
  2. 所有**数据均存在叶子节点**，且叶子节点通过**链表链式相连**，支持高效范围查询；
  3. 树高度低（多路），磁盘寻道次数少，适合海量外存数据查询。

  

**对图的理解**

1. 非线性结构，由 ** 顶点集 (V)**和**边集 (E)** 组成，是树的泛化（树是无环连通图）；
2. 分类：无向图 / 有向图、加权图（边带值）/ 无权图、连通图 / 非连通图、有环图 / 无环图；
3. 存储方式：**邻接矩阵**（二维数组，适合稠密图，查询 O (1)）、**邻接表**（数组 + 链表，适合稀疏图，节省内存）；
4. 核心遍历：DFS（栈 / 递归）、BFS（队列）；
5. 经典算法：最短路径（Dijkstra/Floyd）、最小生成树（Prim/Kruskal）、拓扑排序；
6. 应用：路网规划、社交关系、依赖分析、电路设计。



**链表逆序（翻转单向链表，简单代码）**

```java
class ListNode { int val; ListNode next; ListNode(int x) { val = x; } }
ListNode reverseList(ListNode head) {
    ListNode pre = null, cur = head;
    while (cur != null) {
        ListNode temp = cur.next; // 保存后继
        cur.next = pre; // 翻转指针
        pre = cur; // 前驱后移
        cur = temp; // 当前后移
    }
    return pre; // 新头节点
}
```



**判断单链表成环与否（简单代码）**

**快慢指针法（面试首选，空间 O (1)）**：快指针走 2 步，慢指针走 1 步，相遇则成环，否则无环。

```java
boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) return false;
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) return true; // 相遇成环
    }
    return false;
}
```



**合并多个递增单有序链表（简单代码）**

**分治思想（面试常用，效率高）**：两两合并，最终合并为一个有序链表。

```java
// 合并两个递增链表（基础方法）
ListNode mergeTwo(ListNode a, ListNode b) {
    ListNode dummy = new ListNode(0), cur = dummy;
    while (a != null && b != null) {
        if (a.val < b.val) { cur.next = a; a = a.next; }
        else { cur.next = b; b = b.next; }
        cur = cur.next;
    }
    cur.next = a == null ? b : a;
    return dummy.next;
}
// 分治合并多个链表
ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) return null;
    return merge(lists, 0, lists.length - 1);
}
ListNode merge(ListNode[] lists, int l, int r) {
    if (l == r) return lists[l];
    int mid = (l + r) / 2;
    ListNode left = merge(lists, l, mid);
    ListNode right = merge(lists, mid + 1, r);
    return mergeTwo(left, right);
}
```



### 线程、多线程和线程池

**1. 开启线程的三种方式**

1. 继承`Thread`类，重写`run()`，调用`start()`；

2. 实现`Runnable`接口，重写`run()`，传入`Thread`启动；

3. 实现`Callable`接口（带返回值 / 异常），配合`FutureTask+Thread`获取结果。

   

**线程和进程的区别**

- 进程：**资源分配基本单位**，独立内存 / 资源，创建 / 切换开销大，进程间隔离；
- 线程：**CPU 调度基本单位**，隶属于进程，共享进程资源，轻量，开销极小；
- 一个进程可包含多个线程，线程是进程的执行单元。



**为什么要有线程，而非仅用进程**

进程创建 / 销毁 / 上下文切换**开销极大**，线程轻量、开销低，提升 CPU 并发利用率；

线程共享进程资源，减少进程间通信的复杂度和开销；适合细粒度的并发任务拆分。



**run () 和 start () 方法区别**

- `start()`：**启动新线程**，让线程进入就绪态，JVM 底层调用`run()`，仅能调用一次；

- `run()`：普通方法，直接调用不会启动新线程，由当前线程（如主线程）执行，可多次调用。

  

**控制方法并发访问线程个数**

使用**Semaphore（信号量）**，初始化指定许可数（最大并发数），方法内`acquire()`获取许可，`finally`中`release()`释放许可，超出许可的线程阻塞。



**Java 中 wait 和 sleep 方法的不同**

1. 所属类：`wait()`是`Object`方法，`sleep()`是`Thread`静态方法；

2. 锁释放：`wait()`释放持有的锁，`sleep()`不释放；

3. 使用场景：`wait()`必须在`synchronized`块内，`sleep()`可在任意位置；

4. 唤醒：`wait()`需`notify/notifyAll`唤醒，`sleep()`超时 / 中断自动唤醒；

5. 用途：`wait()`用于线程间通信，`sleep()`用于线程延时。

   

**对 wait/notify 关键字的理解**

均为`Object`的方法，**必须在 synchronized 同步块 / 方法内使用**；

`wait()`：线程释放锁，进入**等待池**，等待被唤醒；

`notify()`：唤醒等待池中**一个**线程，进入锁池竞争锁；

`notifyAll()`：唤醒等待池中**所有**线程；二者配合实现**线程间的通信与同步**。



**什么导致线程阻塞？**

1. 竞争锁失败（`synchronized`/`Lock`）；

2. 调用`wait()`/`join()`/`park()`；

3. 执行 IO 操作（文件 / 网络读写）；

4. 调用`sleep()`；

5. 线程池队列满，新任务阻塞。

   

**线程如何关闭？**

**禁止使用`stop()`/`suspend()`**（强制终止，易导致数据不一致 / 锁泄漏）；

安全方式：1. 自定义**布尔标志位**，线程循环判断标志位退出；

2. 调用`interrupt()`，线程内通过`isInterrupted()`检测中断信号退出；

3. 线程池任务用`Future.cancel(true)`取消。

   

**Java 中的同步方法**

1. `synchronized`修饰**实例方法**：锁当前对象实例，保证同一实例的该方法互斥访问；
2. `synchronized`修饰**静态方法**：锁类的`Class`对象，保证所有实例的该方法互斥访问。

- **单机并发**：加锁（`synchronized`/`Lock`）、`volatile`、原子类（Atomic）、CAS；
- **分布式**：分布式锁（Redis/ZooKeeper）、分布式事务（Seata/XA）、消息队列（削峰 / 有序）、数据库行锁 / 乐观锁。



**如何保证线程安全？**

核心保证**原子性、可见性、有序性**三大特性，常用手段：

1. 互斥锁（`synchronized`/`ReentrantLock`）；

2. 轻量同步（`volatile`）；

3. 原子操作（Atomic 类 / CAS）；

4. 使用线程安全容器（`ConcurrentHashMap`/`CopyOnWriteArrayList`）；

5. 避免共享可变资源（线程封闭）。

   

**两个进程同时写 / 读的实现与进程同步防止**

- 读操作：**可同时实现**（读共享，无数据竞争）；
- 写操作 / 写读混合：**不可同时**，需互斥，否则数据脏读 / 覆盖；
- 进程同步（互斥）手段：文件锁、系统信号量、共享内存 + 互斥锁、管道 / 消息队列。



**线程间操作 List**

`ArrayList`/`LinkedList`非线程安全，

解决方案：1. `Collections.synchronizedList()`：包装为同步 List（方法级锁，简单）；

2. `CopyOnWriteArrayList`：读多写少场景（写时复制，读无锁，高效）；

3. 手动加锁（`synchronized`/`Lock`）保护 List 操作。

   

**Java 中对象的生命周期**

7 个核心阶段：**创建**（new / 反射）→**加载 / 初始化**（类加载机制）→**就绪**（分配内存、初始化成员）→**运行**（对象可达，被引用）→**阻塞**（暂时无引用 / 等待资源）→**垃圾回收**（对象不可达，进入 GC 队列）→**销毁**（GC 释放内存，对象消亡）。



**synchronized 的原理**

JDK6 后优化为**分级锁**（偏向锁→轻量级自旋锁→重量级锁），根据竞争程度自动升级；基于**对象头 Mark Word**存储锁状态，重量级锁依赖 **Monitor（监视器）** 实现；同步代码块通过`monitorenter/monitorexit`指令加解锁，同步方法通过方法区`ACC_SYNCHRONIZED`标志位实现。



**对 Synchronized 类锁、方法锁、重入锁的理解**

- 方法锁：分**实例方法锁**（对象锁，锁当前实例）和**静态方法锁**（类锁，锁 Class 对象）；

- 类锁：锁的是类的 Class 对象，所有实例共享，保证静态资源的线程安全；

- 重入锁：`synchronized`是天然的可重入锁，底层维护**线程标识**和**重入次数**，同一线程持有锁后可重复获取，避免自死锁。

  

**volatile 的原理**

通过**内存屏障**禁止指令重排，通过**强制主存交互**保证可见性；修改 volatile 变量时，立即刷回主存，其他线程读取时直接从主存加载，不使用工作内存缓存；**不保证原子性**。

仅能修饰**共享成员变量 / 静态变量**，不能修饰方法 / 局部变量；核心场景：1. 修饰**状态标志位**（如线程停止标志）；2. 配合 CAS 实现非阻塞同步；3. 解决**双重检查锁（DCL）单例**的可见性和有序性问题。

锁机制：`synchronized`是独占锁，`volatile`无锁；2. 保证特性：`synchronized`保证原子性、可见性、有序性，`volatile`仅保证可见性、有序性；3. 修饰范围：`synchronized`修饰方法 / 代码块，`volatile`修饰变量；4. 开销：`synchronized`有上下文切换开销，`volatile`轻量无开销；5. 原子性：`synchronized`保证，`volatile`不保证。



**对 NIO 的理解**

Java**非阻塞 IO**（New IO/Non-Blocking IO），适配高并发网络编程；核心组件：`Channel`（双向通道，替代流）、`Buffer`（数据载体，所有 IO 操作基于缓冲区）、`Selector`（选择器，多路复用，单线程管理多个 Channel）；基于**事件驱动**，非阻塞模式，减少线程开销，是 Netty 的底层基础。



**synchronized 与 Lock 的区别**

1. 实现层面：`synchronized`是 JVM 内置关键字，`Lock`是 JUC 包的显式接口；

2. 加解锁：`synchronized`自动加解锁，`Lock`需手动`lock()`/`unlock()`（建议 finally 释放）；

3. 公平性：`synchronized`默认非公平，`Lock`（如 ReentrantLock）可指定公平 / 非公平；

4. 功能：`Lock`支持可中断、限时获取锁、多条件变量，`synchronized`无；

5. 锁粒度：`Lock`更灵活，可实现细粒度锁。

   

**ReentrantLock 、synchronized 和 volatile 比较**

- `volatile`：无锁，轻量，保证可见性 / 有序性，修饰变量，适用于简单状态标记；

- `synchronized`：内置可重入锁，自动加解锁，保证三特性，中等开销，适用于通用同步场景；

- `ReentrantLock`：显式可重入锁（AQS 实现），手动加解锁，支持公平 / 可中断 / 条件变量，灵活，中等开销，适用于复杂同步场景。(tryLock，lock时长...)

  

**死锁的四个必要条件**

必须**同时满足**才会产生死锁：1. **互斥条件**：资源只能被一个线程独占；2. **请求与保持条件**：线程持有一个资源，又请求其他被占用的资源；3. **不剥夺条件**：资源不能被强行剥夺，只能由线程主动释放；4. **循环等待条件**：线程间形成资源的循环依赖链。

破坏**任一**死锁必要条件即可，常用手段：1. 按**固定顺序**获取锁（破坏循环等待）；2. 超时获取锁（`tryLock(long,TimeUnit)`，破坏请求与保持）；3. 一次性获取所有所需资源（破坏请求与保持）；4. 主动释放持有的资源（破坏不剥夺）。



**对象锁和类锁是否会互相影响？**

**不会互相影响**；对象锁是**实例对象**的锁（存储在对象头 Mark Word），类锁是**类的 Class 对象**的锁（Class 对象是单例），二者是**不同的锁对象**，线程持有一个锁，不影响获取另一个。



**什么是线程池，如何使用？**

- 定义：管理线程的容器，**复用线程**，减少线程创建 / 销毁的开销，控制最大并发数，避免资源耗尽；

- 使用：

- 简易方式：`Executors`工具类创建（如`newFixedThreadPool`/`newCachedThreadPool`）；

- 推荐方式：手动创建`ThreadPoolExecutor`（指定核心线程数、最大线程数、空闲时间、任务队列、拒绝策略），避免默认工具类的资源泄漏问题。

  

**Java 的并发、多线程、线程模型**

- 并发：同一时间段内多个任务**交替执行**，提升 CPU 利用率；
- 多线程：进程内的轻量执行单元，是实现并发的核心手段，共享进程资源；
- 线程模型：1. 1:1（内核级线程，Java 默认，一个用户线程对应一个内核线程）；2. M:1（用户级线程，多个用户线程对应一个内核线程）；3. M:N（混合级线程，多对多映射）。



**谈谈对多线程的理解**

多线程是进程内**并行执行的轻量执行单元**，共享进程的内存 / 文件等资源；本质是 CPU**时间片轮转调度**，看似同时执行，实际交替运行；核心价值是提升 CPU 利用率和程序并发效率，适用于 IO 密集型 / CPU 密集型任务拆分；需解决线程安全、死锁、可见性等问题。

1. 线程安全（数据竞争、脏读 / 覆盖）；2. 死锁 / 活锁；3. 上下文切换的性能开销；4. 内存可见性和指令重排；5. 锁泄漏（未释放锁）；6. 线程池拒绝策略和队列溢出；7. 共享资源的合理管控。



**多线程断点续传原理**

将待传输文件**分割为多个固定大小的块**，多线程并行下载 / 上传不同块；实时**记录每个块的已完成进度**（存本地文件 / 数据库）；当传输中断后，重新启动时读取进度记录，仅继续传输**未完成的块**，无需重新传输整个文件，提升传输效率。



**断点续传的实现**

核心步骤：1. 计算文件总大小，按固定大小分割为 N 个块；2. 初始化线程池，为每个线程分配待传输的块；3. 传输过程中实时记录每个块的进度（如已完成字节数，存本地 txt/json）；4. 中断后，读取进度文件，过滤已完成块，重新分配未完成块；5. 所有块传输完成后，合并所有块为完整文件。