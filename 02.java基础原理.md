## HashMap

1. **底层结构（JDK1.8+）**：

   数组（桶）为主体，每个桶下挂链表；当单个桶的链表长度≥8 且数组长度≥64 时，链表转为红黑树（树化）；树节点数≤6 时，红黑树转回链表（退化）。

   桶位计算：`hash(key) & (数组长度-1)`（数组长度为 2^n，等价取模且效率更高）。

2. **put 操作核心**：

   - 计算 hash 确定桶位，桶空则直接插入新节点；
   - 桶非空：key 相等则替换值；是红黑树则调用`putTreeVal`插入，插入后若违反红黑树特性（颜色、左右子树高度差），触发左旋 / 右旋 + 颜色调整维持平衡；是链表则尾插，插完检查是否满足树化条件；
   - 最后检查元素数≥阈值（容量 × 加载因子，默认 0.75），触发扩容。

3. **扩容机制**：

   - 触发条件：元素数≥阈值，或链表长度≥8 但数组长度 < 64（优先扩容而非树化）；
   - 规则：容量翻倍（保持 2^n），重新计算节点桶位（仅两种可能：原位置 / 原位置 + 旧容量）；
   - 红黑树扩容：拆分树节点到新桶，若拆分后节点数≤6 则退化回链表。

4. **查询效率：**

   - 设计逻辑：HashMap 在 put 阶段通过链表转红黑树、红黑树旋转调整等操作，提前构建了高效的查询结构，避免查询时的低效遍历；
   - 自身效率：理想情况（哈希分布均匀）查询 O (1)；链表最坏 O (n)；红黑树 O (logn)；
   - 对比 List / 数组：
     - 数组：按索引查 O (1)，但按 “值” 遍历匹配查 O (n)；
     - List（如 ArrayList）：底层是数组，查询逻辑同数组；LinkedList 按值查 O (n)；

5. **线程安全版 HashMap**：

   - 加锁 HashMap（Hashtable）：全局锁（synchronized 修饰所有方法），并发下所有操作竞争同一把锁，效率极低，已被淘汰；
   - ConcurrentHashMap（JDK1.8+）：
     - 摒弃 JDK1.7 的分段锁，改用**CAS+synchronized** 实现线程安全；
     - 仅锁定当前操作的桶（或红黑树节点），锁粒度极细，多个桶可并发操作；
     - 扩容时采用 “多线程分段扩容”，避免单线程扩容耗时，兼顾线程安全和并发效率。

## 创建对象的原理

堆上分配内存；

栈上分配临时变量指向地址；

1. 类加载检查（类加载，链接，初始化）

2. 分配内存(如果不够，还需要STW来整理内存)
3. 初始化初值



## Java线程同步

###  一、核心特性

1. **内存可见性**：线程修改共享变量后，其他线程能立即看到最新值（避免 CPU 缓存未同步到主内存的问题）。
2. **原子性**：操作不可分割（如赋值`a=1`），多线程下不会被打断；复合操作（如`i++`）不具备原子性。
3. **有序性**：单线程下 JVM 保证执行结果与代码顺序一致（as-if-serial），多线程需通过机制禁止指令重排。

### 二、核心关键字对比

|    关键字    | 可见性 |       原子性        | 有序性 |                           实现方式                           |
| :----------: | :----: | :-----------------: | :----: | :----------------------------------------------------------: |
|   volatile   |   ✅    | ❌（仅单个读写有效） |   ✅    | CPU 的 lock 指令（同步缓存到主内存 + 失效其他缓存）+ 内存屏障（禁止重排） |
| synchronized |   ✅    | ✅（临界区独占执行） |   ✅    |                     临界区机制（排他锁）                     |

### 三、关键问题解答

1. 单例模式为何需要双检测（DCL）？

- 外层`null`判断：减少`synchronized`锁开销（避免每次都进入临界区）。
- 内层`synchronized`：保证单例对象创建的原子性（防止多线程同时创建）。
- volatile 修饰单例变量：禁止对象创建时的指令重排（避免线程拿到 “未初始化完成” 的对象）。

2. volatile 为何不能保证原子性？

- 原子性仅支持**单个变量的读 / 写操作**（如`flag=true`）。
- 复合操作（`i++`）拆分为 “读 - 改 - 写” 三步，多线程下会被打断，volatile 无法干预。



## 锁的种类，特性

### Java 常用锁

#### 1. 内置锁（synchronized）- 自动释放

- 核心优化（JDK1.5+）：锁升级（无锁→偏向锁→轻量级锁→重量级锁），按需减少内核态切换：
  - 偏向锁：单线程重复获取，消除 CAS 开销；
  - 轻量级锁：多线程竞争无阻塞，CAS 自旋尝试获取；
  - 重量级锁：自旋失败，依赖 OS 互斥量，线程阻塞。
- 特性：可重入、默认非公平、不可中断。

#### 2. 显式锁（java.util.concurrent.locks）

- ReentrantLock（可重入锁）：
  - 显式加锁 / 释放（lock ()/unlock ()，需 finally 保证释放）；
  - 特性：可指定公平 / 非公平、可中断、可尝试获取锁（tryLock ()）。
- ReentrantReadWriteLock（读写锁）：
  - 读共享、写排他，适配 “读多写少”；不支持读锁升级，支持写锁降级。
- StampedLock（JDK1.8+）：
  - 替代读写锁，支持乐观读（无锁读，仅验证版本戳），性能更高。

#### 3. 高频同步工具

- CountDownLatch：倒计时，一次性等待多线程完成；
- CyclicBarrier：循环屏障，等待所有线程到达后继续。

### C++ 常用锁

#### 1. 基础互斥锁

- std::mutex：排他锁，不可重入（重复 lock () 死锁），需手动释放；
- std::recursive_mutex：可重入互斥锁，允许同一线程多次 lock ()。

#### 2. 读写锁（C++17+）

- std::shared_mutex：读共享（std::shared_lock）、写排他（std::unique_lock），适配 “读多写少”。

#### 3. 自旋锁与 RAII 封装

- std::atomic_flag：自旋锁实现基础，CAS 自旋，适合锁持有时间极短的场景；
- std::lock_guard/unique_lock：RAII 封装，自动解锁（lock_guard 简单不可手动解锁，unique_lock 更灵活）。



## 反射

反射类的字节码，Class.forName,  .class,  getClass, Method, Filed, Contructor

android中反射，有一些限定。

## 泛型

编译完成后，泛型就擦除变成了Object（指定则变成指定的上限）。

## 注解

Annotation，可以在运行时获取注解，不过在android上普通比较嫌弃。

纯java运行时注解。

编译时注解。

## 多线程

executorService比较简单：

```java
static ExcutorService myNewTest() {
  ExecutorService pool = new ThreadPoolExecutor(2, 4, 60000L, TimeUnit.MILLISECONDS, 
  new ArrayBlockingQueue<Runnable>(3), 
  Executors.defaultThreadFactory(), 
  new ThreadPoolExecutor.AbortPolicy());
  //我们给coreSize2，maxSize4，并且给了ArrayBlockingQueue容量为3的队列。
  //所以当前我们可以先跑2个线程运行，并且队列是空着的；
  //这个时候2个线程还没有干完，又来活儿了，加入到队列中，直到满；
  //当满了，如果maxSize是大于coreSize的，会将现在来的任务直接干（也就是比先加入队列的还要先干活，是不是超出你的想象？）
  //如果还是超过了，就报错。
}

//以下是源码中的Excutors.java:
public static ExecutorService newSingleThreadExecutor() {
  return new FinalizableDelegatedExecutorService
    (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>()));
  //单线程池
  //coreSize，maxSize为1，表示了不可能有额外创建线程的可能；只有1个。
  //时间是0，永远不释放。
  //并且使用链表无限排队。
}

public static ExecutorService newCachedThreadPool() {
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue<Runnable>());
  //与OKHTTP内部线程模型一样
  //coreSize 0, 60的时间，表示没活一段时间后会释放；
  //SynchronousQueue,一个假的队列一直是满的。根据图片规则，超过了就新建线程去了。
  //同时，maxSize Int上限，表示无线创建线程；
  //适用于最大化并发，并且又能够在一定时间内的复用线程。
}

public static ExecutorService newFixedThreadPool(int nThreads) {
  return new ThreadPoolExecutor(nThreads, nThreads,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>());
  //coreSize=maxSize表明不能新建；
  //linkedblockingQueue表明无限压任务排队；
  //0L时间表示不回收线程。
  //适用于固定数量的线程，永远不回收。与单个线程类似。
}
```

自定义线程池：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
```

corePoolSize：描述核心个数。超过核心个数会进入BlockingQueue；

maxSize:          描述最多创建线程数。

blockQueue:   对逻辑产生重大影响。

* SynchronousQueue（无内部容量同步队列）

  没有容量，即（队列是否满了）判断永远是“满了”。

* ArrayBlockingQueue （指定容量的数组阻塞队列）

* LinkedBlockingQueue( 链表阻塞队列) 

  内部是链表，无限往下挂item，即(队列是否满了)判断永远为“未满”。

<img src="https://img-blog.csdnimg.cn/8848b183c1c9471a81d6f6a5a41efede.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAanpsaGxsMTIz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:45%;" />

深入理解和背诵图片，结合，如下4个case大致上就掌握了。



## ThreadLocal内存泄漏的原因

* weakReference和threadLocal的基本用法

  必须放在这里，因为后面好用于解析源码的时候回忆。

```java
//weak ref
WeakReference<Activity> ref = new WeakReference<>(activity);

//thread local
ThreadLocal<String> local = new ThreadLocal<>();
local.set("test");
String s = local.get();
local.remove();
```

* 代码结构

<img src="https://i-blog.csdnimg.cn/blog_migrate/9881acb6c08058a18504acf3a1439054.png#pic_center" alt="threadLocal" style="zoom:40%;" />

画图结合使用逻辑，就清楚了。

假设我们自己的代码中local已经没有引用了，比如Test已经置为null，或者local置为null，可达性已经失去；

那么，作为Entry的key就被回收；而value是强引用设置的值，如果是复杂类型数据的话，就会长时间留存在ThreadLocalMap(table)数组中。在某些get(), remove() , resize() 扩容,set()动作的时候，会尝试clear部分key为null的entry，移除数组并标记value=null，去除引用。

但是这些动作并不一定能跑进去。而且假设你申请的local并不是特别频繁使用的话（即很少调用set，remove, get），这个value的引用将会存在无法回收。

**解决方案：用完记得remove掉。比如Thread结束的时候，或者数据使用完后，记得remove()。有的帖子说搞成static，下面我将Handler会提到。**

* 扩展点1：多线程下有几个local？几个map？多个local变量申明呢？

  * 假设1个local变量，多线程：

    这个很容易理解了吧，每个Thread下面都挂着一个map，只是我们这一个local被多次拿去做Entry key了，保存着不同的value。

    Android Handler就是这个模式。

  * 假设多个local变量，单线程：

    <img src="https://i-blog.csdnimg.cn/blog_migrate/926da668cd9b6f8fbdc56d5b381f459d.png#pic_center" alt="threadlocalMulti" style="zoom:33%;" />

    如灵魂画手，即，该线程下的map的数组不再是单个Entry元素了。而是多个k v组成。

  * 假设多个local变量，多线程：

    这下好理解了，不用多说。每一个线程都有map，map下的数组就对应有多个Entry（local组成弱引用的key，和value）。

    


* 扩展点2 Android Handler

      就是把Looper对象，申明了一个static的LocalThread<Looper>在我们prepare的时候，进行初始化。这样的情况，就保证了每一个线程，在new出来的时候，都会创建一个独有的Looper。
      
      所以说，ThreadLocal和Thread有什么关系呢？Thread只和ThreadLocalMap有关，而我们申明的变量，ThreadLocal是作为ThreadLocalMap的数组中一个元素的key(weakRef)。

  那为什么在Handler和Looper源码中看不到remove来解决内存泄漏呢？

  这里他使用static来标记threadLocal变量。即保证了所有线程只有一个key。这个key永远不会被回收了。则不会出现key=null，value存在的现象。但是假设HandlerThread被回收，Looper作为value会被先回收。理论上讲，他并没有考虑内存问题。如果线程和Looper搞的多，在前面提到的逻辑中，靠的ThreadLocal内部代码的比如set，或者resize的时候，进行清理（详细可以阅读ThreadLocal.java：set()->cleanSomeSlots，即每次设置值都会尝试清理清理）。

  

## JVM运行时分区

进程共享：方法区(常量池) （类信息，常量，静态变量）,  堆区（类的全局变量跟随类new出来的）；

线程私有： 虚拟机栈（临时变量），本地方法栈，程序计数器。

## classLoader

类加载器，最开始是给Java Applet（一种Html+下载Java代码来执行逻辑的应用程序）。这就要求JVM能够动态加载java代码，因而设计出来。

`java.lang.ClassLoader` 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 `java.lang.Class` 类的一个实例。

https://developer.ibm.com/zh/articles/j-lo-classloader/

https://www.jianshu.com/p/fe2f739928ec

https://segmentfault.com/a/1190000004062880

https://blog.csdn.net/dongbaoming/article/details/54312824?utm_source=blogxgwz5



## java类加载流程

类从被加载到JVM中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。

Loading：查找class到内存

Linking:  验证(字节码是否合规)，准备(静态变量，空间并附默认值)，解析（直接引用常量池）

Initialization: 初始化，真正的值变更。



### 类加载器&双亲委托

* java里面：

customClassLoader->applicationClassloader->extersionClassLoader->bootstrapClassLoader

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // First, check if the class has already been loaded
    // 1.先查找该 Class 是否已经加载过，若加载过，则直接返回。
    Class<?> c = findLoadedClass(name);
    if (c == null) {
        try {
            if (parent != null) {
                // 2.委托给父加载器进行加载。
                c = parent.loadClass(name, false);
            } else {
                // 当执行到顶层的类加载器时，parent = null
                c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // ClassNotFoundException thrown if class not found
            // from the non-null parent class loader
        }

        if (c == null) {
            // 3.如果父加载器也没有找到，则自己尝试加载。该方法的逻辑由具体子加载器实现。
            c = findClass(name);
        }
    }
    return c;
}

// 由子类自己实现
protected Class<?> findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
```

像极了事件分发，onInterept()就是在本类中进行拦截，就直接return掉完成了；

如果本类不做处理，则给到parent去loadClass。如果parent有返回就是返回的。如果parent没有返回的，则最终才轮到自己去创建，就像只有子View不消费，父控件才能触发自己的onTouchEvent。

也相当于二叉树的后序遍历。

```java
public void visit(TreeNode n) {
   //前序点拦截
   visit(n.left);
   visit(n.right);
   print(n.val); //后序点
}
```

前序遍历点做拦截处理；能最快的打破往下传递。

后序遍历点做自己的实现(打印，消费事件），当自己被访问链，即将离开的时候，才处理。



与事件分发的区别在于：

事件分发机制，onInterupt()是极度容易，而这里的拦截是父类的native方法。仅仅起到后续二次加载cache而已。



* 打破双亲委托

  loadClass修改；Thread处理；自定义classLoader。android一般用不上。 

* android里面：

  我们加载的dex文件，因此必须要自己实现classLoader了。

  主要分为：

  BootClassLoader（加载常用类）；

  PathClassLoader（加载系统类和应用程序类，已经安装的程序的dex）；

  DexClassLoader（可以用于外部加载dex，apk）

* 热修复：

  修复的原理就是将补丁 dex 文件放到 dexElements 数组靠前位置，这样在加载 class 时，优先找到补丁包中的 dex 文件，加载到 class 之后就不再寻找，从而原来的 apk 文件中同名的类就不会再使用，从而达到修复的目的。Application初始化就加载好它。



## 静态代理和动态代理

使用上，

1）必须实现InvocationHandler接口；

2）使用Proxy.newProxyInstance产生代理对象；

3）被代理的对象必须要实现接口。

```java
public interface IString {
    int length(String s);
}

System.out.println("s addr: " + System.identityHashCode(s));

IString news = (IString) Proxy.newProxyInstance(IString.class.getClassLoader(), new Class[] { IString.class},
                                                new InvocationHandler() {
                                                  @Override
                                                  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                                    System.out.println("proxy addr: " + System.identityHashCode(proxy));
                                                    int an = (int) method.invoke(s, args); //重点：第一个参数是被代理的对象。
                                                    return an + 1;
                                                  }
                                                });

System.out.println(" news addr: " + System.identityHashCode(news));
var ans = news.length("hello");
System.out.println("ans: " + ans);

//执行结果
s addr: 2055281021
news addr: 834600351
proxy addr: 834600351
ans: 6
```

在invoke里面，

我们可以针对被代理的结果进行修改；或者插入额外执行信息；
甚至可以完全不调用它，换成adapter适配模式一样，替换掉。
还可以使用动态代理做成一种网络运行参数的配置规则。通过注解不同的interface，解析注解来访问网络。

* 原理

1. JDK里面源码，就是在Proxy.newProxyInstance的传入参数，

第二是传入想要代理的接口类，第三是传入InvocationHandler处理函数。

2. 动态生成的代码，类似如下：

```java
public class NewStringImpl extends Proxy implements IString{
    protected InvocationHandler h; //在父类Proxy里面
  
    private static Method m1;
    private static Method m0;
    private static Method m3;
    private static Method m2;
  
  	public String length() {
       h.invoke(this, m, null);
    }
  
    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
  
      static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
            m2 = Class.forName("java.lang.Object").getMethod("toString");
          
            m3 = Class.forName("xxxx.IString").getMethod("length");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```

也就是说，JDK帮我们生成了一个类:

1. 它继承了Proxy；父类Proxy里面含有一个我们构造的时候的第三个参数InvocationHandler h；
2. 实现了我们传入的第二个参数接口；

3. 生成了toString, hashCode, equals三个静态变量method，和目标函数静态变量method；
4. 在我们调用接口的函数的时候，触发的执行其实就是执行了InvocationHandler的回调。而method.invoke(Object obj, Object... args)，第一个参数为对象（即Proxy.newInstanace出来的这个对象）。

因此，需要注意：

不能在invoke函数里面调用System.out.println(proxy)，会导致死循环，因为toString也会invoke给到这个函数。导致不断死循环。

可以看到，m0~m3的class.forname。才会有框架代码判断if (Object.class.equals(method.getDeclaringClass())) 的拦截。





## java基础面试知识点

**java 中 == 和 equals 和 hashCode 的区别**

==：基本类型比值，引用类型比内存地址；

equals：默认同 ==，重写后可比较对象内容（如 String）；

hashCode：返回对象哈希值，重写 equals 必须重写它，保证内容相等对象哈希值一致，用于哈希表快速定位。



**String、StringBuffer、StringBuilder 区别**

String 底层 final 字符数组，不可变，频繁拼接效率低；StringBuffer 和 StringBuilder 可变，前者线程安全（方法同步）、效率稍低，后者线程不安全、效率高；单线程用 StringBuilder，多线程用 StringBuffer。



**int、char、long 各占多少字节数**

int 占 4 字节，char 占 2 字节，long 占 8 字节。



**int 与 integer 的区别**

int 是基本类型，存值、默认 0；Integer 是 int 的包装类，是对象、存地址、默认 null；支持自动装箱 / 拆箱，Integer 有 - 128~127 缓存。



**谈谈对 java 多态的理解**

多态是同一行为的不同表现形式，基于继承 / 接口实现、方法重写、父类引用指向子类对象；分编译时（方法重载，同名函数）和运行时（方法重写，申明变量是父类，创建的对象是子类）多态，提升代码扩展性和解耦性。



**类与接口**

* 什么是内部类？内部类的作用

定义在其他类 / 方法中的类；可访问外部类私有成员、封装隐藏类、弥补 Java 单继承、让代码更模块化。

* 抽象类和接口区别

抽象类单继承，含抽象 / 非抽象方法、任意属性，体现 is-a 继承关系；接口多实现，属性默认公静常，Java8 + 可加默认 / 静态方法，体现 like-a 行为规范。

* 抽象类的意义

抽取子类共性，定义统一父类规范；通过抽象方法强制子类实现特有逻辑，约束子类行为；不能实例化，避免无意义对象，提升代码规范性和可维护性。

* 抽象类与接口的应用场景

抽象类：子类是同一种类、有共性属性 / 方法需复用，如动物类抽取出食性、移动等共性；接口：不同类需统一行为、无共性属性，如跑、飞接口，人 / 鸟 / 车均可实现。

* 抽象类是否可以没有方法和属性？

可以，抽象类的核心是 abstract 关键字，与是否有成员无关；但该用法无实际业务意义，开发中极少使用。

* 接口的意义

定义行为契约，强制实现类遵守；弥补 Java 单继承局限，支持多实现；面向接口编程，解耦模块依赖；实现行为层面复用，提升代码扩展性和可维护性。

* 静态属性 / 方法：是否可继承、可重写 + 原因

可继承：子类能通过类名 / 对象直接使用父类静态成员，静态成员属于类本身，随类的继承被子类拥有；

不可重写：重写依赖**运行时多态**，而静态成员是**编译期静态绑定**（绑定到所属类），子类同名静态方法仅为**隐藏 / 遮蔽**父类方法，非重写。

* 静态内部类的设计意图

1. 封装相关逻辑，避免全局类污染命名空间；

2. 不依赖外部类实例，可独立创建使用，解耦与外部类非静态成员的关联；

3. 内聚外部类相关功能（仅需访问外部类静态成员），提升代码整洁性。

   成员内部类：非静态，依赖外部类实例，可访问外部类**所有成员**；

   静态内部类：静态，独立无外部类实例依赖，仅访问外部类**静态成员**；

   局部内部类：定义在方法 / 代码块中，作用域仅限当前区域，可访问外部隐式 final 变量；

   匿名内部类：无类名，定义即实例化，仅一次性使用，可继承类 / 实现接口。

* 项目应用

  成员内部类：实体类的关联辅助类（如早期 HashMap 的 Entry 类）；

  静态内部类：工具类细分功能（如 ArrayList 的 Itr 迭代器）、独立关联组件；

  局部内部类：方法内专用临时类（如方法内自定义排序的比较器，避免全局暴露）；

  匿名内部类：一次性回调 / 接口实现（线程创建、按钮点击事件、集合临时排序）。

* 父类的静态方法能否被子类重写

不能；静态方法属于类，编译期静态绑定到所属类，子类同名静态方法仅**隐藏**父类方法，不具备运行时多态的重写特征。

**闭包和局部内部类的区别**

- 形式：局部内部类是**具名类**，需实例化调用方法；闭包是**代码块**，可直接执行 / 作为参数传递，轻量无类名；
- 变量访问：局部内部类仅能访问外部**final / 有效 final**变量，不可修改；闭包可直接持有并**修改外部变量引用**（Java8+/Kotlin）；
- 状态持有：局部内部类通过类实例持有外部状态；闭包直接绑定外部变量，更简洁地携带状态执行。

> 若闭包**未访问外部类成员 / 变量**：编译为**静态内部类**（单例实现，避免外部类实例依赖，优化性能）；
>
> 若闭包**访问了外部类的非静态成员 / 变量**：编译为**普通局部 / 匿名内部类**，通过内部类实例持有外部类引用，实现对外部变量的访问；



**泛型中 extends 和 super 的区别**

? extends T（上界通配符）：限定泛型为「T 或 T 的子类」

**核心边界**：泛型类型 ≤ T（子类 / 自身）

**编译器推导逻辑**：仅确定泛型是 T 的派生类，但**无法确定具体是 T 的哪一个子类**

- **取数据**：无限制（自由取）→ 所有元素必然是 T 的子类，可安全向上转型为 T，这也是 “适用于消费数据” 的原因；
- **存数据**：仅能存 null（唯一安全）→ 因无法确定具体子类，存任何具体 T 的子类对象，都可能造成集合类型混乱（如？extends Number 存 Integer，实际集合可能是 Double 类型），编译器直接禁止以避免类型安全问题。

? super T（下界通配符）：限定泛型为「T 或 T 的父类」

**核心边界**：泛型类型 ≥ T（父类 / 自身）

**编译器推导逻辑**：仅确定泛型是 T 的基类，但**无法确定具体是 T 的哪一个父类**（最顶层为 Object）

- **存数据**：无限制（自由存）→ T 的对象可向上转型为任意父类，因此存**T 或 T 的子类对象**绝对安全，这也是 “适用于生产数据” 的原因；
- **取数据**：仅能取到 Object 类型→ 因无法确定具体是 T 的哪个父类，编译器只能保证取到的是所有类的父类 Object，无法精准转型为 T 或其直接父类。



**final，finally，finalize 的区别**

- **final**：关键字，修饰类（不可继承）、方法（不可重写）、变量（引用 / 值不可修改）；

- **finally**：异常处理关键字，try-catch-finally 中**必执行块**（JVM 强制退出除外），用于释放资源；

- **finalize**：Object 类的方法，GC 回收对象前调用，**Java9 已废弃**，仅早期用于资源清理。

  

**string 转换成 integer 的方式及原理**

1. `Integer.parseInt(String s)`：转**int 基本类型**，底层解析字符串字符为数字，做进制转换，返回纯数值；
2. `Integer.valueOf(String s)`：转**Integer 对象**，底层调用`parseInt`获 int 值，再通过`IntegerCache`缓存（-128~127 复用对象，超出新建）返回；

字符串非纯数字时，均抛出`NumberFormatException`；`new Integer(String s)`已废弃，开发不用。



**进程和线程的区别**

进程是 OS**资源分配最小单位**，有独立内存 / 资源，开销大，进程间相互独立；

线程是 CPU**调度执行最小单位**，隶属于进程，共享进程资源，开销小；

一个进程可包含多个线程，线程是进程的执行单元。



**序列化的方式**

实现**Serializable**接口（标记型，默认序列化，JVM 自动处理）和android的parceable。

**Serializable 和 Parcelable 的区别**

- 适用平台：Serializable 是 Java 跨平台接口；Parcelable 是**Android 专属**接口；
- 效率：Serializable 依赖反射 / IO，效率低；Parcelable 手动实现，无额外开销，效率高；
- 场景：Serializable 用于**网络传输、文件持久化**；Parcelable 用于 Android**组件间传对象**（Intent/Bundle）。



**谈谈对 kotlin 的理解**

Kotlin 是基于 JVM 的编程语言，Android 官方首选开发语言，**完全兼容 Java**；核心特性：

空安全（从语法避免空指针）、

协程（轻量实现并发）、

扩展函数、数据类、委托等；

语法简洁，代码更安全易维护，与 Java 无缝互操作，并非替代而是互补 Java。



**垃圾回收触发条件**
对象不可达（无引用）、引用置为null、引用超出作用域。JVM自动管理，`System.gc()`仅为建议，不保证立即回收。



**常见编码方式**
Base64（64字符集，末尾=，用于二进制转文本）、

URL编码（%+十六进制，如%20）

Unicode（UTF-8等，\u开头）。特征：Base64含+/=；URL编码含%；Base16仅0-9A-F。

**UTF-8中文字节 & int字节**
UTF-8中文通常3字节（生僻字4字节）；Java中`int`固定4字节（与平台无关）。



**静态代理 vs 动态代理**
静态代理：编译期写死，需为每个类写代理，适用于简单固定场景。
动态代理：运行时生成（JDK基于接口，CGLIB基于继承），适用于AOP、事务等需统一处理多类的场景。



**Java异常体系**
`Throwable`为根：

- `Error`：JVM严重错误（如OOM），不处理。
- Exception
  - 受检异常（Checked）：编译检查（如`IOException`），需`throws`或`try-catch`。
  - 非受检异常（Unchecked）：运行时异常（如`NullPointerException`），无需强制处理。



**解析与分派**

- **解析**：编译期将符号引用转为直接引用（静态）。

- 分派

  - 静态分派：重载，依据参数静态类型（编译期）。
  - 动态分派：重写+多态，依据对象实际类型（运行期，JVM通过vtable实现）。

  

**Java反射理解**
运行时动态获取类结构（字段/方法/构造器），通过`Class`、`Method`等操作对象。用途：框架（Spring）、动态代理。注意：性能开销大、破坏封装性、需处理安全限制。



**Java注解理解**
元数据（`@Override`/`@Deprecated`），用于编译检查、文档生成、框架配置（如Spring）。自定义注解需`@Retention(RUNTIME)` + 反射读取。核心：不改变代码逻辑，提供附加信息。



**依赖注入理解**
IoC实现方式：由容器（如Spring）在运行时将依赖（接口实现）注入对象（构造器/setter）。优势：解耦、便于测试（Mock）、提升可维护性。典型场景：Service注入DAO。



**泛型原理**

**类型擦除**：编译后泛型信息擦除，替换为边界类型（如`Object`），插入强制转换。
例：`List<String>` → 编译为`List`，`get()`返回自动转`String`。

作用：编译期类型安全，运行时无泛型。



**Java String认知**
`final`类，内部`private final char[]/byte[]`，不可变。

支持常量池优化（`"abc"`复用），所有操作（`substring`等）返回新对象。

线程安全，适合作为HashMap的key。



**String不可变原因**

- 安全：常量池共享防篡改、类加载器安全。
- 集合：HashMap的key需hashCode稳定（缓存hash值）。
- 线程安全：无需同步。
- 设计保障：`final`类 + 私有final字段 + 无修改API。





浅拷贝：对象无引用类型成员、或无需独立修改引用成员（追求效率）；

深拷贝：对象包含多层引用类型、或需要完全独立的对象实例（如业务对象拷贝、数据快照）。



## 数据结构

**重写equals与hashCode原因**
保证集合（HashMap/HashSet）正确性：

- **约定**：`equals`相等 → `hashCode`必须相等。
- **后果**：若只重写`equals`，对象存入HashMap后可能因hashCode不同无法查找；反之亦然。需同时重写并保持逻辑一致。

 

**1. HashMap 实现原理**

> 不同的 Key 通过哈希计算得到**相同的哈希值**，映射到 HashMap 数组的**同一个桶位**，这种情况就是哈希冲突（哈希碰撞）。
>
> HashMap 解决哈希冲突的核心位置是**数组的单个桶位**：
>
> 该桶位会承载所有哈希冲突的节点，通过**链表（JDK8 前）/ 链表 + 红黑树（JDK8+）** 结构组织这些冲突节点，让每个桶位成为冲突节点的 “集合容器”，从而解决多节点映射同一桶位的问题（JDK8 + 当链表长度≥8 且数组容量≥64 时，桶内链表转红黑树，优化冲突后的查询效率）。

基于哈希表（数组 + 链表 / 红黑树）实现，通过 key 的哈希值散列到数组桶位，链表解决哈希冲突，JDK8 + 当链表长度≥8 且数组容量≥64 时转红黑树优化查询；非线程安全，允许 null 键值，负载因子 0.75 平衡空间与效率。



**2. HashMap 数据结构**

JDK8 及以后：数组 + 单向链表 + 红黑树，数组是主体，红黑树解决链表过长导致的查询低效问题。



**3. HashMap 源码理解**

核心成员：table（存储节点的数组）、loadFactor（负载因子 0.75）、threshold（扩容阈值 = 容量 * 负载因子）；

核心方法：hash ()（key 的 hashCode 高 16 位异或低 16 位，减少碰撞）、putVal ()（核心存储逻辑）、resize ()（扩容并重新哈希节点）；桶位计算：`(数组长度-1) & hash`（替代取模，效率更高）。



**HashMap put 数据（源码角度）**

计算 key 的 hash 值（null 键 hash 为 0）；2. 若 table 未初始化 / 长度为 0，调用 resize () 初始化；3. 计算桶位，桶位为空则直接新建节点放入；4. 桶位有元素：首节点 key 相同则替换 value；首节点是红黑树则树插入；否则链表尾插，插入后若链表≥8 且数组≥64 则转红黑树，遍历中遇相同 key 则替换；5. size+1 后，若超过 threshold 则 resize ()；6. 返回旧 value（无则 null）。



**ConcurrentHashMap 实现原理**

JDK8 前：分段锁（Segment 数组 + HashEntry），锁粒度为 Segment，并发度 = Segment 数；

JDK8  采用**数组 + 链表 + 红黑树**，结合**CAS+Synchronized**（仅锁桶位首节点），锁粒度更小，并发效率更高；不允许 null 键值，天然线程安全，扩容时分段进行。

|              特性              |        CAS         |    Synchronized    |     ReentrantLock      |
| :----------------------------: | :----------------: | :----------------: | :--------------------: |
|             锁类型             |      无锁机制      |     内置隐式锁     |   显式锁（AQS 实现）   |
|           加解锁方式           | 自旋重试，无加解锁 |    JVM 自动处理    | 手动 lock ()/unlock () |
|            核心优势            | 轻量，无锁竞争开销 | 简单易用，自动管理 | 功能灵活，支持高级特性 |
|            适用场景            |  单个变量原子操作  |    通用简单同步    |     复杂定制化同步     |
| 可重入性(允许嵌套代码继续执行) |     无（非锁）     |        支持        |          支持          |

**ArrayMap 和 HashMap 的对比**

存储结构：

ArrayMap 用两个数组（int [] 存哈希值、Object [] 存键值对），无链表 / 红黑树；

HashMap 是数组 + 链表 + 红黑树；

内存：

ArrayMap 无节点对象，内存占用极低，适合小数据量；

HashMap 节点占内存，大数据量更优；

效率：

ArrayMap 查找用二分法，增删需移动数组，小数据快、大数据慢；

HashMap 哈希直接查找，大数据查询 / 增删高效；

场景：

ArrayMap 是 Android 专属；

HashMap 是 Java 通用，全场景适配；

扩容：

ArrayMap 无负载因子，满了直接扩容

HashMap 负载因子 0.75，提前扩容减少碰撞。



**HashTable 实现原理**

基于**数组 + 单向链表**的哈希表实现，无红黑树优化；

全程通过**方法级 Synchronized**加锁，锁整个哈希表；

不允许 null 键值，初始容量 11，负载因子 0.75，扩容为 2n+1，桶位计算直接用 hashCode% 容量；

线程安全但并发效率极低，已被 ConcurrentHashMap 替代。



**HashMap 和 HashTable 的区别**

1. 线程安全：HashMap 非线程安全；HashTable 线程安全（方法 Synchronized）；
2. null 支持：HashMap 允许 1 个 null 键、多个 null 值；HashTable 完全不允许；
3. 容量 / 扩容：HashMap 初始 16，扩容 2n；HashTable 初始 11，扩容 2n+1；
4. 哈希计算：HashMap 有 hash 扰动，(n-1)&hash；HashTable 直接 hashCode% 容量；
5. 效率：HashMap 远高于 HashTable（HashTable 锁整个表，并发冲突严重）；
6. 继承：HashMap 继承 AbstractMap；HashTable 继承古老的 Dictionary 类。



**HashMap 与 HashSet 的区别**

接口实现：

HashMap 实现 Map，存**键值对**；

HashSet 实现 Set，存**单元素**；

底层依赖：

HashSet 基于 HashMap 实现，元素存于 HashMap 的 key，value 是固定常量 PRESENT；

唯一性：HashMap 仅 key 唯一，value 可重复；HashSet 所有元素唯一；

用途：

HashMap 用于键值映射；HashSet 用于去重集合。



**HashSet 与 HashMap 判断元素重复**

**核心逻辑完全一致**：先通过 key 的`hashCode()`计算哈希值，若哈希值不同，直接判定为不同元素；若哈希值相同，再调用 key 的`equals()`方法，**两者均相同**则判定为重复；HashMap 会替换旧 value，HashSet 直接拒绝添加。



**集合 Set 实现 Hash 怎么防止碰撞**

1. 强制要求元素（HashMap 的 key）重写`hashCode()`，保证哈希值均匀分布，减少同哈希值情况；

2. 重写`equals()`，哈希值相同时精准判断是否为同一元素；

3. 底层依赖 HashMap 的**哈希扰动**和`(n-1)&hash`桶位计算，降低碰撞概率；

4. JDK8 + 链表转红黑树，即使发生碰撞，也能保证查询效率 O (logn)；

5. 合理设置初始容量和负载因子，减少扩容前的桶位拥挤。

   

**ArrayList 和 LinkedList 的区别及应用场景**

核心区别

底层结构：

ArrayList 是**动态数组**（基于 Object []）

LinkedList 是**双向链表**（节点存数据 + 前驱 / 后继指针）；

随机访问：

ArrayList 支持（get (i) O (1)），查询极快；

LinkedList 不支持（遍历 O (n)），查询慢；

增删操作：

ArrayList 尾部增删 O (1)，中间 / 头部需移动元素 O (n)；

LinkedList 增删仅修改指针 O (1)（需先找节点 O (n)，批量操作更优）

内存占用：

ArrayList 连续内存，有扩容冗余（默认 1.5 倍扩容）；LinkedList 节点额外存指针，内存开销大；

方法支持：LinkedList 实现 Deque，支持队列 / 栈操作（offer、pop 等）；ArrayList 无相关方法。

应用场景：

ArrayList：适合**大量查询、少量尾部增删**的场景（如数据展示、数据库查询结果缓存、排行榜）；

LinkedList：适合**大量中间 / 头部增删、队列 / 栈实现**的场景（如任务队列、消息队列、链表结构模拟）。



**数组和链表的区别**

| 维度 |                  数组                   |            链表            |
| :--: | :-------------------------------------: | :------------------------: |
| 存储 |              连续内存空间               |     离散节点，指针连接     |
| 访问 |             随机访问 O (1)              |       顺序访问 O (n)       |
| 增删 | 中间 / 头部 O (n)（移元素），尾部 O (1) | 找到节点后 O (1)（改指针） |
| 内存 |     固定容量 / 扩容冗余，无额外开销     |   节点存指针，内存开销大   |
| 适用 |         大量查询、少量尾部增删          |  大量增删、无随机访问需求  |



**二叉树 DFS（深度优先）& BFS（广度优先）实现**

```java
class TreeNode { int val; TreeNode left, right; TreeNode(int x) { val = x; }
//DFS//（前 / 中 / 后序，核心：递归 / 栈实现，优先走子节点）
void dfsPre(TreeNode root) {
    if (root == null) return;
    System.out.print(root.val + " "); // 前序
    dfsPre(root.left);
    dfsPre(root.right);
}

//BFS （层序，核心：队列实现，按层遍历，优先走同层节点）
void bfs(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);
    while (!q.isEmpty()) {
        TreeNode node = q.poll();
        System.out.print(node.val + " ");
        if (node.left != null) q.offer(node.left);
        if (node.right != null) q.offer(node.right);
    }
}
```

**堆的结构**

1. 底层是**完全二叉树**（仅最后一层右侧缺节点），可用**数组**高效存储；
2. 分**大顶堆**（父节点值 ≥ 所有子节点）、**小顶堆**（父节点值 ≤ 所有子节点）；
3. 数组索引关系（根从 0 开始）：父节点`i` → 左子`2i+1`、右子`2i+2`；子节点`i` → 父`(i-1)/2`；
4. 核心操作：堆化（调整节点位置维持堆性质）、插入 / 删除顶节点，时间复杂度均 O (logn)。

**堆和树的区别**

1. 堆是**特殊的完全二叉树**，有严格的父子值约束（大 / 小顶堆），普通树无此约束；
2. 堆通常用**数组**存储，普通树多为**链式存储**；
3. 堆核心作用是**快速获取极值**（顶节点），树侧重**数据遍历、查找、有序存储**；
4. 普通树的子节点无顺序要求，堆的子节点隐含大小顺序。



**堆和栈的内存区别（数据结构 + 实际实现）**

数据结构层面

- 堆：完全二叉树，支持快速取极值，插入 / 删除 O (logn)；
- 栈：线性结构，先进后出（FILO），入栈 / 出栈 O (1)。

实际实现层面（Java/JVM）

- 栈（虚拟机栈）：**线程私有**，随方法执行创建 / 销毁，帧栈结构，存局部变量、方法调用信息；自动回收，无 GC，易出现`StackOverflowError`（栈溢出）；
- 堆（堆内存）：**所有线程共享**，存对象、数组、常量池；手动 / 自动 GC 回收，分新生代 / 老年代，易出现`OutOfMemoryError`（堆溢出）。



**树、B + 树的理解**

- **树**：非线性分层数据结构，由根、节点、边组成，解决线性结构查询低效问题；核心是**分层遍历、递归结构**，常见类型：二叉树、二叉搜索树、红黑树（自平衡），适用于内存内数据的有序存储 / 查询。

- B + 树

  平衡多路搜索树

  （B 树的优化版），数据库 / 文件系统核心索引结构，适配磁盘 IO：

  1. 非叶子节点仅存**索引键**，不存数据，可存储更多索引，减少 IO 次数；
  2. 所有**数据均存在叶子节点**，且叶子节点通过**链表链式相连**，支持高效范围查询；
  3. 树高度低（多路），磁盘寻道次数少，适合海量外存数据查询。

  

**对图的理解**

1. 非线性结构，由 ** 顶点集 (V)**和**边集 (E)** 组成，是树的泛化（树是无环连通图）；
2. 分类：无向图 / 有向图、加权图（边带值）/ 无权图、连通图 / 非连通图、有环图 / 无环图；
3. 存储方式：**邻接矩阵**（二维数组，适合稠密图，查询 O (1)）、**邻接表**（数组 + 链表，适合稀疏图，节省内存）；
4. 核心遍历：DFS（栈 / 递归）、BFS（队列）；
5. 经典算法：最短路径（Dijkstra/Floyd）、最小生成树（Prim/Kruskal）、拓扑排序；
6. 应用：路网规划、社交关系、依赖分析、电路设计。



**链表逆序（翻转单向链表，简单代码）**

```java
class ListNode { int val; ListNode next; ListNode(int x) { val = x; } }
ListNode reverseList(ListNode head) {
    ListNode pre = null, cur = head;
    while (cur != null) {
        ListNode temp = cur.next; // 保存后继
        cur.next = pre; // 翻转指针
        pre = cur; // 前驱后移
        cur = temp; // 当前后移
    }
    return pre; // 新头节点
}
```



**判断单链表成环与否（简单代码）**

**快慢指针法（面试首选，空间 O (1)）**：快指针走 2 步，慢指针走 1 步，相遇则成环，否则无环。

```java
boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) return false;
    ListNode slow = head, fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) return true; // 相遇成环
    }
    return false;
}
```



**合并多个递增单有序链表（简单代码）**

**分治思想（面试常用，效率高）**：两两合并，最终合并为一个有序链表。

```java
// 合并两个递增链表（基础方法）
ListNode mergeTwo(ListNode a, ListNode b) {
    ListNode dummy = new ListNode(0), cur = dummy;
    while (a != null && b != null) {
        if (a.val < b.val) { cur.next = a; a = a.next; }
        else { cur.next = b; b = b.next; }
        cur = cur.next;
    }
    cur.next = a == null ? b : a;
    return dummy.next;
}
// 分治合并多个链表
ListNode mergeKLists(ListNode[] lists) {
    if (lists == null || lists.length == 0) return null;
    return merge(lists, 0, lists.length - 1);
}
ListNode merge(ListNode[] lists, int l, int r) {
    if (l == r) return lists[l];
    int mid = (l + r) / 2;
    ListNode left = merge(lists, l, mid);
    ListNode right = merge(lists, mid + 1, r);
    return mergeTwo(left, right);
}
```



## 线程、多线程和线程池

**1. 开启线程的三种方式**

1. 继承`Thread`类，重写`run()`，调用`start()`；

2. 实现`Runnable`接口，重写`run()`，传入`Thread`启动；

3. 实现`Callable`接口（带返回值 / 异常），配合`FutureTask+Thread`获取结果。

   

**线程和进程的区别**

- 进程：**资源分配基本单位**，独立内存 / 资源，创建 / 切换开销大，进程间隔离；
- 线程：**CPU 调度基本单位**，隶属于进程，共享进程资源，轻量，开销极小；
- 一个进程可包含多个线程，线程是进程的执行单元。



**为什么要有线程，而非仅用进程**

进程创建 / 销毁 / 上下文切换**开销极大**，线程轻量、开销低，提升 CPU 并发利用率；

线程共享进程资源，减少进程间通信的复杂度和开销；适合细粒度的并发任务拆分。



**run () 和 start () 方法区别**

- `start()`：**启动新线程**，让线程进入就绪态，JVM 底层调用`run()`，仅能调用一次；

- `run()`：普通方法，直接调用不会启动新线程，由当前线程（如主线程）执行，可多次调用。

  

**控制方法并发访问线程个数**

使用**Semaphore（信号量）**，初始化指定许可数（最大并发数），方法内`acquire()`获取许可，`finally`中`release()`释放许可，超出许可的线程阻塞。



**Java 中 wait 和 sleep 方法的不同**

1. 所属类：`wait()`是`Object`方法，`sleep()`是`Thread`静态方法；

2. 锁释放：`wait()`释放持有的锁，`sleep()`不释放；

3. 使用场景：`wait()`必须在`synchronized`块内，`sleep()`可在任意位置；

4. 唤醒：`wait()`需`notify/notifyAll`唤醒，`sleep()`超时 / 中断自动唤醒；

5. 用途：`wait()`用于线程间通信，`sleep()`用于线程延时。

   

**对 wait/notify 关键字的理解**

均为`Object`的方法，**必须在 synchronized 同步块 / 方法内使用**；

`wait()`：线程释放锁，进入**等待池**，等待被唤醒；

`notify()`：唤醒等待池中**一个**线程，进入锁池竞争锁；

`notifyAll()`：唤醒等待池中**所有**线程；二者配合实现**线程间的通信与同步**。



**什么导致线程阻塞？**

1. 竞争锁失败（`synchronized`/`Lock`）；

2. 调用`wait()`/`join()`/`park()`；

3. 执行 IO 操作（文件 / 网络读写）；

4. 调用`sleep()`；

5. 线程池队列满，新任务阻塞。

   

**线程如何关闭？**

**禁止使用`stop()`/`suspend()`**（强制终止，易导致数据不一致 / 锁泄漏）；

安全方式：1. 自定义**布尔标志位**，线程循环判断标志位退出；

2. 调用`interrupt()`，线程内通过`isInterrupted()`检测中断信号退出；

3. 线程池任务用`Future.cancel(true)`取消。

   

**Java 中的同步方法**

1. `synchronized`修饰**实例方法**：锁当前对象实例，保证同一实例的该方法互斥访问；
2. `synchronized`修饰**静态方法**：锁类的`Class`对象，保证所有实例的该方法互斥访问。

- **单机并发**：加锁（`synchronized`/`Lock`）、`volatile`、原子类（Atomic）、CAS；
- **分布式**：分布式锁（Redis/ZooKeeper）、分布式事务（Seata/XA）、消息队列（削峰 / 有序）、数据库行锁 / 乐观锁。



**如何保证线程安全？**

核心保证**原子性、可见性、有序性**三大特性，常用手段：

1. 互斥锁（`synchronized`/`ReentrantLock`）；

2. 轻量同步（`volatile`）；

3. 原子操作（Atomic 类 / CAS）；

4. 使用线程安全容器（`ConcurrentHashMap`/`CopyOnWriteArrayList`）；

5. 避免共享可变资源（线程封闭）。

   

**两个进程同时写 / 读的实现与进程同步防止**

- 读操作：**可同时实现**（读共享，无数据竞争）；
- 写操作 / 写读混合：**不可同时**，需互斥，否则数据脏读 / 覆盖；
- 进程同步（互斥）手段：文件锁、系统信号量、共享内存 + 互斥锁、管道 / 消息队列。



**线程间操作 List**

`ArrayList`/`LinkedList`非线程安全，

解决方案：1. `Collections.synchronizedList()`：包装为同步 List（方法级锁，简单）；

2. `CopyOnWriteArrayList`：读多写少场景（写时复制，读无锁，高效）；

3. 手动加锁（`synchronized`/`Lock`）保护 List 操作。

   

**Java 中对象的生命周期**

7 个核心阶段：**创建**（new / 反射）→**加载 / 初始化**（类加载机制）→**就绪**（分配内存、初始化成员）→**运行**（对象可达，被引用）→**阻塞**（暂时无引用 / 等待资源）→**垃圾回收**（对象不可达，进入 GC 队列）→**销毁**（GC 释放内存，对象消亡）。



**synchronized 的原理**

JDK6 后优化为**分级锁**（偏向锁→轻量级自旋锁→重量级锁），根据竞争程度自动升级；基于**对象头 Mark Word**存储锁状态，重量级锁依赖 **Monitor（监视器）** 实现；同步代码块通过`monitorenter/monitorexit`指令加解锁，同步方法通过方法区`ACC_SYNCHRONIZED`标志位实现。



**对 Synchronized 类锁、方法锁、重入锁的理解**

- 方法锁：分**实例方法锁**（对象锁，锁当前实例）和**静态方法锁**（类锁，锁 Class 对象）；

- 类锁：锁的是类的 Class 对象，所有实例共享，保证静态资源的线程安全；

- 重入锁：`synchronized`是天然的可重入锁，底层维护**线程标识**和**重入次数**，同一线程持有锁后可重复获取，避免自死锁。

  

**volatile 的原理**

通过**内存屏障**禁止指令重排，通过**强制主存交互**保证可见性；修改 volatile 变量时，立即刷回主存，其他线程读取时直接从主存加载，不使用工作内存缓存；**不保证原子性**。

仅能修饰**共享成员变量 / 静态变量**，不能修饰方法 / 局部变量；核心场景：1. 修饰**状态标志位**（如线程停止标志）；2. 配合 CAS 实现非阻塞同步；3. 解决**双重检查锁（DCL）单例**的可见性和有序性问题。

锁机制：`synchronized`是独占锁，`volatile`无锁；2. 保证特性：`synchronized`保证原子性、可见性、有序性，`volatile`仅保证可见性、有序性；3. 修饰范围：`synchronized`修饰方法 / 代码块，`volatile`修饰变量；4. 开销：`synchronized`有上下文切换开销，`volatile`轻量无开销；5. 原子性：`synchronized`保证，`volatile`不保证。



**对 NIO 的理解**

Java**非阻塞 IO**（New IO/Non-Blocking IO），适配高并发网络编程；核心组件：`Channel`（双向通道，替代流）、`Buffer`（数据载体，所有 IO 操作基于缓冲区）、`Selector`（选择器，多路复用，单线程管理多个 Channel）；基于**事件驱动**，非阻塞模式，减少线程开销，是 Netty 的底层基础。



**synchronized 与 Lock 的区别**

1. 实现层面：`synchronized`是 JVM 内置关键字，`Lock`是 JUC 包的显式接口；

2. 加解锁：`synchronized`自动加解锁，`Lock`需手动`lock()`/`unlock()`（建议 finally 释放）；

3. 公平性：`synchronized`默认非公平，`Lock`（如 ReentrantLock）可指定公平 / 非公平；

4. 功能：`Lock`支持可中断、限时获取锁、多条件变量，`synchronized`无；

5. 锁粒度：`Lock`更灵活，可实现细粒度锁。

   

**ReentrantLock 、synchronized 和 volatile 比较**

- `volatile`：无锁，轻量，保证可见性 / 有序性，修饰变量，适用于简单状态标记；

- `synchronized`：内置可重入锁，自动加解锁，保证三特性，中等开销，适用于通用同步场景；

- `ReentrantLock`：显式可重入锁（AQS 实现），手动加解锁，支持公平 / 可中断 / 条件变量，灵活，中等开销，适用于复杂同步场景。(tryLock，lock时长...)

  

**死锁的四个必要条件**

必须**同时满足**才会产生死锁：1. **互斥条件**：资源只能被一个线程独占；2. **请求与保持条件**：线程持有一个资源，又请求其他被占用的资源；3. **不剥夺条件**：资源不能被强行剥夺，只能由线程主动释放；4. **循环等待条件**：线程间形成资源的循环依赖链。

破坏**任一**死锁必要条件即可，常用手段：1. 按**固定顺序**获取锁（破坏循环等待）；2. 超时获取锁（`tryLock(long,TimeUnit)`，破坏请求与保持）；3. 一次性获取所有所需资源（破坏请求与保持）；4. 主动释放持有的资源（破坏不剥夺）。



**对象锁和类锁是否会互相影响？**

**不会互相影响**；对象锁是**实例对象**的锁（存储在对象头 Mark Word），类锁是**类的 Class 对象**的锁（Class 对象是单例），二者是**不同的锁对象**，线程持有一个锁，不影响获取另一个。



**什么是线程池，如何使用？**

- 定义：管理线程的容器，**复用线程**，减少线程创建 / 销毁的开销，控制最大并发数，避免资源耗尽；

- 使用：

- 简易方式：`Executors`工具类创建（如`newFixedThreadPool`/`newCachedThreadPool`）；

- 推荐方式：手动创建`ThreadPoolExecutor`（指定核心线程数、最大线程数、空闲时间、任务队列、拒绝策略），避免默认工具类的资源泄漏问题。

  

**Java 的并发、多线程、线程模型**

- 并发：同一时间段内多个任务**交替执行**，提升 CPU 利用率；
- 多线程：进程内的轻量执行单元，是实现并发的核心手段，共享进程资源；
- 线程模型：1. 1:1（内核级线程，Java 默认，一个用户线程对应一个内核线程）；2. M:1（用户级线程，多个用户线程对应一个内核线程）；3. M:N（混合级线程，多对多映射）。



**谈谈对多线程的理解**

多线程是进程内**并行执行的轻量执行单元**，共享进程的内存 / 文件等资源；本质是 CPU**时间片轮转调度**，看似同时执行，实际交替运行；核心价值是提升 CPU 利用率和程序并发效率，适用于 IO 密集型 / CPU 密集型任务拆分；需解决线程安全、死锁、可见性等问题。

1. 线程安全（数据竞争、脏读 / 覆盖）；2. 死锁 / 活锁；3. 上下文切换的性能开销；4. 内存可见性和指令重排；5. 锁泄漏（未释放锁）；6. 线程池拒绝策略和队列溢出；7. 共享资源的合理管控。



**多线程断点续传原理**

将待传输文件**分割为多个固定大小的块**，多线程并行下载 / 上传不同块；实时**记录每个块的已完成进度**（存本地文件 / 数据库）；当传输中断后，重新启动时读取进度记录，仅继续传输**未完成的块**，无需重新传输整个文件，提升传输效率。



**断点续传的实现**

核心步骤：1. 计算文件总大小，按固定大小分割为 N 个块；2. 初始化线程池，为每个线程分配待传输的块；3. 传输过程中实时记录每个块的进度（如已完成字节数，存本地 txt/json）；4. 中断后，读取进度文件，过滤已完成块，重新分配未完成块；5. 所有块传输完成后，合并所有块为完整文件。
