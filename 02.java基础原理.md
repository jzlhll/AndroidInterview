## HashMap

1. **底层结构（JDK1.8+）**：

   数组（桶）为主体，每个桶下挂链表；当单个桶的链表长度≥8 且数组长度≥64 时，链表转为红黑树（树化）；树节点数≤6 时，红黑树转回链表（退化）。

   桶位计算：`hash(key) & (数组长度-1)`（数组长度为 2^n，等价取模且效率更高）。

2. **put 操作核心**：

   - 计算 hash 确定桶位，桶空则直接插入新节点；
   - 桶非空：key 相等则替换值；是红黑树则调用`putTreeVal`插入，插入后若违反红黑树特性（颜色、左右子树高度差），触发左旋 / 右旋 + 颜色调整维持平衡；是链表则尾插，插完检查是否满足树化条件；
   - 最后检查元素数≥阈值（容量 × 加载因子，默认 0.75），触发扩容。

3. **扩容机制**：

   - 触发条件：元素数≥阈值，或链表长度≥8 但数组长度 < 64（优先扩容而非树化）；
   - 规则：容量翻倍（保持 2^n），重新计算节点桶位（仅两种可能：原位置 / 原位置 + 旧容量）；
   - 红黑树扩容：拆分树节点到新桶，若拆分后节点数≤6 则退化回链表。

4. **查询效率：**

   - 设计逻辑：HashMap 在 put 阶段通过链表转红黑树、红黑树旋转调整等操作，提前构建了高效的查询结构，避免查询时的低效遍历；
   - 自身效率：理想情况（哈希分布均匀）查询 O (1)；链表最坏 O (n)；红黑树 O (logn)；
   - 对比 List / 数组：
     - 数组：按索引查 O (1)，但按 “值” 遍历匹配查 O (n)；
     - List（如 ArrayList）：底层是数组，查询逻辑同数组；LinkedList 按值查 O (n)；

5. **线程安全版 HashMap**：

   - 加锁 HashMap（Hashtable）：全局锁（synchronized 修饰所有方法），并发下所有操作竞争同一把锁，效率极低，已被淘汰；
   - ConcurrentHashMap（JDK1.8+）：
     - 摒弃 JDK1.7 的分段锁，改用**CAS+synchronized** 实现线程安全；
     - 仅锁定当前操作的桶（或红黑树节点），锁粒度极细，多个桶可并发操作；
     - 扩容时采用 “多线程分段扩容”，避免单线程扩容耗时，兼顾线程安全和并发效率。

## 创建对象的原理

堆上分配内存；

栈上分配临时变量指向地址；

1. 类加载检查（类加载，链接，初始化）

2. 分配内存(如果不够，还需要STW来整理内存)
3. 初始化初值



## Java线程同步

###  一、核心特性

1. **内存可见性**：线程修改共享变量后，其他线程能立即看到最新值（避免 CPU 缓存未同步到主内存的问题）。
2. **原子性**：操作不可分割（如赋值`a=1`），多线程下不会被打断；复合操作（如`i++`）不具备原子性。
3. **有序性**：单线程下 JVM 保证执行结果与代码顺序一致（as-if-serial），多线程需通过机制禁止指令重排。

### 二、核心关键字对比

|    关键字    | 可见性 |       原子性        | 有序性 |                           实现方式                           |
| :----------: | :----: | :-----------------: | :----: | :----------------------------------------------------------: |
|   volatile   |   ✅    | ❌（仅单个读写有效） |   ✅    | CPU 的 lock 指令（同步缓存到主内存 + 失效其他缓存）+ 内存屏障（禁止重排） |
| synchronized |   ✅    | ✅（临界区独占执行） |   ✅    |                     临界区机制（排他锁）                     |

### 三、关键问题解答

1. 单例模式为何需要双检测（DCL）？

- 外层`null`判断：减少`synchronized`锁开销（避免每次都进入临界区）。
- 内层`synchronized`：保证单例对象创建的原子性（防止多线程同时创建）。
- volatile 修饰单例变量：禁止对象创建时的指令重排（避免线程拿到 “未初始化完成” 的对象）。

2. volatile 为何不能保证原子性？

- 原子性仅支持**单个变量的读 / 写操作**（如`flag=true`）。
- 复合操作（`i++`）拆分为 “读 - 改 - 写” 三步，多线程下会被打断，volatile 无法干预。



## 锁的种类，特性

### Java 常用锁

#### 1. 内置锁（synchronized）- 自动释放

- 核心优化（JDK1.5+）：锁升级（无锁→偏向锁→轻量级锁→重量级锁），按需减少内核态切换：
  - 偏向锁：单线程重复获取，消除 CAS 开销；
  - 轻量级锁：多线程竞争无阻塞，CAS 自旋尝试获取；
  - 重量级锁：自旋失败，依赖 OS 互斥量，线程阻塞。
- 特性：可重入、默认非公平、不可中断。

#### 2. 显式锁（java.util.concurrent.locks）

- ReentrantLock（可重入锁）：
  - 显式加锁 / 释放（lock ()/unlock ()，需 finally 保证释放）；
  - 特性：可指定公平 / 非公平、可中断、可尝试获取锁（tryLock ()）。
- ReentrantReadWriteLock（读写锁）：
  - 读共享、写排他，适配 “读多写少”；不支持读锁升级，支持写锁降级。
- StampedLock（JDK1.8+）：
  - 替代读写锁，支持乐观读（无锁读，仅验证版本戳），性能更高。

#### 3. 高频同步工具

- CountDownLatch：倒计时，一次性等待多线程完成；
- CyclicBarrier：循环屏障，等待所有线程到达后继续。

### C++ 常用锁

#### 1. 基础互斥锁

- std::mutex：排他锁，不可重入（重复 lock () 死锁），需手动释放；
- std::recursive_mutex：可重入互斥锁，允许同一线程多次 lock ()。

#### 2. 读写锁（C++17+）

- std::shared_mutex：读共享（std::shared_lock）、写排他（std::unique_lock），适配 “读多写少”。

#### 3. 自旋锁与 RAII 封装

- std::atomic_flag：自旋锁实现基础，CAS 自旋，适合锁持有时间极短的场景；
- std::lock_guard/unique_lock：RAII 封装，自动解锁（lock_guard 简单不可手动解锁，unique_lock 更灵活）。



## 反射

反射类的字节码，Class.forName,  .class,  getClass, Method, Filed, Contructor

android中反射，有一些限定。

## 泛型

编译完成后，泛型就擦除变成了Object（指定则变成指定的上限）。

## 注解

Annotation，可以在运行时获取注解，不过在android上普通比较嫌弃。

纯java运行时注解。

编译时注解。

## 多线程

executorService比较简单：

```java
static ExcutorService myNewTest() {
  ExecutorService pool = new ThreadPoolExecutor(2, 4, 60000L, TimeUnit.MILLISECONDS, 
  new ArrayBlockingQueue<Runnable>(3), 
  Executors.defaultThreadFactory(), 
  new ThreadPoolExecutor.AbortPolicy());
  //我们给coreSize2，maxSize4，并且给了ArrayBlockingQueue容量为3的队列。
  //所以当前我们可以先跑2个线程运行，并且队列是空着的；
  //这个时候2个线程还没有干完，又来活儿了，加入到队列中，直到满；
  //当满了，如果maxSize是大于coreSize的，会将现在来的任务直接干（也就是比先加入队列的还要先干活，是不是超出你的想象？）
  //如果还是超过了，就报错。
}

//以下是源码中的Excutors.java:
public static ExecutorService newSingleThreadExecutor() {
  return new FinalizableDelegatedExecutorService
    (new ThreadPoolExecutor(1, 1,
                            0L, TimeUnit.MILLISECONDS,
                            new LinkedBlockingQueue<Runnable>()));
  //单线程池
  //coreSize，maxSize为1，表示了不可能有额外创建线程的可能；只有1个。
  //时间是0，永远不释放。
  //并且使用链表无限排队。
}

public static ExecutorService newCachedThreadPool() {
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue<Runnable>());
  //与OKHTTP内部线程模型一样
  //coreSize 0, 60的时间，表示没活一段时间后会释放；
  //SynchronousQueue,一个假的队列一直是满的。根据图片规则，超过了就新建线程去了。
  //同时，maxSize Int上限，表示无线创建线程；
  //适用于最大化并发，并且又能够在一定时间内的复用线程。
}

public static ExecutorService newFixedThreadPool(int nThreads) {
  return new ThreadPoolExecutor(nThreads, nThreads,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>());
  //coreSize=maxSize表明不能新建；
  //linkedblockingQueue表明无限压任务排队；
  //0L时间表示不回收线程。
  //适用于固定数量的线程，永远不回收。与单个线程类似。
}
```

自定义线程池：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
```

corePoolSize：描述核心个数。超过核心个数会进入BlockingQueue；

maxSize:          描述最多创建线程数。

blockQueue:   对逻辑产生重大影响。

* SynchronousQueue（无内部容量同步队列）

  没有容量，即（队列是否满了）判断永远是“满了”。

* ArrayBlockingQueue （指定容量的数组阻塞队列）

* LinkedBlockingQueue( 链表阻塞队列) 

  内部是链表，无限往下挂item，即(队列是否满了)判断永远为“未满”。

<img src="https://img-blog.csdnimg.cn/8848b183c1c9471a81d6f6a5a41efede.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAanpsaGxsMTIz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:45%;" />

深入理解和背诵图片，结合，如下4个case大致上就掌握了。



## ThreadLocal内存泄漏的原因

* weakReference和threadLocal的基本用法

  必须放在这里，因为后面好用于解析源码的时候回忆。

```java
//weak ref
WeakReference<Activity> ref = new WeakReference<>(activity);

//thread local
ThreadLocal<String> local = new ThreadLocal<>();
local.set("test");
String s = local.get();
local.remove();
```

* 代码结构

<img src="https://i-blog.csdnimg.cn/blog_migrate/9881acb6c08058a18504acf3a1439054.png#pic_center" alt="threadLocal" style="zoom:40%;" />

画图结合使用逻辑，就清楚了。

假设我们自己的代码中local已经没有引用了，比如Test已经置为null，或者local置为null，可达性已经失去；

那么，作为Entry的key就被回收；而value是强引用设置的值，如果是复杂类型数据的话，就会长时间留存在ThreadLocalMap(table)数组中。在某些get(), remove() , resize() 扩容,set()动作的时候，会尝试clear部分key为null的entry，移除数组并标记value=null，去除引用。

但是这些动作并不一定能跑进去。而且假设你申请的local并不是特别频繁使用的话（即很少调用set，remove, get），这个value的引用将会存在无法回收。

**解决方案：用完记得remove掉。比如Thread结束的时候，或者数据使用完后，记得remove()。有的帖子说搞成static，下面我将Handler会提到。**

* 扩展点1：多线程下有几个local？几个map？多个local变量申明呢？

  * 假设1个local变量，多线程：

    这个很容易理解了吧，每个Thread下面都挂着一个map，只是我们这一个local被多次拿去做Entry key了，保存着不同的value。

    Android Handler就是这个模式。

  * 假设多个local变量，单线程：

    <img src="https://i-blog.csdnimg.cn/blog_migrate/926da668cd9b6f8fbdc56d5b381f459d.png#pic_center" alt="threadlocalMulti" style="zoom:33%;" />

    如灵魂画手，即，该线程下的map的数组不再是单个Entry元素了。而是多个k v组成。

  * 假设多个local变量，多线程：

    这下好理解了，不用多说。每一个线程都有map，map下的数组就对应有多个Entry（local组成弱引用的key，和value）。

    


* 扩展点2 Android Handler

      就是把Looper对象，申明了一个static的LocalThread<Looper>在我们prepare的时候，进行初始化。这样的情况，就保证了每一个线程，在new出来的时候，都会创建一个独有的Looper。
      
      所以说，ThreadLocal和Thread有什么关系呢？Thread只和ThreadLocalMap有关，而我们申明的变量，ThreadLocal是作为ThreadLocalMap的数组中一个元素的key(weakRef)。

  那为什么在Handler和Looper源码中看不到remove来解决内存泄漏呢？

  这里他使用static来标记threadLocal变量。即保证了所有线程只有一个key。这个key永远不会被回收了。则不会出现key=null，value存在的现象。但是假设HandlerThread被回收，Looper作为value会被先回收。理论上讲，他并没有考虑内存问题。如果线程和Looper搞的多，在前面提到的逻辑中，靠的ThreadLocal内部代码的比如set，或者resize的时候，进行清理（详细可以阅读ThreadLocal.java：set()->cleanSomeSlots，即每次设置值都会尝试清理清理）。

  

## JVM运行时分区

进程共享：方法区(常量池) （类信息，常量，静态变量）,  堆区（类的全局变量跟随类new出来的）；

线程私有： 虚拟机栈（临时变量），本地方法栈，程序计数器。

## classLoader

类加载器，最开始是给Java Applet（一种Html+下载Java代码来执行逻辑的应用程序）。这就要求JVM能够动态加载java代码，因而设计出来。

`java.lang.ClassLoader` 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 `java.lang.Class` 类的一个实例。

https://developer.ibm.com/zh/articles/j-lo-classloader/

https://www.jianshu.com/p/fe2f739928ec

https://segmentfault.com/a/1190000004062880

https://blog.csdn.net/dongbaoming/article/details/54312824?utm_source=blogxgwz5



## java类加载流程

类从被加载到JVM中开始，到卸载为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。

Loading：查找class到内存

Linking:  验证(字节码是否合规)，准备(静态变量，空间并附默认值)，解析（直接引用常量池）

Initialization: 初始化，真正的值变更。



### 类加载器&双亲委托

* java里面：

customClassLoader->applicationClassloader->extersionClassLoader->bootstrapClassLoader

```java
protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // First, check if the class has already been loaded
    // 1.先查找该 Class 是否已经加载过，若加载过，则直接返回。
    Class<?> c = findLoadedClass(name);
    if (c == null) {
        try {
            if (parent != null) {
                // 2.委托给父加载器进行加载。
                c = parent.loadClass(name, false);
            } else {
                // 当执行到顶层的类加载器时，parent = null
                c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // ClassNotFoundException thrown if class not found
            // from the non-null parent class loader
        }

        if (c == null) {
            // 3.如果父加载器也没有找到，则自己尝试加载。该方法的逻辑由具体子加载器实现。
            c = findClass(name);
        }
    }
    return c;
}

// 由子类自己实现
protected Class<?> findClass(String name) throws ClassNotFoundException {
    throw new ClassNotFoundException(name);
}
```

像极了事件分发，onInterept()就是在本类中进行拦截，就直接return掉完成了；

如果本类不做处理，则给到parent去loadClass。如果parent有返回就是返回的。如果parent没有返回的，则最终才轮到自己去创建，就像只有子View不消费，父控件才能触发自己的onTouchEvent。

也相当于二叉树的后序遍历。

```java
public void visit(TreeNode n) {
   //前序点拦截
   visit(n.left);
   visit(n.right);
   print(n.val); //后序点
}
```

前序遍历点做拦截处理；能最快的打破往下传递。

后序遍历点做自己的实现(打印，消费事件），当自己被访问链，即将离开的时候，才处理。



与事件分发的区别在于：

事件分发机制，onInterupt()是极度容易，而这里的拦截是父类的native方法。仅仅起到后续二次加载cache而已。



* 打破双亲委托

  loadClass修改；Thread处理；自定义classLoader。android一般用不上。 

* android里面：

  我们加载的dex文件，因此必须要自己实现classLoader了。

  主要分为：

  BootClassLoader（加载常用类）；

  PathClassLoader（加载系统类和应用程序类，已经安装的程序的dex）；

  DexClassLoader（可以用于外部加载dex，apk）

* 热修复：

  修复的原理就是将补丁 dex 文件放到 dexElements 数组靠前位置，这样在加载 class 时，优先找到补丁包中的 dex 文件，加载到 class 之后就不再寻找，从而原来的 apk 文件中同名的类就不会再使用，从而达到修复的目的。Application初始化就加载好它。



## 静态代理和动态代理

使用上，

1）必须实现InvocationHandler接口；

2）使用Proxy.newProxyInstance产生代理对象；

3）被代理的对象必须要实现接口。

```java
public interface IString {
    int length(String s);
}

System.out.println("s addr: " + System.identityHashCode(s));

IString news = (IString) Proxy.newProxyInstance(IString.class.getClassLoader(), new Class[] { IString.class},
                                                new InvocationHandler() {
                                                  @Override
                                                  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                                                    System.out.println("proxy addr: " + System.identityHashCode(proxy));
                                                    int an = (int) method.invoke(s, args); //重点：第一个参数是被代理的对象。
                                                    return an + 1;
                                                  }
                                                });

System.out.println(" news addr: " + System.identityHashCode(news));
var ans = news.length("hello");
System.out.println("ans: " + ans);

//执行结果
s addr: 2055281021
news addr: 834600351
proxy addr: 834600351
ans: 6
```

在invoke里面，

我们可以针对被代理的结果进行修改；或者插入额外执行信息；
甚至可以完全不调用它，换成adapter适配模式一样，替换掉。
还可以使用动态代理做成一种网络运行参数的配置规则。通过注解不同的interface，解析注解来访问网络。

* 原理

1. JDK里面源码，就是在Proxy.newProxyInstance的传入参数，

第二是传入想要代理的接口类，第三是传入InvocationHandler处理函数。

2. 动态生成的代码，类似如下：

```java
public class NewStringImpl extends Proxy implements IString{
    protected InvocationHandler h; //在父类Proxy里面
  
    private static Method m1;
    private static Method m0;
    private static Method m3;
    private static Method m2;
  
  	public String length() {
       h.invoke(this, m, null);
    }
  
    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }
  
      static {
        try {
            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));
            m0 = Class.forName("java.lang.Object").getMethod("hashCode");
            m2 = Class.forName("java.lang.Object").getMethod("toString");
          
            m3 = Class.forName("xxxx.IString").getMethod("length");
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
```

也就是说，JDK帮我们生成了一个类:

1. 它继承了Proxy；父类Proxy里面含有一个我们构造的时候的第三个参数InvocationHandler h；
2. 实现了我们传入的第二个参数接口；

3. 生成了toString, hashCode, equals三个静态变量method，和目标函数静态变量method；
4. 在我们调用接口的函数的时候，触发的执行其实就是执行了InvocationHandler的回调。而method.invoke(Object obj, Object... args)，第一个参数为对象（即Proxy.newInstanace出来的这个对象）。

因此，需要注意：

不能在invoke函数里面调用System.out.println(proxy)，会导致死循环，因为toString也会invoke给到这个函数。导致不断死循环。

可以看到，m0~m3的class.forname。才会有框架代码判断if (Object.class.equals(method.getDeclaringClass())) 的拦截。

