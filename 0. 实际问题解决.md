### 虎一

#### jsbridge2.0 

> 它的原理**loadUrl** + **shouldOverrideUrlLoading + Iframe.src**更新的相互通知的机制。
>
> 1. 准备工作做好基础的插入js片段；
> 2. 通过native java代码将消息拼接到一段执行handleMsgDisptach的script字符串，调用WebView的loadUrl(script)；通过这种方式实现native调用WebView js；
> 3. js掉native，则是通过iframe.src的赋值，进而触发native的shouldOverrideUrlLoading函数；native可以解析得到消息内容。
> 4. 然后设计一些缓存map，msgId，做callback实现等。

但是到了今天，可以摒弃4.x。于是我基于该框架，并完全兼容以前的前端H5代码，实现了jsbridge2.0。目前公司日活顶峰50w+。支持androiod5.0+，使用evaluateJavascript和重写，代码上也能简化。

> 我的原理webView的`addJavascriptInterface(bridgeObject)` + `evaluateJavascript` 
> JsBridge主要的目的是解决四种逻辑：
> native -> H5; 
>
> H5 -> native; 
>
> native -> h5并有回调；
>
> H5->native并有回调。
>
> 1. 准备工作做好基础的插入js片段；并插入addJavascriptInterface的对象体；
> 2. native调用js很简单，直接evaluateJavascript("WebViewJavascriptBridge._handleMessageFromNative('%s');")就可以传递内容而且没有2MB大小限制；
> 3. js调用native也简单，通过对象体的加了`@JavascriptInterface`的函数直接调用native函数(jsCall)即可。
> 4. H5->native的回调设计：js调用native的时候，把js的callback体缓存到一个map中，并创建msgId，和消息体形成Message通过jsCall调用到native；native解析Message，同步也好异步也好，再将msgId结合结果信息封装Message通过evaluateJavascript回调_handleMessageFromNative回来，然后从map中提取callback去执行；
> 5. native->H5的回调设计：native通过执行js调用，封装msgId和消息体，给到了js去_handleMessageFromNative。js处理完成后，通过直接调用JavascriptInterface的函数jsResponse往native调用。native通过Message解析出之前的msgId，进而将缓存的callback提取并执行回调。
> 6. 还设计了handleName来实现统一分类逻辑，native和H5都有map（messageHandlers）提供注册好需要执行的处理函数。

* 优化点

> 解决原代码1.0.4和master中的问题：jsbridge2.0 解决了大量存在的问题。

* 新增scheme uri跳转支持。
* onPageFinished插入js片段问题
坑点：某些网址无法触发。
包括他现在的代码都是在onPageFinished以后才loadJs文件，这个时机对于某些在线网址，可能由于某些组件刷新机制，或者加载过慢的情况，无法触发。改成onPageStarted 后500ms或者onPageFinished立刻执行加载，来保证一定执行。
* 无法通信原因是iframe被清理
    坑点：有的网址使用的某些框架搭建的，无法jsbridge通信，研究了很久，发现iframe会被清理。
    js注入片段，调整init执行顺序。master有解决。
*  二次过快执行loadUrl导致丢失指令
    坑点：通信框架出现问题或者消息丢失
    原因loadUrl多次，导致_fetechQueue多次，第一次的iframe将messageQueue传递了进去，但是没有触发shouldOverride，第二次的messageQueue又是空的。
    导致消息丢失。master有从js的执行上做了延迟处理解决。我遇到的就是chromium版本低的情况，出现该问题。导致，初始化信息未能给到WebView。
    之所以原来的代码这样做是为了支持android4.x，那么，到了今天我们的app基本上最低要求minSDK都是android6.0+，甚至8.0了。
    所以抛弃掉使用shouldOverride这套机制，而是直接通过evaluateJavascript来实现，这样可以避免大量的来来回回的传递消息。也解决此问题。
* 长度过长loadUrl vs evaluateJavascript
    master上有根据长度，做了处理。大约2M。原因是webView限制loadUrl的长度，而evaluateJavascript不限制。无此问题。
* 效率对比
    抛弃4.4的loadUrl+shouldOverrideUrlLoading +iframe更新机制。
    完全采用evaluateJavascript即可。
    既能简化jsbrige框架，又能提升效率。无需来来回回的向上向下通知。



#### 蓝牙android14 mtu

给google提了issue，最终得到答复，系统默认requestMtu是没用的；传参是不准的；要以自己request下去的值为准。



#### androidStudio Handler removeCallbacks

```kotlin
Handler.removeCallbacks { 

} //黄色提醒is an implicit SAM conversion, so the instance you are removing here will not match anything. 
```

Lambda会编译成静态函数或者匿名内部类变量。经过转换都不是同一个runnable。

https://blog.csdn.net/jzlhll123/article/details/143391144?spm=1001.2014.3001.5501



#### mmkv版本号之争

腾讯版本号1.3.5有bug。结果导致armv7/x86手机开始报错，提示 “libmmkv.so” not found。

https://blog.csdn.net/jzlhll123/article/details/140275739?spm=1001.2014.3001.5501



#### iconfont解决字体排版

https://blog.csdn.net/jzlhll123/article/details/140117623?spm=1001.2014.3001.5501



#### kotlin低版本gson解析错误

https://blog.csdn.net/jzlhll123/article/details/139398967?spm=1001.2014.3001.5501

gson在高版本加了一个check，会报错，二级嵌套泛型获取的解析方式问题。

如果是java,必须如下操作，通过`TypeToken.getParameterized`来获取嵌套泛型类型解析：

```java
public static <T> T parse(String jsonStr, Class<T> t) {
    return new GsonBuilder().create().fromJson(jsonStr, t);
}

public static <T, T2> MyCmd<T2> parseLv2(String jsonStr, Class<T> t, Class<T2> t2) {
    Type typeToken = TypeToken.getParameterized(t, t2).getType();
    return new GsonBuilder().create().fromJson(jsonStr, typeToken);
}
```

如果是kotlin，则直接通过inline reified:

```kotlin
inline fun <reified T> String.fromJson(): T {
    return Globals.gson.fromJson(this, object : TypeToken<T>() {}.type)
}
```

这个函数，在低版本kotlin的时候会出现嵌套泛型解析错误。



### 阿里-天猫精灵

#### audioRecorder、tinyalsa

#### 架构

分层：

​	底层库、三方库：okhttp/阿里网络库，glide，crashSDK，fastjson, jetpack， 埋点库...

​	团队封装库：统一线程池，glog，网络二次封装库，团队路由框架，性能监控...

​	业务模块：消息中心，精灵球，闹钟，联系人，音乐；语音采集核心库，识别库

​	壳工程

通信：

​	隐式路由uri实现（都是为了解决跨模块之间，互相不知道class类然后需要跳转而做的一些框架设计）；

​	IPC通信框架（contentProvider实现的；主要是在rom上容易被拉起进程，就可以直接自动初始化；）

​	EventBus应用进程内通信。	

### 阿里-后装车载

#### mp4循环录制

​	录像 vs 8.0

#### mp4 vs TS保存问题

​	mp4容易播放当时。

​	ts在手机上不容易播放。

#### aidl多进程分割

​	视频管理，播放。减少内存占用。

​	aidl传递给手机app。

#### cpu温度处理

​	分辨率，帧率，动态调整，系统SystemServer进程追加监控线程。通知各个模块

#### 离屏显示

​	桌面，小窗口

#### 双路录制

​	cameraService处解开

#### ADAS集成

​	寻找HAL copy buff，解析。



### 解决方案收集

ScrollView + RecycleView导致RecycleView有一堆的问题，这边汇总一些常见解决方案，并把一些原因尽量分析和阐述出来。

* 只显示一个Item；

* 显示不全，只显示3-4个，（其实是显示了控件限定的大小的item个数），而且无法滑动；

* 全部正常显示，但是没有复用，每次都是全部加载完；

* item跟整个限定的rv的大小一样，是因为item的布局写了match——parent导致！

* 解决事件分发冲突中，产生Item间距变大问题； 

  是因为调用了某个函数导致不断累积间距。

  

Glide圆角不生效的一个原因可能是你的图片设置的是centerCrop。应该换成fitXY，因为你期待了你们图片就是那么大。让他fitXY就好了。

  

```xml
<HorizontalScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <!-- 整体滑动 -->
    <RelativeLayout
        android:layout_width="wrap_content"
        android:layout_height="match_parent">
        <!-- otherview 其他控件略-->
        <RecycleView
                android:id="@+id/rv"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"/>
    </RelativeLayout>
</HorizontalScrollView>
```

这样写的布局，ScrollView无所谓match或者wrap，而Relayout和RecyclerView的方向上的宽度或者高度会有影响，会对结果产生一堆不同的BUG。



1. onCreate里面设定不采取死rv的width，则全部有，但是复用失效；

   	原因：由于没有限定RecycleView的大小；而ScrollView又是无限的；因此被当做了全部显示，故而没有复用机制；MeasureSpec.UNSPECIFIED 模式会导致LinearLayoutManager中的fill方法中判断是否可以无限制填冲整个recycleview为true，从而导致RecyclerView的复用失效。

2. onCreate里面设定死rv的width （或者xml中写死） 则导致只有1个；

   	原因：未知；

3. onCreate里面设定rv_hold的width，则只能加载这么多宽度的item个数。

4. 修改了拦截效果，仍然出现了item之间的距离变大。

5. 采用了我的新方案：

   解决了外层ScrollView和内部RecycleView的冲突问题。但是出现了一个问题：

   1、 前提使用我的修改版NestHorizScrollView，并给Rv给一个外层Relayout套住，并限定外层Relayout的宽度；则会出现Rv的item间距变大；有复用；

   2、去掉RelativeLayout，直接在NestHorizScrollView里面放入效果一样。

   3、m6PartRecycleView.setNestedScrollingEnabled(false);则导致只有一个item。

   



#### 2.1 LayoutManager

```java
public class FullyLinearLayoutManager extends LinearLayoutManager {
 
    private static final String TAG = FullyLinearLayoutManager.class.getSimpleName();
 
    public FullyLinearLayoutManager(Context context) {
        super(context);
    }
 
    public FullyLinearLayoutManager(Context context, int orientation, boolean reverseLayout) {
        super(context, orientation, reverseLayout);
    }
 
    private int[] mMeasuredDimension = new int[2];
 
    @Override
    public void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state,
                          int widthSpec, int heightSpec) {
 
        final int widthMode = View.MeasureSpec.getMode(widthSpec);
        final int heightMode = View.MeasureSpec.getMode(heightSpec);
        final int widthSize = View.MeasureSpec.getSize(widthSpec);
        final int heightSize = View.MeasureSpec.getSize(heightSpec);
 
 
        int width = 0;
        int height = 0;
        for (int i = 0; i < getItemCount(); i++) {
            measureScrapChild(recycler, i,
                    View.MeasureSpec.makeMeasureSpec(i, View.MeasureSpec.UNSPECIFIED),
                    View.MeasureSpec.makeMeasureSpec(i, View.MeasureSpec.UNSPECIFIED),
                    mMeasuredDimension);
 
            if (getOrientation() == HORIZONTAL) {
                width = width + mMeasuredDimension[0];
                if (i == 0) {
                    height = mMeasuredDimension[1];
                }
            } else {
                height = height + mMeasuredDimension[1];
                if (i == 0) {
                    width = mMeasuredDimension[0];
                }
            }
        }
        switch (widthMode) {
            case View.MeasureSpec.EXACTLY:
                width = widthSize;
            case View.MeasureSpec.AT_MOST:
            case View.MeasureSpec.UNSPECIFIED:
        }
 
        switch (heightMode) {
            case View.MeasureSpec.EXACTLY:
                height = heightSize;
            case View.MeasureSpec.AT_MOST:
            case View.MeasureSpec.UNSPECIFIED:
        }
 
        setMeasuredDimension(width, height);
    }
 
    private void measureScrapChild(RecyclerView.Recycler recycler, int position, int widthSpec,
                                   int heightSpec, int[] measuredDimension) {
        try {
            View view = recycler.getViewForPosition(0);//fix 动态添加时报IndexOutOfBoundsException
 
            if (view != null) {
                RecyclerView.LayoutParams p = (RecyclerView.LayoutParams) view.getLayoutParams();
 
                int childWidthSpec = ViewGroup.getChildMeasureSpec(widthSpec,
                        getPaddingLeft() + getPaddingRight(), p.width);
 
                int childHeightSpec = ViewGroup.getChildMeasureSpec(heightSpec,
                        getPaddingTop() + getPaddingBottom(), p.height);
 
                view.measure(childWidthSpec, childHeightSpec);
                measuredDimension[0] = view.getMeasuredWidth() + p.leftMargin + p.rightMargin;
                measuredDimension[1] = view.getMeasuredHeight() + p.bottomMargin + p.topMargin;
                recycler.recycleView(view);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
        }
    }
}
```

然后设置：

```java

FullyLinearLayoutManager fullyLinearLayoutManager = new FullyLinearLayoutManager(getActivity());
fullyLinearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
/**
         * 当平滑滚动启用时，滚动条把手的位置和大小基于可见条目的可见像素数来计算。
         * 该处里假定所有列表条目具有相同的高度。如果你使用条目高度不同的类表， 滚动条会在用户滚动过程中改变大小。
         * 为了避免这种情况，应该禁用该特性。 当平滑滚动被禁用后，滚动条把手的大小和位置只是基于适配器中的条目数， 以及适配器中的可见条目来确定。
         * 这样可以为使用可变高条目列表的用户， 提供稳定的滚动条。
         */
fullyLinearLayoutManager.setSmoothScrollbarEnabled(true);
//TODO 开启自动测绘
fullyLinearLayoutManager.setAutoMeasureEnabled(true);
recyclerView.setLayoutManager(fullyLinearLayoutManager);
//设置不允许嵌套滑动，因为嵌套滑动的话会导致错乱
recyclerView.setNestedScrollingEnabled(false);
recyclerView.setAdapter(mAdapter);
```

GridLayoutManager也类似。



#### 1.2 给RecycleView套一个Relayout

```xml
<RelativeLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:descendantFocusability="blocksDescendants">
  <!-- blocksDescendants 重要的 -->
    <android.support.v7.widget.RecyclerView
        android:id="@+id/lv_home_list"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"

        android:layout_marginTop="0px"
        android:background="@color/colorWhite"
        android:clipToPadding="false"
        android:visibility="visible">
  </android.support.v7.widget.RecyclerView>
</RelativeLayout>
```

descendantFocusability该属性是当一个为view获取焦点时，定义viewGroup和其子控件两者之间的关系。

http://stackoverflow.com/questions/27083091/recyclerview-inside-scrollview-is-not-working

https://github.com/amardeshbd/android-recycler-view-wrap-content

[Android 6.0 解决recyclerview 在 scrollview 中不能全部显示，高度不正常的问题。 - 小梦龙的个人页面 - OSCHINA - 中文开源技术交流社区](https://my.oschina.net/caomenglong/blog/747197)

据说解决高度不正常的问题。



#### 1.3 NestedScrollView替代ScrollView

因为这个组件是google专门给滑动冲突解决设计的ScrollView替代者，ScrollView和NestedScrollView的区别
滑动RecyclerView的时候ScrollView其它部分不动，还会有卡顿现象。这个问题可以将ScrollView改成NestedScrollView可解决。而横的ScrollView没有替代者仍然有滑动冲突问题BUG。



1. 显示1个，显示不全：

```xml
<HorizontalScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <!-- 整体滑动 -->
    <RelativeLayout
        android:layout_width="wrap_content"
        android:layout_height="match_parent">
        <!-- otherview 略-->
        <RecycleView
                android:id="@+id/rv"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"/>
    </RelativeLayout>
</HorizontalScrollView>
```




```xml
<HorizontalScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <!-- 整体滑动 -->
    <RelativeLayout
        android:layout_width="wrap_content"
        android:layout_height="match_parent">
        <!-- otherview 略-->
        <RelativeLayout
            android:id="@+id/rv_hold"
            android:layout_width="wrap_content"
            android:layout_marginTop="12dp"
            android:layout_height="match_parent">
            <RecycleView
                android:id="@+id/rv"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"/>
        </RelativeLayout>
    </RelativeLayout>
</HorizontalScrollView>
```

