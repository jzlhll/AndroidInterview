https://juejin.cn/post/6844903797270003719

https://juejin.cn/post/7267737437953720359

- mvp架构，如何实现一个Fragment，base系列如何实现？

- MVI，reducer？stateFlow


  单activity 、 Fragment设计。  
  	第一种FragmentManager，add/replace/hide需要自行管理Fragment的动画，返回栈。
  	第二种jetpack navigation。
  	第三种自己实现的。

  TouchDelegate


  刚刚绑定，等了很久才突然出现我的设备。



- 触摸事件的传递，事件分发，内部外部滑动冲突解决，View如何消费?

> 8.讲讲View的绘制和事件分发
>
> “在Android中，View的绘制和事件分发是两个核心流程，分别对应界面的呈现和用户交互。这两个流程内部都具有很多细节与优化，下面我详细讲讲它们的内部机制和如何保证高效运行。
>
> 首先说绘制过程。View的绘制流程主要可以分为三个阶段：Measure（测量）、Layout（布局）和Draw（绘制）。
>
> 测量阶段：
> 在这个阶段，系统会调用每个View的measure()方法，目的是让每个View根据父容器给出的MeasureSpec来计算出自身的宽高。父视图会传递测量规格，子视图则根据这些规格做出响应，从而确定最适合的尺寸。这一过程不仅确保了各个View都能在有限的空间内正确呈现，也为后续的布局阶段做好了准备。
>
> 布局阶段：
> 当各个View都知道自己的尺寸后，父容器会调用每个子View的layout()方法，来确定它们在屏幕上的具体位置。对于ViewGroup来说，它要遍历所有子View，计算它们在容器内的摆放位置。在这个过程中，父容器需要平衡内部视图之间的关系，比如对齐、间距以及重叠等情况，保证整体UI合理显示。
>
> 绘制阶段：
> 绘制阶段是实际把界面内容呈现出来的时候，调用draw()方法。每个View的draw()包括绘制背景、绘制自身（调用onDraw()方法）以及绘制子View（对ViewGroup而言，还会调用dispatchDraw()方法来绘制所有子View）。Canvas在这个过程中起到关键作用，所有的绘制操作都在Canvas上执行，最终将图形渲染到屏幕。这一过程经过大量优化，比如视图合并、硬件加速等，确保整个绘制过程既高效又美观。
>
> 接下来是事件分发的流程。当用户与屏幕交互（比如点击、滑动等），系统会首先捕捉到这类触摸事件，然后通过一个专门的事件分发机制传递给各个View。
>
> 事件分发起点：
> Android框架会将捕获到的事件传至Activity，然后由Activity递归地交给根View来处理，调用dispatchTouchEvent()方法。这是整个事件分发链的起点。
>
> 分发到ViewGroup：
> 当事件到达ViewGroup时，它会首先在dispatchTouchEvent()内部调用onInterceptTouchEvent()方法，这个方法允许ViewGroup根据具体情况决定是否截获事件。如果返回true，说明这个ViewGroup想消费这个事件，不继续分发给子View；而返回false则说明允许事件传递到内部的子View。
>
> 子View事件处理：
> 如果不被拦截，事件就会继续传递给对应的子View，由子View的dispatchTouchEvent()调用onTouchEvent()来真正响应用户交互。在这个方法中，会根据事件类型，比如ACTION_DOWN、ACTION_MOVE和ACTION_UP来做出具体的业务处理，比如响应点击、滑动、长按等。
>
> 事件回传：
> 同时，在事件消费的过程中，还可能出现回传处理：如果一个View没有完全消费事件，事件可能会沿着视图树向上传递，直到有父View来处理未被消费的部分，保证事件不会丢失。
>
> 总的来说，绘制和事件分发流程都是严格遵循单向流程，并通过递归遍历对应的视图树。绘制流程确保了UI能够高效地更新和渲染，而事件分发则确保了用户交互可以精准地传递到需要响应的View上。这两个过程不仅各自深度优化，而且相互独立运行，保证了用户界面的流畅性和响应性。

- 自定义View中，getMeasuredWidth和getWidth有什么区别?

  getMeasureWidth getWidth在不干扰系统代码的层面上是会相同的；

  一个是measure后确定的宽度，一个是layout后真实的宽度。

  如果在onLayout方法里面做了处理改变了，则会有差异。

- 线程池如何管理？异常如何处理？

​		最后一个参数就是给出一个new Thread的模板；你可以给thread设置同一个exception处理器。

* 应用启动速度优化?

* activity启动速度优化？

* view优化。viewstub原理，哪些方法被跳过？如何被替换？

  1. 仅仅做了一些获取id，layoutId的事情，没有正式去inflate；

  2. onMeasure的设置了0,0的高宽；也设置visible Gone。不做绘制
  3. 对比View.GONE,是其他的都做了，仅仅是最后的绘制不做。

* RecyclerView原理，RecylerView优化?

  > 6大部件：
  >
  > LayoutManager: 接管measure，layout，draw
  >
  > ItemDecoration： Item添加子View需要自行添加和实现
  >
  > ItemAnimator：添加删除时候的动画
  >
  > Adapter： 主体逻辑组织，生产ViewHolder，绑定。
  >
  > ViewHolder：子布局
  >
  > Recycler： 缓存池
  >
  > 缓存原理：
  >
  > 4层：
  >
  > 1. mAttachedScrap，可见范围的ViewHolder。mChangedScrap有变化的数据；
  > 2. mCachedView，只有2个。后来的recylerView增加了预取那就是2+N；
  > 3. ViewCacheExtension，开发自行实现的缓存；
  > 4. RecycledViewPool，不同的缓存类型默认5个；
  >
  > 优化：
  >
  > notifyItemChanged: 可以设置payload;进行部分控件规则刷新
  >
  > diffutil计算并，notifyRangeChanged: 局部刷新几个更新
  >
  > 减少层级；透明度，背景重叠移除；
  >
  > onCreateViewHolder里面做一些点击监听；不要搞到onBinderViewHolder里面去；
  >
  > 目的都是为了减少onCreate和onBinder
  >
  > 额外设置缓存；
  >
  > 固定fixedSize

* 数据本地化方案：文件、sp、数据库， mmkv

* SharedPreference的commit和apply区别、有什么问题?如何解决?

  commit提交到内存，然后同步落盘，有返回值；

  apply提交到内存，然后异步落盘，没有返回值。

  SP的主要问题有2个：

  1. 初始化SP是异步的；但是如果马上去读取就卡住了；解决办法，多分几个名字来存储，保证每一个比较小；
  2. 在ActivityThread处理生命周期Pause/Stop（服务|Activity）， QueueWork.waitToFinish的时候卡住。
     解决办法，hook sFinished poll。不让他等待了。网上一大堆代码。

* 子线程能刷新UI么？为何只能主线程刷新UI？

* 泛型

  ```java
  //定义一个子类继承泛型父类，并给这个泛型一个实际的类型
  class SubClass extends ParentGeneric<String>{
  
  }
  
  //匿名内部类，其实我们定义的这个匿名内部类也是一个子类，它继承了泛型父类，并给这个泛型一个实际的类型
  ParentGeneric<String> parentGeneric2 = new ParentGeneric<String>(){};
  ```

​		因此如果我们想要获取某个泛型类型，我们可以通过子类的帮助去取出该泛型类型，一种良好的编程实践就是把当前需要获取的泛型类用 abstract 声明

​	泛型擦除；泛型膨胀

* JVM，DVK，ART

  JVM是在PC，服务器比较合适；指令集减少，压缩class，变成dex；

  DVK|ART分别是JIT，AOT。最新的又有杂糅。

* Handler机制以及相关知识。
* Activity和Fragment生命周期。
* Android四大组件相关的知识。
* Android进程间通信的方式。
* Context相关的知识。
* Activity的启动模式。
* Android动画相关知识。
* Android自定义组件相关知识。
* Android事件分发机制以及触摸事件冲突的处理。
* ANR产生的原因以及避免ANR的方式。
* 内存泄漏产生的原因以及定位解决的方式。
* Android页面渲染机制以及优化方式。
* LinearLayout、FrameLayout、RelativeLayout和ConstraintLayout的理解和性能对比。
* Android各版本的特性。
* Android屏幕适配的技巧。
* MVC,MVP,MVVM的理解与实践。
* Android的主题、样式、属性相关的内容。
* JNI相关的知识。

* 泛型

  ```java
  //定义一个子类继承泛型父类，并给这个泛型一个实际的类型
  class SubClass extends ParentGeneric<String>{
  
  }
  
  //匿名内部类，其实我们定义的这个匿名内部类也是一个子类，它继承了泛型父类，并给这个泛型一个实际的类型
  ParentGeneric<String> parentGeneric2 = new ParentGeneric<String>(){};
  ```

  	因此如果我们想要获取某个泛型类型，我们可以通过子类的帮助去取出该泛型类型，一种良好的编程实践就是把当前需要获取的泛型类用 abstract 声明

  泛型擦除；泛型膨胀

* JVM，DVK，ART

  JVM是在PC，服务器比较合适；指令集减少，压缩class，变成dex；

  DVK|ART分别是JIT，AOT。最新的又有杂糅。

  

#### 三、android启动优化

https://github.com/alibaba/alpha 异步启动框架



开发者模式 -> 显示 CPU 使用情况 第一行数字
分别是1/5/15分钟观测。
cat /proc/loadavg

https://scoutapm.com/blog/understanding-load-averages?spm=ata.13261165.0.0.5f70438d79v9fH


* 编译

  android执行代码是从dex字节码（class打包在一起），通过ART或者dalvik runtime转换为机器码。

  Dalvik是JIT即时编译，ART是5.0开始的AOT预编译（**dex2oat**工具）。

  7.0开始混合编译。

新学习的linux命令：

倒数100行日志打印。

```shell
tail -100 a.log     
```

#### 四、hook

#### 五、注解

##### 1. 编译时

##### 2. 运行时



#### 六、内存

标记清除算法；复制；整理；

GC Roots： 类静态对象；常量对象；本地变量，栈对象；JNI引用独享；

可达性分析：

从GC Roots一直往下搜索；

https://blog.csdn.net/a779868946/article/details/105927910

##### 2. profile用法、MAT

record/拉去时间标记

这是：finalizerReference：虽然很多，但是正常的。只要重写了finalze()方法，就会有。所以这个忽略。

左下侧 className->  instance view -> allocation call stack 把一组很多同样的比如String,Path等说明在抓取的几秒时间内有很多内存的分配，点10来个看看，有黑色的方法里面就说明这个函数里面有不断的新建对象，（灰色是framework方法，黑色是自己的方法）

```
paint.setColor(Color.parseColor(color[2])), 就会有String的创建。说明parseColor会
```

DDMServer是监控的对象申请。



1. 注意循环体和常调用的函数避免重复创建对象；
2. 对象池。



MAT可以查看引用关系

hprof，MAT查看。dominator tree大对象建议,leak 内存泄漏建议；

Histogram调用栈，然后搜索类名，class name; 可以看到引用链。

##### 3. 泄漏

leakCanary

写代码如何注意防止内存泄漏？

注意root节点；注意weakRef的使用；注意Context/Application；注意生命周期的长短；借助监控leakCanary；



#### 11、android新特性

Android16 实时活动；强制旋转兼容

android15 16kb对齐；默认启动全面沉浸式适配

android14蓝牙权限，BLE MTU

Android13 媒体权限不断调整，forgroundService不断限制

android12 启动画面



#### 12、字节码插桩

ASM bytecode 



#### 13、计算机基础

寄存器：存在CPU当中，速度极快，



#### 15、 HashMap



#### 16、ActivityLifecycleCallbacks



TabLayout ViewPager Fragment



ARouter



#### 17、AIDL

AIDL的标签

AIDL oneway作用不得有返回值，表示调用后，不管结果，也不阻塞。AIDL in，out，inout有点类似C#的传参。in不关心结果，out不关心输入。目的：可以节约部分写入，减少远程调用的内存和时间消耗。

Binder



#### 插件化





#### Jar包处理相关



#### 对象池


#### AOP

https://www.jianshu.com/p/50f3e7c9becc?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation

`aop`的思想是，针对业务处理过程中的切面进行提取，是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果
 简单讲，使用的时候是**关注具体的方法和功能切入点， 不用关心所在的类或者对象， 只关注功能的实现**。

基本就是日志入侵。路由框架这类。



#### linux IO



#### 冷启动热启动



#### liveData && observer& observable

#### Cookie & Token & Session



### Gradle常见错误

./gradlew app:dependencies > log_dependencies.txt 打印所有依赖



### 减少方法数

https://www.iteye.com/blog/chroya-2254365

### 编译速度加速
./gradlew clean assDebug --profile -Pversion=21 --console=plain -Paspectj=false -Dorg.gradle.daemon=true -Dorg.gradle.project.resguard=false
MinSDK设置：minSdkVersion 21
开启Gradle Daemon和并行构建
org.gradle.daemon=true
org.gradle.parallel=true
避免编译不必要的资源：resConfigs "en", "xxhdpi"
开启离线模式：--offline
调整daemon堆大小：org.gradle.jvmargs=-noverify -Xmx8192m -XX:MaxPermSize=2048m
启用构建缓存：该功能在gradle2.3以上默认开启，饿了么采用的是gradle4.4，默认已开启，命令行中把clean去掉即可；
对调试 Build 停用 Crashlytics ：
android {
  ...
  buildTypes {
    debug {
      ext.enableCrashlytics=false
    }
}
dexOptions设置
dexOptions {
  javaMaxHeapSize"4g"
  preDexLibrariestrue
}
最终
./gradlew assDebug --profile --offline -Pversion=21 --console=plain -Paspectj=false -Dorg.gradle.daemon=true -Dorg.gradle.project.resguard=false



### 加固

#### 加固手段

```
反模拟器：模拟器运行apk，可以用模拟器监控到apk的各种行为，所以在实际的加固apk运行中，一旦发现模拟器在运行该apk就停止核心代码的执行；

虚拟机保护：银行类app，运行比较卡，但是是自己做一个独立的虚拟机，保护；自建一个虚拟执行引擎，然后把原生的可执行代码转换为自定义的指令进行虚拟执行；

加密：样本的部分可执行代码是以压缩或者加密的形式存在的；比如，被保护过的代码被切割为多个小段，前面的一段代码先把后面的代码片段在内存中解密，然后再去执行解密之后的代码，如果一块块的迭代执行。
```

dex：文件操作。针对某一个具体的函数加密，需要了解dex的构造针对某个函数加密。

so：加固。

对整个dex文件的加密：

apk（dex1原）解压缩得到dex1原，进行AES整体加密，搞个壳dex2，合并后新的dex文件。然后将新的系列dex+剩余的apk资源。再打包回去。再签名。就是新的apk。

vmp：函数抽取思路。

dex结构：

apk打包流程：

aapt工具将Res文件生成R.java, 然后aidl工具生成java文件。再用java编译工具成.class文件。需要将.class再打包为android虚拟机运行dex文件。再把资源和dex打包成apk，压缩下，对齐，再签名。





