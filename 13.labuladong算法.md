# labuladong算法笔记

## 第0章核心框架汇总

### 0.1 框架思维

第一步：学习数组，链表；

第二步：刷二叉树。递归，都是树。再看回溯、动规、分治等算法专题。

重点：

* 忽略细节，不要在意n+1,n-1, == null。

### 0.2 刷题心得

#### 0.2.1数组、链表系列

* 单链表： **双指针**。暴力法则：HashSet缓存。

* 数组：

  * `二分搜索`：

  **两端向中心的双指针**。应用于有序数组；

  * `滑动窗口`：

  **快慢指针**。暴力解法则是O(n^2) 两重循环。而快慢指针降低到O(n)。应用于能明确可以扩大缩小的情况。

  * `回文串`：

  判断是不是回文串，使用双指针从两端向中心检查；

  寻找回文字串，则从中心向两端扩散。

  * `前缀和`：？
  * `差分数组`：？

### 0.2.2二叉树系列

二叉树的递归解法，分为两类思路：

第一类，**遍历一遍二叉树得到答案**；对应：回溯算法核心框架？。

```java
// 二叉树遍历框架
void traverse(TreeNode root) {
	if (root == null) {
		return;
	}
	// 前序遍历位置
	traverse(root.left);
  //中序遍历位置
	traverse(root.right);
	// 后序遍历位置
}
```

记住二叉树的递归先序、中序、后序遍历框架，父节点，分left，right递归。

第二类，**分解问题计算出答案**；对应：动态规划核心框架？。

```java
void levelTraverse(TreeNode root) {
    if (root == null) return 0;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    int depth = 1;
    // 从上到下遍历二叉树的每一层
    while (!q.isEmpty()) {
        int sz = q.size();
        // 从左到右遍历每一层的每个节点
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();

            if (cur.left != null) {
                q.offer(cur.left);
            }
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
        depth++;
    }
}
```

记住这个层次遍历的算法。通过一个辅助的queue的来回offer和poll解决。



### 0.3 二叉树纲领篇

思维模式：

**1、【遍历】：是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现。

**2、【分解问题】：是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。

无论使用哪种思维模式，你都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。

**二叉树所有的问题，都可以转变为框架和在三个位置的写入代码。**

> **void** traverse(TreeNode root) {    
>
> 	**if** (root == **null**)   { **return**;   }   
> 		
> 		 **// 前序位置**    
> 		
> 		traverse(root.left);    
> 		
> 		**// 中序位置**    
> 		
> 		traverse(root.right);    
> 		
> 		**// 后序位置** 
>
> }



>  **前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据**。
>
>  **一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。



### 0.4 动态规划解题套路

动态规划，一般就是求最值。**穷举**。

一般不采用递归，而采用循环迭代。

思考框架：

**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 `dp` 数组/函数的含义**。



### 0.5 回溯算法解题套路

### 0.8 双指针解决链表题目