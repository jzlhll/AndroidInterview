#### TCP/IP网络模型

应用层：用户态：http, ftp, DNS, SMTP 他们操作的是socket，而socket是操作系统和语言提供的基础能力；

传输层：内核态：tcp|udp。给应用层协议数据分包并添加tcp头，双方的端口，流量控制，拥塞控制，重传机制等；

网络层：内核态：ip。给tcp数据进行分包添加ip头。一个是寻址能力，一个是路由能力；

网络接口层：网卡，交换机，路由器这一层，电信号，数字信号的转换和进行mac头的不断地替换来传输。

#### 一次网页(http)请求的过程

http客户端->tcp->ip->网络->交换机：路由器->互联网物理↓

http客户端<-tcp<-ip<-网络<-交换机：路由器

* 第一步，解析URL，组装html报文；

* 第二步，将URL中的域名，解析成IP地址；

> 好处：
>
> 速记；服务器可换IP；CDN。
>
> 扩展：
>
> DNS服务器采用UDP通信（UDP 53端口），采信第一次解析的结果，递归或迭代查询。
>
> 容易被**DNS污染**(运营商屏蔽国外网站)和**DNS劫持**(攻击别人或伪装为别人的DNS服务器)。
>
> 请求DNS服务之前，又有浏览器cache，系统hosts，挡在前面。

* 第三步，网络程序通过Socket来委托协议栈工作

* 3.1 Socket

语言和操作系统来实现。

* 3.2 TCP/UDP

网络传输层，操作系统实现。超过一定的限制会拆包。

>  结构：
>
>  src端口号（应用程监听的序端口），dst端口（web服务器端口http80, https443），
>
>  包序号（解决包乱序），
>
>  确认号（不丢包，确认对方收到），
>
>  状态位（SYN，ACK，RST，FIN等，引起双方连接状态变化），
>
>  窗口大小（流量控制，标识自身处理能力）
>
>  拥塞控制等等

* IP(ARP&ICMP) 远程定位
  * 追加IP头

最关键的，追加src IP和dst IP。

> 如果有多网卡，还需要通过路由表选择src IP。路由表。跟子网掩码Genmask与运算，不匹配下一个。最后一个子网掩码是0.0.0.0。
>
> 另外就是NAT，实现内网IP+分析上层协议比如端口进行连接追踪，公网转换。

​	* 追加mac头

关键的追加src Mac（网卡rom mac）和dst Mac。

ARP协议：通过广播的方式获取mac，操作系统ARP缓存一段时间，用于查询以太网mac地址；

> 广播局域网内找IP对应的mac。如果是公网，则填写的是自家的路由器mac地址；一层一层转发，直到找到目标主机的路由器，路由器再通过arp协议找到内网的主机IP。

ICMP协议：传输控制网络包。

​	* 第三步，网卡驱动->物理网卡

网卡从IP模块复制到网卡缓存区，头尾追加信息。变成电信号发出去。此时终于走上的网线。

* 第四步，交换机

电脑出来的信号转为数字信号，不丢弃，全部缓存下来；

查询dst Mac地址与交换机端口映射表，发送到对应的端口上去。没有则全部发送，不对mac的设备会自动丢弃。

* 第五步，路由器

他类似网卡，有ip，有mac。而交换机没有mac。数据包到了路由器，mac头就扒掉；再通过ARP查询目标路由或者目标主机的mac地址，换上。

层层转发。

* 服务器已经收到

服务器收到以后，通过协议栈一层一层扒掉头部。最后得到http报文。

tcp协议先进行ack。

解析了数据以后，把结果数据，封装成http响应报文，再穿上tcp,ip,mac, 网卡，交换机，路由器，转发到网络上去。

#### TCP建立连接(三次握手)

Server：listen;

Client：**SYN** -> Server变为syn-sent；

Server：**SYN&ACK-**>client变成syn-recv;

Client：**ACK**->server变成ESTABLISHED；

Server: 变成ESTABLISHED。

保证双方都有发送和接收的能力。

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误（网络中延迟的重复分组）。

#### TCP断开连接(四次挥手)

A：**FIN**->B 变成FIN_WAIT_1;

B: **ACK**->A, 变成CLOSE_WAIT, 

A: A收到后变成FIN_WAIT_2;

B: **FIN**->A；

A：**ACK**->B,

所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

可能有人会有疑问，tcp我握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢.

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。

但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步**挥手**。



gateway genmask？

DHCP？

交换机？端口？

CDN？



#### http常见面试

1xx提示信息；2xx成功；3xx重定向；4xx报文有误；5xx服务端有误。

**host**：同一个服务器，不同的网站；

**connection**:keep-live 持久连接1.1。

**Content-type**: 数据类型；

**content-encoding** 编码。

**缓存**：浏览器缓存(cache-control, expires)；协商缓存的策略。

**http1.1**:

应用层协议容易替换下面的传输层协议。可读性很高。应用广泛。

**无状态**：好处，不用消耗内存磁盘来记忆；坏处，每次访问都要验证信息，cookie。

**明文**：安全性差。

**长连接**：超越1.0版本。

**管道连接**：好处同一个tcp连接，多个请求。但是会导致队头阻塞。

**https**:

公钥，私钥。SSL/TLS。在tcp三次握手之后。再开始的。

TLS1.2 4次握手。2个RTT。

1. clientHello->Server; 

2. ServerHello-> client;

​	Server证书，key交换等等->client; 

​	ServerDone->client;

3. client验证后密钥->server;

   证书->server;

4. change cipher spec->client; severFinish->client.

TLS1.3 1个RTT：

1. clientHello, cipher, key->Server;
2. ServerHello,key,finish->client;
3. client check finish->server

还有缓存情况下，各自再节约一次RTT。

**http版本**：

http/1.1：改善长连接；存在队头阻塞；头部偏大；服务器被动。

http/2：头部压缩；二进制；stream；多路复用（1个连接多个请求，不再串行阻塞）；主动推送；tcp层面的阻塞。

http/3: 

udp，自己实现应用层协议quic，更快的建立链接。

wifi->移动 IP虽然变化，但是sessionId TLS没有变化，更快的复用原来的连接，而TCP3次握手注定了更慢。

队头阻塞彻底解决。

#### http请求优化

缓存；

重定向优化：通过中间的代理服务器优化掉，因为他们基本属于内网级别；

减少请求次数：css图片合成；webpack打包；base64字符串；整合http请求接口。

http响应包压缩：encoding等方式。

**http&tcp keep alive**

http长连接是为了复用tcp连接，由应用层控制是否关闭；

tcp是内核在较长时间进行的探测，自动关闭连接。不过，往往服务器并不允许这么久。而且网络环境复杂断了也不知道哪里断的。



#### tcp粘包

对于包的概念有误，对于tcp而言，是流，没有边界的，他不知道你应用层的数据结构；因此可能你的数据会分成N个包，也可以多个数据组成一个包收到。

出现粘包的几种原因：1. TCP复用导致的（多线程复用同一TCP链接）；2. TCP内部算法可能会导致多个分组得到一个确认后一起发送；3. 数据包过大会被切分；4. 流量控制，拥塞控制；5. 接收方不及时接收。

解决的几个方案：

尾部标记序列比如按行读取；头部标记长度（head+payload）；发送数据定义长度。

#### websocket

一种全新的提供给web应用和server全双工通信的应用层协议。Html5新技术。打破传统http协议只能由client发起request的缺陷。http，需要借助SSE技术。

#### 数据安全怎么保证

1. 基础网络安全https前提: 

​	自定义银行级证书，okhttp请求里面预制；一般企业不做，是通过手机CA认证（存在wifi中间人攻击的可能性）

2. app api请求安全：

​	token，时间戳，服务器可以追踪和过滤，避免重复的篡改的请求攻击；

3. 端侧对于敏感数据可进一步进行加密，服务器反解密。
